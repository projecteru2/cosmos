// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `core.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct Empty {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Empty {
    fn default() -> &'a Empty {
        <Empty as ::protobuf::Message>::default_instance()
    }
}

impl Empty {
    pub fn new() -> Empty {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Empty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Empty {
        Empty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Empty>(
                    "Empty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Empty {
        static mut instance: ::protobuf::lazy::Lazy<Empty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Empty,
        };
        unsafe {
            instance.get(Empty::new)
        }
    }
}

impl ::protobuf::Clear for Empty {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Empty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListContainersOptions {
    // message fields
    pub appname: ::std::string::String,
    pub entrypoint: ::std::string::String,
    pub nodename: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub limit: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListContainersOptions {
    fn default() -> &'a ListContainersOptions {
        <ListContainersOptions as ::protobuf::Message>::default_instance()
    }
}

impl ListContainersOptions {
    pub fn new() -> ListContainersOptions {
        ::std::default::Default::default()
    }

    // string appname = 1;


    pub fn get_appname(&self) -> &str {
        &self.appname
    }
    pub fn clear_appname(&mut self) {
        self.appname.clear();
    }

    // Param is passed by value, moved
    pub fn set_appname(&mut self, v: ::std::string::String) {
        self.appname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appname(&mut self) -> &mut ::std::string::String {
        &mut self.appname
    }

    // Take field
    pub fn take_appname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appname, ::std::string::String::new())
    }

    // string entrypoint = 2;


    pub fn get_entrypoint(&self) -> &str {
        &self.entrypoint
    }
    pub fn clear_entrypoint(&mut self) {
        self.entrypoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_entrypoint(&mut self, v: ::std::string::String) {
        self.entrypoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entrypoint(&mut self) -> &mut ::std::string::String {
        &mut self.entrypoint
    }

    // Take field
    pub fn take_entrypoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entrypoint, ::std::string::String::new())
    }

    // string nodename = 3;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // repeated .pb.ListContainersOptions.LabelsEntry labels = 4;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // int64 limit = 5;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for ListContainersOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entrypoint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.appname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.appname);
        }
        if !self.entrypoint.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entrypoint);
        }
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.nodename);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.labels);
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(5, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.appname.is_empty() {
            os.write_string(1, &self.appname)?;
        }
        if !self.entrypoint.is_empty() {
            os.write_string(2, &self.entrypoint)?;
        }
        if !self.nodename.is_empty() {
            os.write_string(3, &self.nodename)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.labels, os)?;
        if self.limit != 0 {
            os.write_int64(5, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListContainersOptions {
        ListContainersOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "appname",
                    |m: &ListContainersOptions| { &m.appname },
                    |m: &mut ListContainersOptions| { &mut m.appname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entrypoint",
                    |m: &ListContainersOptions| { &m.entrypoint },
                    |m: &mut ListContainersOptions| { &mut m.entrypoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &ListContainersOptions| { &m.nodename },
                    |m: &mut ListContainersOptions| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &ListContainersOptions| { &m.labels },
                    |m: &mut ListContainersOptions| { &mut m.labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    |m: &ListContainersOptions| { &m.limit },
                    |m: &mut ListContainersOptions| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListContainersOptions>(
                    "ListContainersOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListContainersOptions {
        static mut instance: ::protobuf::lazy::Lazy<ListContainersOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListContainersOptions,
        };
        unsafe {
            instance.get(ListContainersOptions::new)
        }
    }
}

impl ::protobuf::Clear for ListContainersOptions {
    fn clear(&mut self) {
        self.appname.clear();
        self.entrypoint.clear();
        self.nodename.clear();
        self.labels.clear();
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListContainersOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListContainersOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pod {
    // message fields
    pub name: ::std::string::String,
    pub desc: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pod {
    fn default() -> &'a Pod {
        <Pod as ::protobuf::Message>::default_instance()
    }
}

impl Pod {
    pub fn new() -> Pod {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string desc = 2;


    pub fn get_desc(&self) -> &str {
        &self.desc
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        &mut self.desc
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desc, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Pod {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.desc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.desc.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.desc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.desc.is_empty() {
            os.write_string(2, &self.desc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pod {
        Pod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Pod| { &m.name },
                    |m: &mut Pod| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "desc",
                    |m: &Pod| { &m.desc },
                    |m: &mut Pod| { &mut m.desc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Pod>(
                    "Pod",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Pod {
        static mut instance: ::protobuf::lazy::Lazy<Pod> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Pod,
        };
        unsafe {
            instance.get(Pod::new)
        }
    }
}

impl ::protobuf::Clear for Pod {
    fn clear(&mut self) {
        self.name.clear();
        self.desc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pod {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pods {
    // message fields
    pub pods: ::protobuf::RepeatedField<Pod>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pods {
    fn default() -> &'a Pods {
        <Pods as ::protobuf::Message>::default_instance()
    }
}

impl Pods {
    pub fn new() -> Pods {
        ::std::default::Default::default()
    }

    // repeated .pb.Pod pods = 1;


    pub fn get_pods(&self) -> &[Pod] {
        &self.pods
    }
    pub fn clear_pods(&mut self) {
        self.pods.clear();
    }

    // Param is passed by value, moved
    pub fn set_pods(&mut self, v: ::protobuf::RepeatedField<Pod>) {
        self.pods = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pods(&mut self) -> &mut ::protobuf::RepeatedField<Pod> {
        &mut self.pods
    }

    // Take field
    pub fn take_pods(&mut self) -> ::protobuf::RepeatedField<Pod> {
        ::std::mem::replace(&mut self.pods, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Pods {
    fn is_initialized(&self) -> bool {
        for v in &self.pods {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pods)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pods {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pods {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pods {
        Pods::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pod>>(
                    "pods",
                    |m: &Pods| { &m.pods },
                    |m: &mut Pods| { &mut m.pods },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Pods>(
                    "Pods",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Pods {
        static mut instance: ::protobuf::lazy::Lazy<Pods> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Pods,
        };
        unsafe {
            instance.get(Pods::new)
        }
    }
}

impl ::protobuf::Clear for Pods {
    fn clear(&mut self) {
        self.pods.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pods {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pods {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodResource {
    // message fields
    pub name: ::std::string::String,
    pub cpu_percents: ::std::collections::HashMap<::std::string::String, f64>,
    pub memory_percents: ::std::collections::HashMap<::std::string::String, f64>,
    pub verifications: ::std::collections::HashMap<::std::string::String, bool>,
    pub details: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub storage_percents: ::std::collections::HashMap<::std::string::String, f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodResource {
    fn default() -> &'a PodResource {
        <PodResource as ::protobuf::Message>::default_instance()
    }
}

impl PodResource {
    pub fn new() -> PodResource {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .pb.PodResource.CpuPercentsEntry cpu_percents = 2;


    pub fn get_cpu_percents(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.cpu_percents
    }
    pub fn clear_cpu_percents(&mut self) {
        self.cpu_percents.clear();
    }

    // Param is passed by value, moved
    pub fn set_cpu_percents(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.cpu_percents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cpu_percents(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.cpu_percents
    }

    // Take field
    pub fn take_cpu_percents(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.cpu_percents, ::std::collections::HashMap::new())
    }

    // repeated .pb.PodResource.MemoryPercentsEntry memory_percents = 3;


    pub fn get_memory_percents(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.memory_percents
    }
    pub fn clear_memory_percents(&mut self) {
        self.memory_percents.clear();
    }

    // Param is passed by value, moved
    pub fn set_memory_percents(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.memory_percents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memory_percents(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.memory_percents
    }

    // Take field
    pub fn take_memory_percents(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.memory_percents, ::std::collections::HashMap::new())
    }

    // repeated .pb.PodResource.VerificationsEntry verifications = 4;


    pub fn get_verifications(&self) -> &::std::collections::HashMap<::std::string::String, bool> {
        &self.verifications
    }
    pub fn clear_verifications(&mut self) {
        self.verifications.clear();
    }

    // Param is passed by value, moved
    pub fn set_verifications(&mut self, v: ::std::collections::HashMap<::std::string::String, bool>) {
        self.verifications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_verifications(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, bool> {
        &mut self.verifications
    }

    // Take field
    pub fn take_verifications(&mut self) -> ::std::collections::HashMap<::std::string::String, bool> {
        ::std::mem::replace(&mut self.verifications, ::std::collections::HashMap::new())
    }

    // repeated .pb.PodResource.DetailsEntry details = 5;


    pub fn get_details(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_details(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.details, ::std::collections::HashMap::new())
    }

    // repeated .pb.PodResource.StoragePercentsEntry storage_percents = 6;


    pub fn get_storage_percents(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.storage_percents
    }
    pub fn clear_storage_percents(&mut self) {
        self.storage_percents.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage_percents(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.storage_percents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storage_percents(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.storage_percents
    }

    // Take field
    pub fn take_storage_percents(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.storage_percents, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PodResource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.cpu_percents)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.memory_percents)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(wire_type, is, &mut self.verifications)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.details)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.storage_percents)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(2, &self.cpu_percents);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(3, &self.memory_percents);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(4, &self.verifications);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.details);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(6, &self.storage_percents);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(2, &self.cpu_percents, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(3, &self.memory_percents, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(4, &self.verifications, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.details, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(6, &self.storage_percents, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodResource {
        PodResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &PodResource| { &m.name },
                    |m: &mut PodResource| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                    "cpu_percents",
                    |m: &PodResource| { &m.cpu_percents },
                    |m: &mut PodResource| { &mut m.cpu_percents },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                    "memory_percents",
                    |m: &PodResource| { &m.memory_percents },
                    |m: &mut PodResource| { &mut m.memory_percents },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBool>(
                    "verifications",
                    |m: &PodResource| { &m.verifications },
                    |m: &mut PodResource| { &mut m.verifications },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "details",
                    |m: &PodResource| { &m.details },
                    |m: &mut PodResource| { &mut m.details },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                    "storage_percents",
                    |m: &PodResource| { &m.storage_percents },
                    |m: &mut PodResource| { &mut m.storage_percents },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodResource>(
                    "PodResource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PodResource {
        static mut instance: ::protobuf::lazy::Lazy<PodResource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodResource,
        };
        unsafe {
            instance.get(PodResource::new)
        }
    }
}

impl ::protobuf::Clear for PodResource {
    fn clear(&mut self) {
        self.name.clear();
        self.cpu_percents.clear();
        self.memory_percents.clear();
        self.verifications.clear();
        self.details.clear();
        self.storage_percents.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodResource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeResource {
    // message fields
    pub name: ::std::string::String,
    pub cpu_percent: f64,
    pub memory_percent: f64,
    pub verification: bool,
    pub details: ::protobuf::RepeatedField<::std::string::String>,
    pub storage_percent: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeResource {
    fn default() -> &'a NodeResource {
        <NodeResource as ::protobuf::Message>::default_instance()
    }
}

impl NodeResource {
    pub fn new() -> NodeResource {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // double cpu_percent = 2;


    pub fn get_cpu_percent(&self) -> f64 {
        self.cpu_percent
    }
    pub fn clear_cpu_percent(&mut self) {
        self.cpu_percent = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cpu_percent(&mut self, v: f64) {
        self.cpu_percent = v;
    }

    // double memory_percent = 3;


    pub fn get_memory_percent(&self) -> f64 {
        self.memory_percent
    }
    pub fn clear_memory_percent(&mut self) {
        self.memory_percent = 0.;
    }

    // Param is passed by value, moved
    pub fn set_memory_percent(&mut self, v: f64) {
        self.memory_percent = v;
    }

    // bool verification = 4;


    pub fn get_verification(&self) -> bool {
        self.verification
    }
    pub fn clear_verification(&mut self) {
        self.verification = false;
    }

    // Param is passed by value, moved
    pub fn set_verification(&mut self, v: bool) {
        self.verification = v;
    }

    // repeated string details = 5;


    pub fn get_details(&self) -> &[::std::string::String] {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_details(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.details, ::protobuf::RepeatedField::new())
    }

    // double storage_percent = 6;


    pub fn get_storage_percent(&self) -> f64 {
        self.storage_percent
    }
    pub fn clear_storage_percent(&mut self) {
        self.storage_percent = 0.;
    }

    // Param is passed by value, moved
    pub fn set_storage_percent(&mut self, v: f64) {
        self.storage_percent = v;
    }
}

impl ::protobuf::Message for NodeResource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cpu_percent = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.memory_percent = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.verification = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.details)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.storage_percent = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.cpu_percent != 0. {
            my_size += 9;
        }
        if self.memory_percent != 0. {
            my_size += 9;
        }
        if self.verification != false {
            my_size += 2;
        }
        for value in &self.details {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.storage_percent != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.cpu_percent != 0. {
            os.write_double(2, self.cpu_percent)?;
        }
        if self.memory_percent != 0. {
            os.write_double(3, self.memory_percent)?;
        }
        if self.verification != false {
            os.write_bool(4, self.verification)?;
        }
        for v in &self.details {
            os.write_string(5, &v)?;
        };
        if self.storage_percent != 0. {
            os.write_double(6, self.storage_percent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeResource {
        NodeResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &NodeResource| { &m.name },
                    |m: &mut NodeResource| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "cpu_percent",
                    |m: &NodeResource| { &m.cpu_percent },
                    |m: &mut NodeResource| { &mut m.cpu_percent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "memory_percent",
                    |m: &NodeResource| { &m.memory_percent },
                    |m: &mut NodeResource| { &mut m.memory_percent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "verification",
                    |m: &NodeResource| { &m.verification },
                    |m: &mut NodeResource| { &mut m.verification },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "details",
                    |m: &NodeResource| { &m.details },
                    |m: &mut NodeResource| { &mut m.details },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "storage_percent",
                    |m: &NodeResource| { &m.storage_percent },
                    |m: &mut NodeResource| { &mut m.storage_percent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeResource>(
                    "NodeResource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeResource {
        static mut instance: ::protobuf::lazy::Lazy<NodeResource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeResource,
        };
        unsafe {
            instance.get(NodeResource::new)
        }
    }
}

impl ::protobuf::Clear for NodeResource {
    fn clear(&mut self) {
        self.name.clear();
        self.cpu_percent = 0.;
        self.memory_percent = 0.;
        self.verification = false;
        self.details.clear();
        self.storage_percent = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeResource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListNetworkOptions {
    // message fields
    pub podname: ::std::string::String,
    pub driver: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListNetworkOptions {
    fn default() -> &'a ListNetworkOptions {
        <ListNetworkOptions as ::protobuf::Message>::default_instance()
    }
}

impl ListNetworkOptions {
    pub fn new() -> ListNetworkOptions {
        ::std::default::Default::default()
    }

    // string podname = 1;


    pub fn get_podname(&self) -> &str {
        &self.podname
    }
    pub fn clear_podname(&mut self) {
        self.podname.clear();
    }

    // Param is passed by value, moved
    pub fn set_podname(&mut self, v: ::std::string::String) {
        self.podname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podname(&mut self) -> &mut ::std::string::String {
        &mut self.podname
    }

    // Take field
    pub fn take_podname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.podname, ::std::string::String::new())
    }

    // string driver = 2;


    pub fn get_driver(&self) -> &str {
        &self.driver
    }
    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        &mut self.driver
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.driver, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListNetworkOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.podname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.driver)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.podname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.podname);
        }
        if !self.driver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.driver);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.podname.is_empty() {
            os.write_string(1, &self.podname)?;
        }
        if !self.driver.is_empty() {
            os.write_string(2, &self.driver)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListNetworkOptions {
        ListNetworkOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podname",
                    |m: &ListNetworkOptions| { &m.podname },
                    |m: &mut ListNetworkOptions| { &mut m.podname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "driver",
                    |m: &ListNetworkOptions| { &m.driver },
                    |m: &mut ListNetworkOptions| { &mut m.driver },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListNetworkOptions>(
                    "ListNetworkOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListNetworkOptions {
        static mut instance: ::protobuf::lazy::Lazy<ListNetworkOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListNetworkOptions,
        };
        unsafe {
            instance.get(ListNetworkOptions::new)
        }
    }
}

impl ::protobuf::Clear for ListNetworkOptions {
    fn clear(&mut self) {
        self.podname.clear();
        self.driver.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListNetworkOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListNetworkOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Network {
    // message fields
    pub name: ::std::string::String,
    pub subnets: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Network {
    fn default() -> &'a Network {
        <Network as ::protobuf::Message>::default_instance()
    }
}

impl Network {
    pub fn new() -> Network {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string subnets = 2;


    pub fn get_subnets(&self) -> &[::std::string::String] {
        &self.subnets
    }
    pub fn clear_subnets(&mut self) {
        self.subnets.clear();
    }

    // Param is passed by value, moved
    pub fn set_subnets(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.subnets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subnets(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.subnets
    }

    // Take field
    pub fn take_subnets(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.subnets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Network {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.subnets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.subnets {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.subnets {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Network {
        Network::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Network| { &m.name },
                    |m: &mut Network| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subnets",
                    |m: &Network| { &m.subnets },
                    |m: &mut Network| { &mut m.subnets },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Network>(
                    "Network",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Network {
        static mut instance: ::protobuf::lazy::Lazy<Network> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Network,
        };
        unsafe {
            instance.get(Network::new)
        }
    }
}

impl ::protobuf::Clear for Network {
    fn clear(&mut self) {
        self.name.clear();
        self.subnets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Network {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Network {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Networks {
    // message fields
    pub networks: ::protobuf::RepeatedField<Network>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Networks {
    fn default() -> &'a Networks {
        <Networks as ::protobuf::Message>::default_instance()
    }
}

impl Networks {
    pub fn new() -> Networks {
        ::std::default::Default::default()
    }

    // repeated .pb.Network networks = 1;


    pub fn get_networks(&self) -> &[Network] {
        &self.networks
    }
    pub fn clear_networks(&mut self) {
        self.networks.clear();
    }

    // Param is passed by value, moved
    pub fn set_networks(&mut self, v: ::protobuf::RepeatedField<Network>) {
        self.networks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_networks(&mut self) -> &mut ::protobuf::RepeatedField<Network> {
        &mut self.networks
    }

    // Take field
    pub fn take_networks(&mut self) -> ::protobuf::RepeatedField<Network> {
        ::std::mem::replace(&mut self.networks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Networks {
    fn is_initialized(&self) -> bool {
        for v in &self.networks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.networks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.networks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.networks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Networks {
        Networks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Network>>(
                    "networks",
                    |m: &Networks| { &m.networks },
                    |m: &mut Networks| { &mut m.networks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Networks>(
                    "Networks",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Networks {
        static mut instance: ::protobuf::lazy::Lazy<Networks> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Networks,
        };
        unsafe {
            instance.get(Networks::new)
        }
    }
}

impl ::protobuf::Clear for Networks {
    fn clear(&mut self) {
        self.networks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Networks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Networks {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Node {
    // message fields
    pub name: ::std::string::String,
    pub endpoint: ::std::string::String,
    pub podname: ::std::string::String,
    pub cpu: ::std::collections::HashMap<::std::string::String, i32>,
    pub cpu_used: f64,
    pub memory: i64,
    pub memory_used: i64,
    pub available: bool,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub init_memory: i64,
    pub init_cpu: ::std::collections::HashMap<::std::string::String, i32>,
    pub info: ::std::string::String,
    pub numa: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub numa_memory: ::std::collections::HashMap<::std::string::String, i64>,
    pub storage: i64,
    pub storage_used: i64,
    pub init_storage: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string endpoint = 2;


    pub fn get_endpoint(&self) -> &str {
        &self.endpoint
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint, ::std::string::String::new())
    }

    // string podname = 3;


    pub fn get_podname(&self) -> &str {
        &self.podname
    }
    pub fn clear_podname(&mut self) {
        self.podname.clear();
    }

    // Param is passed by value, moved
    pub fn set_podname(&mut self, v: ::std::string::String) {
        self.podname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podname(&mut self) -> &mut ::std::string::String {
        &mut self.podname
    }

    // Take field
    pub fn take_podname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.podname, ::std::string::String::new())
    }

    // repeated .pb.Node.CpuEntry cpu = 4;


    pub fn get_cpu(&self) -> &::std::collections::HashMap<::std::string::String, i32> {
        &self.cpu
    }
    pub fn clear_cpu(&mut self) {
        self.cpu.clear();
    }

    // Param is passed by value, moved
    pub fn set_cpu(&mut self, v: ::std::collections::HashMap<::std::string::String, i32>) {
        self.cpu = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cpu(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i32> {
        &mut self.cpu
    }

    // Take field
    pub fn take_cpu(&mut self) -> ::std::collections::HashMap<::std::string::String, i32> {
        ::std::mem::replace(&mut self.cpu, ::std::collections::HashMap::new())
    }

    // double cpu_used = 5;


    pub fn get_cpu_used(&self) -> f64 {
        self.cpu_used
    }
    pub fn clear_cpu_used(&mut self) {
        self.cpu_used = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cpu_used(&mut self, v: f64) {
        self.cpu_used = v;
    }

    // int64 memory = 6;


    pub fn get_memory(&self) -> i64 {
        self.memory
    }
    pub fn clear_memory(&mut self) {
        self.memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: i64) {
        self.memory = v;
    }

    // int64 memory_used = 7;


    pub fn get_memory_used(&self) -> i64 {
        self.memory_used
    }
    pub fn clear_memory_used(&mut self) {
        self.memory_used = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory_used(&mut self, v: i64) {
        self.memory_used = v;
    }

    // bool available = 8;


    pub fn get_available(&self) -> bool {
        self.available
    }
    pub fn clear_available(&mut self) {
        self.available = false;
    }

    // Param is passed by value, moved
    pub fn set_available(&mut self, v: bool) {
        self.available = v;
    }

    // repeated .pb.Node.LabelsEntry labels = 9;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // int64 init_memory = 10;


    pub fn get_init_memory(&self) -> i64 {
        self.init_memory
    }
    pub fn clear_init_memory(&mut self) {
        self.init_memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_init_memory(&mut self, v: i64) {
        self.init_memory = v;
    }

    // repeated .pb.Node.InitCpuEntry init_cpu = 11;


    pub fn get_init_cpu(&self) -> &::std::collections::HashMap<::std::string::String, i32> {
        &self.init_cpu
    }
    pub fn clear_init_cpu(&mut self) {
        self.init_cpu.clear();
    }

    // Param is passed by value, moved
    pub fn set_init_cpu(&mut self, v: ::std::collections::HashMap<::std::string::String, i32>) {
        self.init_cpu = v;
    }

    // Mutable pointer to the field.
    pub fn mut_init_cpu(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i32> {
        &mut self.init_cpu
    }

    // Take field
    pub fn take_init_cpu(&mut self) -> ::std::collections::HashMap<::std::string::String, i32> {
        ::std::mem::replace(&mut self.init_cpu, ::std::collections::HashMap::new())
    }

    // string info = 12;


    pub fn get_info(&self) -> &str {
        &self.info
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.info, ::std::string::String::new())
    }

    // repeated .pb.Node.NumaEntry numa = 13;


    pub fn get_numa(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.numa
    }
    pub fn clear_numa(&mut self) {
        self.numa.clear();
    }

    // Param is passed by value, moved
    pub fn set_numa(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.numa = v;
    }

    // Mutable pointer to the field.
    pub fn mut_numa(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.numa
    }

    // Take field
    pub fn take_numa(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.numa, ::std::collections::HashMap::new())
    }

    // repeated .pb.Node.NumaMemoryEntry numa_memory = 14;


    pub fn get_numa_memory(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.numa_memory
    }
    pub fn clear_numa_memory(&mut self) {
        self.numa_memory.clear();
    }

    // Param is passed by value, moved
    pub fn set_numa_memory(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.numa_memory = v;
    }

    // Mutable pointer to the field.
    pub fn mut_numa_memory(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.numa_memory
    }

    // Take field
    pub fn take_numa_memory(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.numa_memory, ::std::collections::HashMap::new())
    }

    // int64 storage = 15;


    pub fn get_storage(&self) -> i64 {
        self.storage
    }
    pub fn clear_storage(&mut self) {
        self.storage = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: i64) {
        self.storage = v;
    }

    // int64 storage_used = 16;


    pub fn get_storage_used(&self) -> i64 {
        self.storage_used
    }
    pub fn clear_storage_used(&mut self) {
        self.storage_used = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage_used(&mut self, v: i64) {
        self.storage_used = v;
    }

    // int64 init_storage = 17;


    pub fn get_init_storage(&self) -> i64 {
        self.init_storage
    }
    pub fn clear_init_storage(&mut self) {
        self.init_storage = 0;
    }

    // Param is passed by value, moved
    pub fn set_init_storage(&mut self, v: i64) {
        self.init_storage = v;
    }
}

impl ::protobuf::Message for Node {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.podname)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.cpu)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cpu_used = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory_used = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.available = tmp;
                },
                9 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.init_memory = tmp;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.init_cpu)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.info)?;
                },
                13 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.numa)?;
                },
                14 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.numa_memory)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage_used = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.init_storage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.endpoint);
        }
        if !self.podname.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.podname);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(4, &self.cpu);
        if self.cpu_used != 0. {
            my_size += 9;
        }
        if self.memory != 0 {
            my_size += ::protobuf::rt::value_size(6, self.memory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.memory_used != 0 {
            my_size += ::protobuf::rt::value_size(7, self.memory_used, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.available != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels);
        if self.init_memory != 0 {
            my_size += ::protobuf::rt::value_size(10, self.init_memory, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(11, &self.init_cpu);
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.info);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(13, &self.numa);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(14, &self.numa_memory);
        if self.storage != 0 {
            my_size += ::protobuf::rt::value_size(15, self.storage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.storage_used != 0 {
            my_size += ::protobuf::rt::value_size(16, self.storage_used, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.init_storage != 0 {
            my_size += ::protobuf::rt::value_size(17, self.init_storage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.endpoint.is_empty() {
            os.write_string(2, &self.endpoint)?;
        }
        if !self.podname.is_empty() {
            os.write_string(3, &self.podname)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(4, &self.cpu, os)?;
        if self.cpu_used != 0. {
            os.write_double(5, self.cpu_used)?;
        }
        if self.memory != 0 {
            os.write_int64(6, self.memory)?;
        }
        if self.memory_used != 0 {
            os.write_int64(7, self.memory_used)?;
        }
        if self.available != false {
            os.write_bool(8, self.available)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels, os)?;
        if self.init_memory != 0 {
            os.write_int64(10, self.init_memory)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(11, &self.init_cpu, os)?;
        if !self.info.is_empty() {
            os.write_string(12, &self.info)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(13, &self.numa, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(14, &self.numa_memory, os)?;
        if self.storage != 0 {
            os.write_int64(15, self.storage)?;
        }
        if self.storage_used != 0 {
            os.write_int64(16, self.storage_used)?;
        }
        if self.init_storage != 0 {
            os.write_int64(17, self.init_storage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Node {
        Node::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Node| { &m.name },
                    |m: &mut Node| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "endpoint",
                    |m: &Node| { &m.endpoint },
                    |m: &mut Node| { &mut m.endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podname",
                    |m: &Node| { &m.podname },
                    |m: &mut Node| { &mut m.podname },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(
                    "cpu",
                    |m: &Node| { &m.cpu },
                    |m: &mut Node| { &mut m.cpu },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "cpu_used",
                    |m: &Node| { &m.cpu_used },
                    |m: &mut Node| { &mut m.cpu_used },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "memory",
                    |m: &Node| { &m.memory },
                    |m: &mut Node| { &mut m.memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "memory_used",
                    |m: &Node| { &m.memory_used },
                    |m: &mut Node| { &mut m.memory_used },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "available",
                    |m: &Node| { &m.available },
                    |m: &mut Node| { &mut m.available },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &Node| { &m.labels },
                    |m: &mut Node| { &mut m.labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "init_memory",
                    |m: &Node| { &m.init_memory },
                    |m: &mut Node| { &mut m.init_memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(
                    "init_cpu",
                    |m: &Node| { &m.init_cpu },
                    |m: &mut Node| { &mut m.init_cpu },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "info",
                    |m: &Node| { &m.info },
                    |m: &mut Node| { &mut m.info },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "numa",
                    |m: &Node| { &m.numa },
                    |m: &mut Node| { &mut m.numa },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "numa_memory",
                    |m: &Node| { &m.numa_memory },
                    |m: &mut Node| { &mut m.numa_memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "storage",
                    |m: &Node| { &m.storage },
                    |m: &mut Node| { &mut m.storage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "storage_used",
                    |m: &Node| { &m.storage_used },
                    |m: &mut Node| { &mut m.storage_used },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "init_storage",
                    |m: &Node| { &m.init_storage },
                    |m: &mut Node| { &mut m.init_storage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Node>(
                    "Node",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Node {
        static mut instance: ::protobuf::lazy::Lazy<Node> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Node,
        };
        unsafe {
            instance.get(Node::new)
        }
    }
}

impl ::protobuf::Clear for Node {
    fn clear(&mut self) {
        self.name.clear();
        self.endpoint.clear();
        self.podname.clear();
        self.cpu.clear();
        self.cpu_used = 0.;
        self.memory = 0;
        self.memory_used = 0;
        self.available = false;
        self.labels.clear();
        self.init_memory = 0;
        self.init_cpu.clear();
        self.info.clear();
        self.numa.clear();
        self.numa_memory.clear();
        self.storage = 0;
        self.storage_used = 0;
        self.init_storage = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Nodes {
    // message fields
    pub nodes: ::protobuf::RepeatedField<Node>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Nodes {
    fn default() -> &'a Nodes {
        <Nodes as ::protobuf::Message>::default_instance()
    }
}

impl Nodes {
    pub fn new() -> Nodes {
        ::std::default::Default::default()
    }

    // repeated .pb.Node nodes = 1;


    pub fn get_nodes(&self) -> &[Node] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<Node>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<Node> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<Node> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Nodes {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Nodes {
        Nodes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Node>>(
                    "nodes",
                    |m: &Nodes| { &m.nodes },
                    |m: &mut Nodes| { &mut m.nodes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Nodes>(
                    "Nodes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Nodes {
        static mut instance: ::protobuf::lazy::Lazy<Nodes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Nodes,
        };
        unsafe {
            instance.get(Nodes::new)
        }
    }
}

impl ::protobuf::Clear for Nodes {
    fn clear(&mut self) {
        self.nodes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Nodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Nodes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeAvailable {
    // message fields
    pub nodename: ::std::string::String,
    pub podname: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeAvailable {
    fn default() -> &'a NodeAvailable {
        <NodeAvailable as ::protobuf::Message>::default_instance()
    }
}

impl NodeAvailable {
    pub fn new() -> NodeAvailable {
        ::std::default::Default::default()
    }

    // string nodename = 1;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // string podname = 2;


    pub fn get_podname(&self) -> &str {
        &self.podname
    }
    pub fn clear_podname(&mut self) {
        self.podname.clear();
    }

    // Param is passed by value, moved
    pub fn set_podname(&mut self, v: ::std::string::String) {
        self.podname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podname(&mut self) -> &mut ::std::string::String {
        &mut self.podname
    }

    // Take field
    pub fn take_podname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.podname, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeAvailable {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.podname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.nodename);
        }
        if !self.podname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.podname);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.nodename.is_empty() {
            os.write_string(1, &self.nodename)?;
        }
        if !self.podname.is_empty() {
            os.write_string(2, &self.podname)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeAvailable {
        NodeAvailable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &NodeAvailable| { &m.nodename },
                    |m: &mut NodeAvailable| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podname",
                    |m: &NodeAvailable| { &m.podname },
                    |m: &mut NodeAvailable| { &mut m.podname },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeAvailable>(
                    "NodeAvailable",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeAvailable {
        static mut instance: ::protobuf::lazy::Lazy<NodeAvailable> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeAvailable,
        };
        unsafe {
            instance.get(NodeAvailable::new)
        }
    }
}

impl ::protobuf::Clear for NodeAvailable {
    fn clear(&mut self) {
        self.nodename.clear();
        self.podname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAvailable {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetNodeOptions {
    // message fields
    pub nodename: ::std::string::String,
    pub status: i32,
    pub delta_cpu: ::std::collections::HashMap<::std::string::String, i32>,
    pub delta_memory: i64,
    pub delta_storage: i64,
    pub delta_numa_memory: ::std::collections::HashMap<::std::string::String, i64>,
    pub numa: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetNodeOptions {
    fn default() -> &'a SetNodeOptions {
        <SetNodeOptions as ::protobuf::Message>::default_instance()
    }
}

impl SetNodeOptions {
    pub fn new() -> SetNodeOptions {
        ::std::default::Default::default()
    }

    // string nodename = 1;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // int32 status = 2;


    pub fn get_status(&self) -> i32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = v;
    }

    // repeated .pb.SetNodeOptions.DeltaCpuEntry delta_cpu = 3;


    pub fn get_delta_cpu(&self) -> &::std::collections::HashMap<::std::string::String, i32> {
        &self.delta_cpu
    }
    pub fn clear_delta_cpu(&mut self) {
        self.delta_cpu.clear();
    }

    // Param is passed by value, moved
    pub fn set_delta_cpu(&mut self, v: ::std::collections::HashMap<::std::string::String, i32>) {
        self.delta_cpu = v;
    }

    // Mutable pointer to the field.
    pub fn mut_delta_cpu(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i32> {
        &mut self.delta_cpu
    }

    // Take field
    pub fn take_delta_cpu(&mut self) -> ::std::collections::HashMap<::std::string::String, i32> {
        ::std::mem::replace(&mut self.delta_cpu, ::std::collections::HashMap::new())
    }

    // int64 delta_memory = 4;


    pub fn get_delta_memory(&self) -> i64 {
        self.delta_memory
    }
    pub fn clear_delta_memory(&mut self) {
        self.delta_memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_delta_memory(&mut self, v: i64) {
        self.delta_memory = v;
    }

    // int64 delta_storage = 5;


    pub fn get_delta_storage(&self) -> i64 {
        self.delta_storage
    }
    pub fn clear_delta_storage(&mut self) {
        self.delta_storage = 0;
    }

    // Param is passed by value, moved
    pub fn set_delta_storage(&mut self, v: i64) {
        self.delta_storage = v;
    }

    // repeated .pb.SetNodeOptions.DeltaNumaMemoryEntry delta_numa_memory = 6;


    pub fn get_delta_numa_memory(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.delta_numa_memory
    }
    pub fn clear_delta_numa_memory(&mut self) {
        self.delta_numa_memory.clear();
    }

    // Param is passed by value, moved
    pub fn set_delta_numa_memory(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.delta_numa_memory = v;
    }

    // Mutable pointer to the field.
    pub fn mut_delta_numa_memory(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.delta_numa_memory
    }

    // Take field
    pub fn take_delta_numa_memory(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.delta_numa_memory, ::std::collections::HashMap::new())
    }

    // repeated .pb.SetNodeOptions.NumaEntry numa = 7;


    pub fn get_numa(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.numa
    }
    pub fn clear_numa(&mut self) {
        self.numa.clear();
    }

    // Param is passed by value, moved
    pub fn set_numa(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.numa = v;
    }

    // Mutable pointer to the field.
    pub fn mut_numa(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.numa
    }

    // Take field
    pub fn take_numa(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.numa, ::std::collections::HashMap::new())
    }

    // repeated .pb.SetNodeOptions.LabelsEntry labels = 8;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for SetNodeOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = tmp;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.delta_cpu)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.delta_memory = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.delta_storage = tmp;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.delta_numa_memory)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.numa)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.nodename);
        }
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(2, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(3, &self.delta_cpu);
        if self.delta_memory != 0 {
            my_size += ::protobuf::rt::value_size(4, self.delta_memory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.delta_storage != 0 {
            my_size += ::protobuf::rt::value_size(5, self.delta_storage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.delta_numa_memory);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.numa);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.nodename.is_empty() {
            os.write_string(1, &self.nodename)?;
        }
        if self.status != 0 {
            os.write_int32(2, self.status)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(3, &self.delta_cpu, os)?;
        if self.delta_memory != 0 {
            os.write_int64(4, self.delta_memory)?;
        }
        if self.delta_storage != 0 {
            os.write_int64(5, self.delta_storage)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.delta_numa_memory, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.numa, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetNodeOptions {
        SetNodeOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &SetNodeOptions| { &m.nodename },
                    |m: &mut SetNodeOptions| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "status",
                    |m: &SetNodeOptions| { &m.status },
                    |m: &mut SetNodeOptions| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(
                    "delta_cpu",
                    |m: &SetNodeOptions| { &m.delta_cpu },
                    |m: &mut SetNodeOptions| { &mut m.delta_cpu },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "delta_memory",
                    |m: &SetNodeOptions| { &m.delta_memory },
                    |m: &mut SetNodeOptions| { &mut m.delta_memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "delta_storage",
                    |m: &SetNodeOptions| { &m.delta_storage },
                    |m: &mut SetNodeOptions| { &mut m.delta_storage },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "delta_numa_memory",
                    |m: &SetNodeOptions| { &m.delta_numa_memory },
                    |m: &mut SetNodeOptions| { &mut m.delta_numa_memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "numa",
                    |m: &SetNodeOptions| { &m.numa },
                    |m: &mut SetNodeOptions| { &mut m.numa },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &SetNodeOptions| { &m.labels },
                    |m: &mut SetNodeOptions| { &mut m.labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetNodeOptions>(
                    "SetNodeOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetNodeOptions {
        static mut instance: ::protobuf::lazy::Lazy<SetNodeOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetNodeOptions,
        };
        unsafe {
            instance.get(SetNodeOptions::new)
        }
    }
}

impl ::protobuf::Clear for SetNodeOptions {
    fn clear(&mut self) {
        self.nodename.clear();
        self.status = 0;
        self.delta_cpu.clear();
        self.delta_memory = 0;
        self.delta_storage = 0;
        self.delta_numa_memory.clear();
        self.numa.clear();
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetNodeOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetNodeOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Container {
    // message fields
    pub id: ::std::string::String,
    pub podname: ::std::string::String,
    pub nodename: ::std::string::String,
    pub name: ::std::string::String,
    pub cpu: ::std::collections::HashMap<::std::string::String, i32>,
    pub quota: f64,
    pub memory: i64,
    pub privileged: bool,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub publish: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub image: ::std::string::String,
    pub storage: i64,
    pub status: ::protobuf::SingularPtrField<ContainerStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Container {
    fn default() -> &'a Container {
        <Container as ::protobuf::Message>::default_instance()
    }
}

impl Container {
    pub fn new() -> Container {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string podname = 2;


    pub fn get_podname(&self) -> &str {
        &self.podname
    }
    pub fn clear_podname(&mut self) {
        self.podname.clear();
    }

    // Param is passed by value, moved
    pub fn set_podname(&mut self, v: ::std::string::String) {
        self.podname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podname(&mut self) -> &mut ::std::string::String {
        &mut self.podname
    }

    // Take field
    pub fn take_podname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.podname, ::std::string::String::new())
    }

    // string nodename = 3;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .pb.Container.CpuEntry cpu = 5;


    pub fn get_cpu(&self) -> &::std::collections::HashMap<::std::string::String, i32> {
        &self.cpu
    }
    pub fn clear_cpu(&mut self) {
        self.cpu.clear();
    }

    // Param is passed by value, moved
    pub fn set_cpu(&mut self, v: ::std::collections::HashMap<::std::string::String, i32>) {
        self.cpu = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cpu(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i32> {
        &mut self.cpu
    }

    // Take field
    pub fn take_cpu(&mut self) -> ::std::collections::HashMap<::std::string::String, i32> {
        ::std::mem::replace(&mut self.cpu, ::std::collections::HashMap::new())
    }

    // double quota = 6;


    pub fn get_quota(&self) -> f64 {
        self.quota
    }
    pub fn clear_quota(&mut self) {
        self.quota = 0.;
    }

    // Param is passed by value, moved
    pub fn set_quota(&mut self, v: f64) {
        self.quota = v;
    }

    // int64 memory = 7;


    pub fn get_memory(&self) -> i64 {
        self.memory
    }
    pub fn clear_memory(&mut self) {
        self.memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: i64) {
        self.memory = v;
    }

    // bool privileged = 8;


    pub fn get_privileged(&self) -> bool {
        self.privileged
    }
    pub fn clear_privileged(&mut self) {
        self.privileged = false;
    }

    // Param is passed by value, moved
    pub fn set_privileged(&mut self, v: bool) {
        self.privileged = v;
    }

    // repeated .pb.Container.LabelsEntry labels = 9;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .pb.Container.PublishEntry publish = 10;


    pub fn get_publish(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.publish
    }
    pub fn clear_publish(&mut self) {
        self.publish.clear();
    }

    // Param is passed by value, moved
    pub fn set_publish(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.publish = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publish(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.publish
    }

    // Take field
    pub fn take_publish(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.publish, ::std::collections::HashMap::new())
    }

    // string image = 11;


    pub fn get_image(&self) -> &str {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image, ::std::string::String::new())
    }

    // int64 storage = 12;


    pub fn get_storage(&self) -> i64 {
        self.storage
    }
    pub fn clear_storage(&mut self) {
        self.storage = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: i64) {
        self.storage = v;
    }

    // .pb.ContainerStatus status = 13;


    pub fn get_status(&self) -> &ContainerStatus {
        self.status.as_ref().unwrap_or_else(|| ContainerStatus::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ContainerStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ContainerStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ContainerStatus {
        self.status.take().unwrap_or_else(|| ContainerStatus::new())
    }
}

impl ::protobuf::Message for Container {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.podname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.cpu)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.quota = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.privileged = tmp;
                },
                9 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.publish)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.podname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.podname);
        }
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.nodename);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(5, &self.cpu);
        if self.quota != 0. {
            my_size += 9;
        }
        if self.memory != 0 {
            my_size += ::protobuf::rt::value_size(7, self.memory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.privileged != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.publish);
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.image);
        }
        if self.storage != 0 {
            my_size += ::protobuf::rt::value_size(12, self.storage, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.podname.is_empty() {
            os.write_string(2, &self.podname)?;
        }
        if !self.nodename.is_empty() {
            os.write_string(3, &self.nodename)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(5, &self.cpu, os)?;
        if self.quota != 0. {
            os.write_double(6, self.quota)?;
        }
        if self.memory != 0 {
            os.write_int64(7, self.memory)?;
        }
        if self.privileged != false {
            os.write_bool(8, self.privileged)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.publish, os)?;
        if !self.image.is_empty() {
            os.write_string(11, &self.image)?;
        }
        if self.storage != 0 {
            os.write_int64(12, self.storage)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Container {
        Container::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Container| { &m.id },
                    |m: &mut Container| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podname",
                    |m: &Container| { &m.podname },
                    |m: &mut Container| { &mut m.podname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &Container| { &m.nodename },
                    |m: &mut Container| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Container| { &m.name },
                    |m: &mut Container| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(
                    "cpu",
                    |m: &Container| { &m.cpu },
                    |m: &mut Container| { &mut m.cpu },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "quota",
                    |m: &Container| { &m.quota },
                    |m: &mut Container| { &mut m.quota },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "memory",
                    |m: &Container| { &m.memory },
                    |m: &mut Container| { &mut m.memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "privileged",
                    |m: &Container| { &m.privileged },
                    |m: &mut Container| { &mut m.privileged },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &Container| { &m.labels },
                    |m: &mut Container| { &mut m.labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "publish",
                    |m: &Container| { &m.publish },
                    |m: &mut Container| { &mut m.publish },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image",
                    |m: &Container| { &m.image },
                    |m: &mut Container| { &mut m.image },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "storage",
                    |m: &Container| { &m.storage },
                    |m: &mut Container| { &mut m.storage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatus>>(
                    "status",
                    |m: &Container| { &m.status },
                    |m: &mut Container| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Container>(
                    "Container",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Container {
        static mut instance: ::protobuf::lazy::Lazy<Container> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Container,
        };
        unsafe {
            instance.get(Container::new)
        }
    }
}

impl ::protobuf::Clear for Container {
    fn clear(&mut self) {
        self.id.clear();
        self.podname.clear();
        self.nodename.clear();
        self.name.clear();
        self.cpu.clear();
        self.quota = 0.;
        self.memory = 0;
        self.privileged = false;
        self.labels.clear();
        self.publish.clear();
        self.image.clear();
        self.storage = 0;
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Container {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Container {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatus {
    // message fields
    pub id: ::std::string::String,
    pub running: bool,
    pub healthy: bool,
    pub networks: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub extension: ::std::vec::Vec<u8>,
    pub ttl: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStatus {
    fn default() -> &'a ContainerStatus {
        <ContainerStatus as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStatus {
    pub fn new() -> ContainerStatus {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bool running = 2;


    pub fn get_running(&self) -> bool {
        self.running
    }
    pub fn clear_running(&mut self) {
        self.running = false;
    }

    // Param is passed by value, moved
    pub fn set_running(&mut self, v: bool) {
        self.running = v;
    }

    // bool healthy = 3;


    pub fn get_healthy(&self) -> bool {
        self.healthy
    }
    pub fn clear_healthy(&mut self) {
        self.healthy = false;
    }

    // Param is passed by value, moved
    pub fn set_healthy(&mut self, v: bool) {
        self.healthy = v;
    }

    // repeated .pb.ContainerStatus.NetworksEntry networks = 4;


    pub fn get_networks(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.networks
    }
    pub fn clear_networks(&mut self) {
        self.networks.clear();
    }

    // Param is passed by value, moved
    pub fn set_networks(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.networks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_networks(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.networks
    }

    // Take field
    pub fn take_networks(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.networks, ::std::collections::HashMap::new())
    }

    // bytes extension = 5;


    pub fn get_extension(&self) -> &[u8] {
        &self.extension
    }
    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::std::vec::Vec<u8>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extension(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.extension, ::std::vec::Vec::new())
    }

    // int64 ttl = 6;


    pub fn get_ttl(&self) -> i64 {
        self.ttl
    }
    pub fn clear_ttl(&mut self) {
        self.ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: i64) {
        self.ttl = v;
    }
}

impl ::protobuf::Message for ContainerStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.running = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.healthy = tmp;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.networks)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.extension)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ttl = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.running != false {
            my_size += 2;
        }
        if self.healthy != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.networks);
        if !self.extension.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.extension);
        }
        if self.ttl != 0 {
            my_size += ::protobuf::rt::value_size(6, self.ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.running != false {
            os.write_bool(2, self.running)?;
        }
        if self.healthy != false {
            os.write_bool(3, self.healthy)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.networks, os)?;
        if !self.extension.is_empty() {
            os.write_bytes(5, &self.extension)?;
        }
        if self.ttl != 0 {
            os.write_int64(6, self.ttl)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStatus {
        ContainerStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &ContainerStatus| { &m.id },
                    |m: &mut ContainerStatus| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "running",
                    |m: &ContainerStatus| { &m.running },
                    |m: &mut ContainerStatus| { &mut m.running },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "healthy",
                    |m: &ContainerStatus| { &m.healthy },
                    |m: &mut ContainerStatus| { &mut m.healthy },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "networks",
                    |m: &ContainerStatus| { &m.networks },
                    |m: &mut ContainerStatus| { &mut m.networks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extension",
                    |m: &ContainerStatus| { &m.extension },
                    |m: &mut ContainerStatus| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ttl",
                    |m: &ContainerStatus| { &m.ttl },
                    |m: &mut ContainerStatus| { &mut m.ttl },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerStatus>(
                    "ContainerStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContainerStatus {
        static mut instance: ::protobuf::lazy::Lazy<ContainerStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerStatus,
        };
        unsafe {
            instance.get(ContainerStatus::new)
        }
    }
}

impl ::protobuf::Clear for ContainerStatus {
    fn clear(&mut self) {
        self.id.clear();
        self.running = false;
        self.healthy = false;
        self.networks.clear();
        self.extension.clear();
        self.ttl = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainersStatus {
    // message fields
    pub status: ::protobuf::RepeatedField<ContainerStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainersStatus {
    fn default() -> &'a ContainersStatus {
        <ContainersStatus as ::protobuf::Message>::default_instance()
    }
}

impl ContainersStatus {
    pub fn new() -> ContainersStatus {
        ::std::default::Default::default()
    }

    // repeated .pb.ContainerStatus status = 1;


    pub fn get_status(&self) -> &[ContainerStatus] {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::protobuf::RepeatedField<ContainerStatus>) {
        self.status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut ::protobuf::RepeatedField<ContainerStatus> {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::protobuf::RepeatedField<ContainerStatus> {
        ::std::mem::replace(&mut self.status, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ContainersStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.status {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainersStatus {
        ContainersStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatus>>(
                    "status",
                    |m: &ContainersStatus| { &m.status },
                    |m: &mut ContainersStatus| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainersStatus>(
                    "ContainersStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContainersStatus {
        static mut instance: ::protobuf::lazy::Lazy<ContainersStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainersStatus,
        };
        unsafe {
            instance.get(ContainersStatus::new)
        }
    }
}

impl ::protobuf::Clear for ContainersStatus {
    fn clear(&mut self) {
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainersStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainersStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatusStreamMessage {
    // message fields
    pub id: ::std::string::String,
    pub container: ::protobuf::SingularPtrField<Container>,
    pub status: ::protobuf::SingularPtrField<ContainerStatus>,
    pub error: ::std::string::String,
    pub delete: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStatusStreamMessage {
    fn default() -> &'a ContainerStatusStreamMessage {
        <ContainerStatusStreamMessage as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStatusStreamMessage {
    pub fn new() -> ContainerStatusStreamMessage {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .pb.Container container = 2;


    pub fn get_container(&self) -> &Container {
        self.container.as_ref().unwrap_or_else(|| Container::default_instance())
    }
    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: Container) {
        self.container = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut Container {
        if self.container.is_none() {
            self.container.set_default();
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> Container {
        self.container.take().unwrap_or_else(|| Container::new())
    }

    // .pb.ContainerStatus status = 3;


    pub fn get_status(&self) -> &ContainerStatus {
        self.status.as_ref().unwrap_or_else(|| ContainerStatus::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ContainerStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ContainerStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ContainerStatus {
        self.status.take().unwrap_or_else(|| ContainerStatus::new())
    }

    // string error = 4;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // bool delete = 5;


    pub fn get_delete(&self) -> bool {
        self.delete
    }
    pub fn clear_delete(&mut self) {
        self.delete = false;
    }

    // Param is passed by value, moved
    pub fn set_delete(&mut self, v: bool) {
        self.delete = v;
    }
}

impl ::protobuf::Message for ContainerStatusStreamMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.container {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delete = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.container.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.error);
        }
        if self.delete != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.container.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(4, &self.error)?;
        }
        if self.delete != false {
            os.write_bool(5, self.delete)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStatusStreamMessage {
        ContainerStatusStreamMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &ContainerStatusStreamMessage| { &m.id },
                    |m: &mut ContainerStatusStreamMessage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Container>>(
                    "container",
                    |m: &ContainerStatusStreamMessage| { &m.container },
                    |m: &mut ContainerStatusStreamMessage| { &mut m.container },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatus>>(
                    "status",
                    |m: &ContainerStatusStreamMessage| { &m.status },
                    |m: &mut ContainerStatusStreamMessage| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &ContainerStatusStreamMessage| { &m.error },
                    |m: &mut ContainerStatusStreamMessage| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "delete",
                    |m: &ContainerStatusStreamMessage| { &m.delete },
                    |m: &mut ContainerStatusStreamMessage| { &mut m.delete },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerStatusStreamMessage>(
                    "ContainerStatusStreamMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContainerStatusStreamMessage {
        static mut instance: ::protobuf::lazy::Lazy<ContainerStatusStreamMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerStatusStreamMessage,
        };
        unsafe {
            instance.get(ContainerStatusStreamMessage::new)
        }
    }
}

impl ::protobuf::Clear for ContainerStatusStreamMessage {
    fn clear(&mut self) {
        self.id.clear();
        self.container.clear();
        self.status.clear();
        self.error.clear();
        self.delete = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatusStreamMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatusStreamMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetContainersStatusOptions {
    // message fields
    pub status: ::protobuf::RepeatedField<ContainerStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetContainersStatusOptions {
    fn default() -> &'a SetContainersStatusOptions {
        <SetContainersStatusOptions as ::protobuf::Message>::default_instance()
    }
}

impl SetContainersStatusOptions {
    pub fn new() -> SetContainersStatusOptions {
        ::std::default::Default::default()
    }

    // repeated .pb.ContainerStatus status = 1;


    pub fn get_status(&self) -> &[ContainerStatus] {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::protobuf::RepeatedField<ContainerStatus>) {
        self.status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut ::protobuf::RepeatedField<ContainerStatus> {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::protobuf::RepeatedField<ContainerStatus> {
        ::std::mem::replace(&mut self.status, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SetContainersStatusOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.status {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetContainersStatusOptions {
        SetContainersStatusOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatus>>(
                    "status",
                    |m: &SetContainersStatusOptions| { &m.status },
                    |m: &mut SetContainersStatusOptions| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetContainersStatusOptions>(
                    "SetContainersStatusOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetContainersStatusOptions {
        static mut instance: ::protobuf::lazy::Lazy<SetContainersStatusOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetContainersStatusOptions,
        };
        unsafe {
            instance.get(SetContainersStatusOptions::new)
        }
    }
}

impl ::protobuf::Clear for SetContainersStatusOptions {
    fn clear(&mut self) {
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetContainersStatusOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetContainersStatusOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatusStreamOptions {
    // message fields
    pub appname: ::std::string::String,
    pub entrypoint: ::std::string::String,
    pub nodename: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStatusStreamOptions {
    fn default() -> &'a ContainerStatusStreamOptions {
        <ContainerStatusStreamOptions as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStatusStreamOptions {
    pub fn new() -> ContainerStatusStreamOptions {
        ::std::default::Default::default()
    }

    // string appname = 1;


    pub fn get_appname(&self) -> &str {
        &self.appname
    }
    pub fn clear_appname(&mut self) {
        self.appname.clear();
    }

    // Param is passed by value, moved
    pub fn set_appname(&mut self, v: ::std::string::String) {
        self.appname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appname(&mut self) -> &mut ::std::string::String {
        &mut self.appname
    }

    // Take field
    pub fn take_appname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appname, ::std::string::String::new())
    }

    // string entrypoint = 2;


    pub fn get_entrypoint(&self) -> &str {
        &self.entrypoint
    }
    pub fn clear_entrypoint(&mut self) {
        self.entrypoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_entrypoint(&mut self, v: ::std::string::String) {
        self.entrypoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entrypoint(&mut self) -> &mut ::std::string::String {
        &mut self.entrypoint
    }

    // Take field
    pub fn take_entrypoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entrypoint, ::std::string::String::new())
    }

    // string nodename = 3;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // repeated .pb.ContainerStatusStreamOptions.LabelsEntry labels = 4;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ContainerStatusStreamOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entrypoint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.appname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.appname);
        }
        if !self.entrypoint.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entrypoint);
        }
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.nodename);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.appname.is_empty() {
            os.write_string(1, &self.appname)?;
        }
        if !self.entrypoint.is_empty() {
            os.write_string(2, &self.entrypoint)?;
        }
        if !self.nodename.is_empty() {
            os.write_string(3, &self.nodename)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStatusStreamOptions {
        ContainerStatusStreamOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "appname",
                    |m: &ContainerStatusStreamOptions| { &m.appname },
                    |m: &mut ContainerStatusStreamOptions| { &mut m.appname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entrypoint",
                    |m: &ContainerStatusStreamOptions| { &m.entrypoint },
                    |m: &mut ContainerStatusStreamOptions| { &mut m.entrypoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &ContainerStatusStreamOptions| { &m.nodename },
                    |m: &mut ContainerStatusStreamOptions| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &ContainerStatusStreamOptions| { &m.labels },
                    |m: &mut ContainerStatusStreamOptions| { &mut m.labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerStatusStreamOptions>(
                    "ContainerStatusStreamOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContainerStatusStreamOptions {
        static mut instance: ::protobuf::lazy::Lazy<ContainerStatusStreamOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerStatusStreamOptions,
        };
        unsafe {
            instance.get(ContainerStatusStreamOptions::new)
        }
    }
}

impl ::protobuf::Clear for ContainerStatusStreamOptions {
    fn clear(&mut self) {
        self.appname.clear();
        self.entrypoint.clear();
        self.nodename.clear();
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatusStreamOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatusStreamOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Containers {
    // message fields
    pub containers: ::protobuf::RepeatedField<Container>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Containers {
    fn default() -> &'a Containers {
        <Containers as ::protobuf::Message>::default_instance()
    }
}

impl Containers {
    pub fn new() -> Containers {
        ::std::default::Default::default()
    }

    // repeated .pb.Container containers = 1;


    pub fn get_containers(&self) -> &[Container] {
        &self.containers
    }
    pub fn clear_containers(&mut self) {
        self.containers.clear();
    }

    // Param is passed by value, moved
    pub fn set_containers(&mut self, v: ::protobuf::RepeatedField<Container>) {
        self.containers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_containers(&mut self) -> &mut ::protobuf::RepeatedField<Container> {
        &mut self.containers
    }

    // Take field
    pub fn take_containers(&mut self) -> ::protobuf::RepeatedField<Container> {
        ::std::mem::replace(&mut self.containers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Containers {
    fn is_initialized(&self) -> bool {
        for v in &self.containers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.containers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.containers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.containers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Containers {
        Containers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Container>>(
                    "containers",
                    |m: &Containers| { &m.containers },
                    |m: &mut Containers| { &mut m.containers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Containers>(
                    "Containers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Containers {
        static mut instance: ::protobuf::lazy::Lazy<Containers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Containers,
        };
        unsafe {
            instance.get(Containers::new)
        }
    }
}

impl ::protobuf::Clear for Containers {
    fn clear(&mut self) {
        self.containers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Containers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Containers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerID {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerID {
    fn default() -> &'a ContainerID {
        <ContainerID as ::protobuf::Message>::default_instance()
    }
}

impl ContainerID {
    pub fn new() -> ContainerID {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContainerID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerID {
        ContainerID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &ContainerID| { &m.id },
                    |m: &mut ContainerID| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerID>(
                    "ContainerID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContainerID {
        static mut instance: ::protobuf::lazy::Lazy<ContainerID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerID,
        };
        unsafe {
            instance.get(ContainerID::new)
        }
    }
}

impl ::protobuf::Clear for ContainerID {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerIDs {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerIDs {
    fn default() -> &'a ContainerIDs {
        <ContainerIDs as ::protobuf::Message>::default_instance()
    }
}

impl ContainerIDs {
    pub fn new() -> ContainerIDs {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ContainerIDs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerIDs {
        ContainerIDs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &ContainerIDs| { &m.ids },
                    |m: &mut ContainerIDs| { &mut m.ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerIDs>(
                    "ContainerIDs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContainerIDs {
        static mut instance: ::protobuf::lazy::Lazy<ContainerIDs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerIDs,
        };
        unsafe {
            instance.get(ContainerIDs::new)
        }
    }
}

impl ::protobuf::Clear for ContainerIDs {
    fn clear(&mut self) {
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerIDs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerIDs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveContainerOptions {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub force: bool,
    pub step: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveContainerOptions {
    fn default() -> &'a RemoveContainerOptions {
        <RemoveContainerOptions as ::protobuf::Message>::default_instance()
    }
}

impl RemoveContainerOptions {
    pub fn new() -> RemoveContainerOptions {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // bool force = 2;


    pub fn get_force(&self) -> bool {
        self.force
    }
    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }

    // int32 step = 3;


    pub fn get_step(&self) -> i32 {
        self.step
    }
    pub fn clear_step(&mut self) {
        self.step = 0;
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: i32) {
        self.step = v;
    }
}

impl ::protobuf::Message for RemoveContainerOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.step = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.force != false {
            my_size += 2;
        }
        if self.step != 0 {
            my_size += ::protobuf::rt::value_size(3, self.step, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        if self.force != false {
            os.write_bool(2, self.force)?;
        }
        if self.step != 0 {
            os.write_int32(3, self.step)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveContainerOptions {
        RemoveContainerOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &RemoveContainerOptions| { &m.ids },
                    |m: &mut RemoveContainerOptions| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "force",
                    |m: &RemoveContainerOptions| { &m.force },
                    |m: &mut RemoveContainerOptions| { &mut m.force },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "step",
                    |m: &RemoveContainerOptions| { &m.step },
                    |m: &mut RemoveContainerOptions| { &mut m.step },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveContainerOptions>(
                    "RemoveContainerOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveContainerOptions {
        static mut instance: ::protobuf::lazy::Lazy<RemoveContainerOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveContainerOptions,
        };
        unsafe {
            instance.get(RemoveContainerOptions::new)
        }
    }
}

impl ::protobuf::Clear for RemoveContainerOptions {
    fn clear(&mut self) {
        self.ids.clear();
        self.force = false;
        self.step = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveContainerOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveContainerOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DissociateContainerOptions {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DissociateContainerOptions {
    fn default() -> &'a DissociateContainerOptions {
        <DissociateContainerOptions as ::protobuf::Message>::default_instance()
    }
}

impl DissociateContainerOptions {
    pub fn new() -> DissociateContainerOptions {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DissociateContainerOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DissociateContainerOptions {
        DissociateContainerOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &DissociateContainerOptions| { &m.ids },
                    |m: &mut DissociateContainerOptions| { &mut m.ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DissociateContainerOptions>(
                    "DissociateContainerOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DissociateContainerOptions {
        static mut instance: ::protobuf::lazy::Lazy<DissociateContainerOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DissociateContainerOptions,
        };
        unsafe {
            instance.get(DissociateContainerOptions::new)
        }
    }
}

impl ::protobuf::Clear for DissociateContainerOptions {
    fn clear(&mut self) {
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DissociateContainerOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DissociateContainerOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReallocOptions {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub cpu: f64,
    pub memory: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReallocOptions {
    fn default() -> &'a ReallocOptions {
        <ReallocOptions as ::protobuf::Message>::default_instance()
    }
}

impl ReallocOptions {
    pub fn new() -> ReallocOptions {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // double cpu = 2;


    pub fn get_cpu(&self) -> f64 {
        self.cpu
    }
    pub fn clear_cpu(&mut self) {
        self.cpu = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cpu(&mut self, v: f64) {
        self.cpu = v;
    }

    // int64 memory = 3;


    pub fn get_memory(&self) -> i64 {
        self.memory
    }
    pub fn clear_memory(&mut self) {
        self.memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: i64) {
        self.memory = v;
    }
}

impl ::protobuf::Message for ReallocOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cpu = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.cpu != 0. {
            my_size += 9;
        }
        if self.memory != 0 {
            my_size += ::protobuf::rt::value_size(3, self.memory, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        if self.cpu != 0. {
            os.write_double(2, self.cpu)?;
        }
        if self.memory != 0 {
            os.write_int64(3, self.memory)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReallocOptions {
        ReallocOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &ReallocOptions| { &m.ids },
                    |m: &mut ReallocOptions| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "cpu",
                    |m: &ReallocOptions| { &m.cpu },
                    |m: &mut ReallocOptions| { &mut m.cpu },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "memory",
                    |m: &ReallocOptions| { &m.memory },
                    |m: &mut ReallocOptions| { &mut m.memory },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReallocOptions>(
                    "ReallocOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReallocOptions {
        static mut instance: ::protobuf::lazy::Lazy<ReallocOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReallocOptions,
        };
        unsafe {
            instance.get(ReallocOptions::new)
        }
    }
}

impl ::protobuf::Clear for ReallocOptions {
    fn clear(&mut self) {
        self.ids.clear();
        self.cpu = 0.;
        self.memory = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReallocOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReallocOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPodOptions {
    // message fields
    pub name: ::std::string::String,
    pub desc: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPodOptions {
    fn default() -> &'a AddPodOptions {
        <AddPodOptions as ::protobuf::Message>::default_instance()
    }
}

impl AddPodOptions {
    pub fn new() -> AddPodOptions {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string desc = 2;


    pub fn get_desc(&self) -> &str {
        &self.desc
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        &mut self.desc
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desc, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddPodOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.desc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.desc.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.desc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.desc.is_empty() {
            os.write_string(2, &self.desc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPodOptions {
        AddPodOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &AddPodOptions| { &m.name },
                    |m: &mut AddPodOptions| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "desc",
                    |m: &AddPodOptions| { &m.desc },
                    |m: &mut AddPodOptions| { &mut m.desc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddPodOptions>(
                    "AddPodOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddPodOptions {
        static mut instance: ::protobuf::lazy::Lazy<AddPodOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddPodOptions,
        };
        unsafe {
            instance.get(AddPodOptions::new)
        }
    }
}

impl ::protobuf::Clear for AddPodOptions {
    fn clear(&mut self) {
        self.name.clear();
        self.desc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPodOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPodOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemovePodOptions {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemovePodOptions {
    fn default() -> &'a RemovePodOptions {
        <RemovePodOptions as ::protobuf::Message>::default_instance()
    }
}

impl RemovePodOptions {
    pub fn new() -> RemovePodOptions {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemovePodOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemovePodOptions {
        RemovePodOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &RemovePodOptions| { &m.name },
                    |m: &mut RemovePodOptions| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemovePodOptions>(
                    "RemovePodOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemovePodOptions {
        static mut instance: ::protobuf::lazy::Lazy<RemovePodOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemovePodOptions,
        };
        unsafe {
            instance.get(RemovePodOptions::new)
        }
    }
}

impl ::protobuf::Clear for RemovePodOptions {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemovePodOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemovePodOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPodOptions {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPodOptions {
    fn default() -> &'a GetPodOptions {
        <GetPodOptions as ::protobuf::Message>::default_instance()
    }
}

impl GetPodOptions {
    pub fn new() -> GetPodOptions {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetPodOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPodOptions {
        GetPodOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &GetPodOptions| { &m.name },
                    |m: &mut GetPodOptions| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPodOptions>(
                    "GetPodOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPodOptions {
        static mut instance: ::protobuf::lazy::Lazy<GetPodOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPodOptions,
        };
        unsafe {
            instance.get(GetPodOptions::new)
        }
    }
}

impl ::protobuf::Clear for GetPodOptions {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPodOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPodOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddNodeOptions {
    // message fields
    pub nodename: ::std::string::String,
    pub endpoint: ::std::string::String,
    pub podname: ::std::string::String,
    pub ca: ::std::string::String,
    pub cert: ::std::string::String,
    pub key: ::std::string::String,
    pub cpu: i32,
    pub share: i32,
    pub memory: i64,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub numa: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub numa_memory: ::std::collections::HashMap<::std::string::String, i64>,
    pub storage: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddNodeOptions {
    fn default() -> &'a AddNodeOptions {
        <AddNodeOptions as ::protobuf::Message>::default_instance()
    }
}

impl AddNodeOptions {
    pub fn new() -> AddNodeOptions {
        ::std::default::Default::default()
    }

    // string nodename = 1;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // string endpoint = 2;


    pub fn get_endpoint(&self) -> &str {
        &self.endpoint
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint, ::std::string::String::new())
    }

    // string podname = 3;


    pub fn get_podname(&self) -> &str {
        &self.podname
    }
    pub fn clear_podname(&mut self) {
        self.podname.clear();
    }

    // Param is passed by value, moved
    pub fn set_podname(&mut self, v: ::std::string::String) {
        self.podname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podname(&mut self) -> &mut ::std::string::String {
        &mut self.podname
    }

    // Take field
    pub fn take_podname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.podname, ::std::string::String::new())
    }

    // string ca = 4;


    pub fn get_ca(&self) -> &str {
        &self.ca
    }
    pub fn clear_ca(&mut self) {
        self.ca.clear();
    }

    // Param is passed by value, moved
    pub fn set_ca(&mut self, v: ::std::string::String) {
        self.ca = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ca(&mut self) -> &mut ::std::string::String {
        &mut self.ca
    }

    // Take field
    pub fn take_ca(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ca, ::std::string::String::new())
    }

    // string cert = 5;


    pub fn get_cert(&self) -> &str {
        &self.cert
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: ::std::string::String) {
        self.cert = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut ::std::string::String {
        &mut self.cert
    }

    // Take field
    pub fn take_cert(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cert, ::std::string::String::new())
    }

    // string key = 6;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // int32 cpu = 7;


    pub fn get_cpu(&self) -> i32 {
        self.cpu
    }
    pub fn clear_cpu(&mut self) {
        self.cpu = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpu(&mut self, v: i32) {
        self.cpu = v;
    }

    // int32 share = 8;


    pub fn get_share(&self) -> i32 {
        self.share
    }
    pub fn clear_share(&mut self) {
        self.share = 0;
    }

    // Param is passed by value, moved
    pub fn set_share(&mut self, v: i32) {
        self.share = v;
    }

    // int64 memory = 9;


    pub fn get_memory(&self) -> i64 {
        self.memory
    }
    pub fn clear_memory(&mut self) {
        self.memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: i64) {
        self.memory = v;
    }

    // repeated .pb.AddNodeOptions.LabelsEntry labels = 10;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .pb.AddNodeOptions.NumaEntry numa = 11;


    pub fn get_numa(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.numa
    }
    pub fn clear_numa(&mut self) {
        self.numa.clear();
    }

    // Param is passed by value, moved
    pub fn set_numa(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.numa = v;
    }

    // Mutable pointer to the field.
    pub fn mut_numa(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.numa
    }

    // Take field
    pub fn take_numa(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.numa, ::std::collections::HashMap::new())
    }

    // repeated .pb.AddNodeOptions.NumaMemoryEntry numa_memory = 12;


    pub fn get_numa_memory(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.numa_memory
    }
    pub fn clear_numa_memory(&mut self) {
        self.numa_memory.clear();
    }

    // Param is passed by value, moved
    pub fn set_numa_memory(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.numa_memory = v;
    }

    // Mutable pointer to the field.
    pub fn mut_numa_memory(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.numa_memory
    }

    // Take field
    pub fn take_numa_memory(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.numa_memory, ::std::collections::HashMap::new())
    }

    // int64 storage = 13;


    pub fn get_storage(&self) -> i64 {
        self.storage
    }
    pub fn clear_storage(&mut self) {
        self.storage = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: i64) {
        self.storage = v;
    }
}

impl ::protobuf::Message for AddNodeOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.podname)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ca)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cert)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cpu = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.share = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory = tmp;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.numa)?;
                },
                12 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.numa_memory)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.nodename);
        }
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.endpoint);
        }
        if !self.podname.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.podname);
        }
        if !self.ca.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.ca);
        }
        if !self.cert.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.cert);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.key);
        }
        if self.cpu != 0 {
            my_size += ::protobuf::rt::value_size(7, self.cpu, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.share != 0 {
            my_size += ::protobuf::rt::value_size(8, self.share, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.memory != 0 {
            my_size += ::protobuf::rt::value_size(9, self.memory, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.numa);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(12, &self.numa_memory);
        if self.storage != 0 {
            my_size += ::protobuf::rt::value_size(13, self.storage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.nodename.is_empty() {
            os.write_string(1, &self.nodename)?;
        }
        if !self.endpoint.is_empty() {
            os.write_string(2, &self.endpoint)?;
        }
        if !self.podname.is_empty() {
            os.write_string(3, &self.podname)?;
        }
        if !self.ca.is_empty() {
            os.write_string(4, &self.ca)?;
        }
        if !self.cert.is_empty() {
            os.write_string(5, &self.cert)?;
        }
        if !self.key.is_empty() {
            os.write_string(6, &self.key)?;
        }
        if self.cpu != 0 {
            os.write_int32(7, self.cpu)?;
        }
        if self.share != 0 {
            os.write_int32(8, self.share)?;
        }
        if self.memory != 0 {
            os.write_int64(9, self.memory)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.numa, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(12, &self.numa_memory, os)?;
        if self.storage != 0 {
            os.write_int64(13, self.storage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddNodeOptions {
        AddNodeOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &AddNodeOptions| { &m.nodename },
                    |m: &mut AddNodeOptions| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "endpoint",
                    |m: &AddNodeOptions| { &m.endpoint },
                    |m: &mut AddNodeOptions| { &mut m.endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podname",
                    |m: &AddNodeOptions| { &m.podname },
                    |m: &mut AddNodeOptions| { &mut m.podname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ca",
                    |m: &AddNodeOptions| { &m.ca },
                    |m: &mut AddNodeOptions| { &mut m.ca },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cert",
                    |m: &AddNodeOptions| { &m.cert },
                    |m: &mut AddNodeOptions| { &mut m.cert },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &AddNodeOptions| { &m.key },
                    |m: &mut AddNodeOptions| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "cpu",
                    |m: &AddNodeOptions| { &m.cpu },
                    |m: &mut AddNodeOptions| { &mut m.cpu },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "share",
                    |m: &AddNodeOptions| { &m.share },
                    |m: &mut AddNodeOptions| { &mut m.share },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "memory",
                    |m: &AddNodeOptions| { &m.memory },
                    |m: &mut AddNodeOptions| { &mut m.memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &AddNodeOptions| { &m.labels },
                    |m: &mut AddNodeOptions| { &mut m.labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "numa",
                    |m: &AddNodeOptions| { &m.numa },
                    |m: &mut AddNodeOptions| { &mut m.numa },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "numa_memory",
                    |m: &AddNodeOptions| { &m.numa_memory },
                    |m: &mut AddNodeOptions| { &mut m.numa_memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "storage",
                    |m: &AddNodeOptions| { &m.storage },
                    |m: &mut AddNodeOptions| { &mut m.storage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddNodeOptions>(
                    "AddNodeOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddNodeOptions {
        static mut instance: ::protobuf::lazy::Lazy<AddNodeOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddNodeOptions,
        };
        unsafe {
            instance.get(AddNodeOptions::new)
        }
    }
}

impl ::protobuf::Clear for AddNodeOptions {
    fn clear(&mut self) {
        self.nodename.clear();
        self.endpoint.clear();
        self.podname.clear();
        self.ca.clear();
        self.cert.clear();
        self.key.clear();
        self.cpu = 0;
        self.share = 0;
        self.memory = 0;
        self.labels.clear();
        self.numa.clear();
        self.numa_memory.clear();
        self.storage = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddNodeOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddNodeOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveNodeOptions {
    // message fields
    pub nodename: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveNodeOptions {
    fn default() -> &'a RemoveNodeOptions {
        <RemoveNodeOptions as ::protobuf::Message>::default_instance()
    }
}

impl RemoveNodeOptions {
    pub fn new() -> RemoveNodeOptions {
        ::std::default::Default::default()
    }

    // string nodename = 1;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoveNodeOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.nodename);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.nodename.is_empty() {
            os.write_string(1, &self.nodename)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveNodeOptions {
        RemoveNodeOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &RemoveNodeOptions| { &m.nodename },
                    |m: &mut RemoveNodeOptions| { &mut m.nodename },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveNodeOptions>(
                    "RemoveNodeOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveNodeOptions {
        static mut instance: ::protobuf::lazy::Lazy<RemoveNodeOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveNodeOptions,
        };
        unsafe {
            instance.get(RemoveNodeOptions::new)
        }
    }
}

impl ::protobuf::Clear for RemoveNodeOptions {
    fn clear(&mut self) {
        self.nodename.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveNodeOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveNodeOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNodeOptions {
    // message fields
    pub nodename: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNodeOptions {
    fn default() -> &'a GetNodeOptions {
        <GetNodeOptions as ::protobuf::Message>::default_instance()
    }
}

impl GetNodeOptions {
    pub fn new() -> GetNodeOptions {
        ::std::default::Default::default()
    }

    // string nodename = 1;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // repeated .pb.GetNodeOptions.LabelsEntry labels = 2;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for GetNodeOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.nodename);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.nodename.is_empty() {
            os.write_string(1, &self.nodename)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNodeOptions {
        GetNodeOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &GetNodeOptions| { &m.nodename },
                    |m: &mut GetNodeOptions| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &GetNodeOptions| { &m.labels },
                    |m: &mut GetNodeOptions| { &mut m.labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetNodeOptions>(
                    "GetNodeOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetNodeOptions {
        static mut instance: ::protobuf::lazy::Lazy<GetNodeOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetNodeOptions,
        };
        unsafe {
            instance.get(GetNodeOptions::new)
        }
    }
}

impl ::protobuf::Clear for GetNodeOptions {
    fn clear(&mut self) {
        self.nodename.clear();
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNodeOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNodeOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListNodesOptions {
    // message fields
    pub podname: ::std::string::String,
    pub all: bool,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListNodesOptions {
    fn default() -> &'a ListNodesOptions {
        <ListNodesOptions as ::protobuf::Message>::default_instance()
    }
}

impl ListNodesOptions {
    pub fn new() -> ListNodesOptions {
        ::std::default::Default::default()
    }

    // string podname = 1;


    pub fn get_podname(&self) -> &str {
        &self.podname
    }
    pub fn clear_podname(&mut self) {
        self.podname.clear();
    }

    // Param is passed by value, moved
    pub fn set_podname(&mut self, v: ::std::string::String) {
        self.podname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podname(&mut self) -> &mut ::std::string::String {
        &mut self.podname
    }

    // Take field
    pub fn take_podname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.podname, ::std::string::String::new())
    }

    // bool all = 2;


    pub fn get_all(&self) -> bool {
        self.all
    }
    pub fn clear_all(&mut self) {
        self.all = false;
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.all = v;
    }

    // repeated .pb.ListNodesOptions.LabelsEntry labels = 3;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ListNodesOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.podname)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all = tmp;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.podname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.podname);
        }
        if self.all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.podname.is_empty() {
            os.write_string(1, &self.podname)?;
        }
        if self.all != false {
            os.write_bool(2, self.all)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListNodesOptions {
        ListNodesOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podname",
                    |m: &ListNodesOptions| { &m.podname },
                    |m: &mut ListNodesOptions| { &mut m.podname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "all",
                    |m: &ListNodesOptions| { &m.all },
                    |m: &mut ListNodesOptions| { &mut m.all },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &ListNodesOptions| { &m.labels },
                    |m: &mut ListNodesOptions| { &mut m.labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListNodesOptions>(
                    "ListNodesOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListNodesOptions {
        static mut instance: ::protobuf::lazy::Lazy<ListNodesOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListNodesOptions,
        };
        unsafe {
            instance.get(ListNodesOptions::new)
        }
    }
}

impl ::protobuf::Clear for ListNodesOptions {
    fn clear(&mut self) {
        self.podname.clear();
        self.all = false;
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListNodesOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListNodesOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Build {
    // message fields
    pub base: ::std::string::String,
    pub repo: ::std::string::String,
    pub version: ::std::string::String,
    pub dir: ::std::string::String,
    pub submodule: bool,
    pub commands: ::protobuf::RepeatedField<::std::string::String>,
    pub envs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub args: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub artifacts: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub cache: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub stop_signal: ::std::string::String,
    pub security: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Build {
    fn default() -> &'a Build {
        <Build as ::protobuf::Message>::default_instance()
    }
}

impl Build {
    pub fn new() -> Build {
        ::std::default::Default::default()
    }

    // string base = 1;


    pub fn get_base(&self) -> &str {
        &self.base
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: ::std::string::String) {
        self.base = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut ::std::string::String {
        &mut self.base
    }

    // Take field
    pub fn take_base(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base, ::std::string::String::new())
    }

    // string repo = 2;


    pub fn get_repo(&self) -> &str {
        &self.repo
    }
    pub fn clear_repo(&mut self) {
        self.repo.clear();
    }

    // Param is passed by value, moved
    pub fn set_repo(&mut self, v: ::std::string::String) {
        self.repo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_repo(&mut self) -> &mut ::std::string::String {
        &mut self.repo
    }

    // Take field
    pub fn take_repo(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.repo, ::std::string::String::new())
    }

    // string version = 3;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string dir = 4;


    pub fn get_dir(&self) -> &str {
        &self.dir
    }
    pub fn clear_dir(&mut self) {
        self.dir.clear();
    }

    // Param is passed by value, moved
    pub fn set_dir(&mut self, v: ::std::string::String) {
        self.dir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dir(&mut self) -> &mut ::std::string::String {
        &mut self.dir
    }

    // Take field
    pub fn take_dir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dir, ::std::string::String::new())
    }

    // bool submodule = 5;


    pub fn get_submodule(&self) -> bool {
        self.submodule
    }
    pub fn clear_submodule(&mut self) {
        self.submodule = false;
    }

    // Param is passed by value, moved
    pub fn set_submodule(&mut self, v: bool) {
        self.submodule = v;
    }

    // repeated string commands = 6;


    pub fn get_commands(&self) -> &[::std::string::String] {
        &self.commands
    }
    pub fn clear_commands(&mut self) {
        self.commands.clear();
    }

    // Param is passed by value, moved
    pub fn set_commands(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.commands = v;
    }

    // Mutable pointer to the field.
    pub fn mut_commands(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.commands
    }

    // Take field
    pub fn take_commands(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.commands, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.Build.EnvsEntry envs = 7;


    pub fn get_envs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.envs
    }
    pub fn clear_envs(&mut self) {
        self.envs.clear();
    }

    // Param is passed by value, moved
    pub fn set_envs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.envs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_envs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.envs
    }

    // Take field
    pub fn take_envs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.envs, ::std::collections::HashMap::new())
    }

    // repeated .pb.Build.ArgsEntry args = 8;


    pub fn get_args(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.args, ::std::collections::HashMap::new())
    }

    // repeated .pb.Build.LabelsEntry labels = 9;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .pb.Build.ArtifactsEntry artifacts = 10;


    pub fn get_artifacts(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.artifacts
    }
    pub fn clear_artifacts(&mut self) {
        self.artifacts.clear();
    }

    // Param is passed by value, moved
    pub fn set_artifacts(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.artifacts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_artifacts(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.artifacts
    }

    // Take field
    pub fn take_artifacts(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.artifacts, ::std::collections::HashMap::new())
    }

    // repeated .pb.Build.CacheEntry cache = 11;


    pub fn get_cache(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.cache
    }
    pub fn clear_cache(&mut self) {
        self.cache.clear();
    }

    // Param is passed by value, moved
    pub fn set_cache(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.cache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cache(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.cache
    }

    // Take field
    pub fn take_cache(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.cache, ::std::collections::HashMap::new())
    }

    // string stop_signal = 12;


    pub fn get_stop_signal(&self) -> &str {
        &self.stop_signal
    }
    pub fn clear_stop_signal(&mut self) {
        self.stop_signal.clear();
    }

    // Param is passed by value, moved
    pub fn set_stop_signal(&mut self, v: ::std::string::String) {
        self.stop_signal = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stop_signal(&mut self) -> &mut ::std::string::String {
        &mut self.stop_signal
    }

    // Take field
    pub fn take_stop_signal(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stop_signal, ::std::string::String::new())
    }

    // bool security = 13;


    pub fn get_security(&self) -> bool {
        self.security
    }
    pub fn clear_security(&mut self) {
        self.security = false;
    }

    // Param is passed by value, moved
    pub fn set_security(&mut self, v: bool) {
        self.security = v;
    }
}

impl ::protobuf::Message for Build {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.repo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dir)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.submodule = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.commands)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.envs)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.args)?;
                },
                9 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.artifacts)?;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.cache)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stop_signal)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.security = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.base.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.base);
        }
        if !self.repo.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.repo);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version);
        }
        if !self.dir.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.dir);
        }
        if self.submodule != false {
            my_size += 2;
        }
        for value in &self.commands {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.envs);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.args);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.artifacts);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.cache);
        if !self.stop_signal.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.stop_signal);
        }
        if self.security != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.base.is_empty() {
            os.write_string(1, &self.base)?;
        }
        if !self.repo.is_empty() {
            os.write_string(2, &self.repo)?;
        }
        if !self.version.is_empty() {
            os.write_string(3, &self.version)?;
        }
        if !self.dir.is_empty() {
            os.write_string(4, &self.dir)?;
        }
        if self.submodule != false {
            os.write_bool(5, self.submodule)?;
        }
        for v in &self.commands {
            os.write_string(6, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.envs, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.args, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.artifacts, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.cache, os)?;
        if !self.stop_signal.is_empty() {
            os.write_string(12, &self.stop_signal)?;
        }
        if self.security != false {
            os.write_bool(13, self.security)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Build {
        Build::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "base",
                    |m: &Build| { &m.base },
                    |m: &mut Build| { &mut m.base },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "repo",
                    |m: &Build| { &m.repo },
                    |m: &mut Build| { &mut m.repo },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &Build| { &m.version },
                    |m: &mut Build| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dir",
                    |m: &Build| { &m.dir },
                    |m: &mut Build| { &mut m.dir },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "submodule",
                    |m: &Build| { &m.submodule },
                    |m: &mut Build| { &mut m.submodule },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "commands",
                    |m: &Build| { &m.commands },
                    |m: &mut Build| { &mut m.commands },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "envs",
                    |m: &Build| { &m.envs },
                    |m: &mut Build| { &mut m.envs },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "args",
                    |m: &Build| { &m.args },
                    |m: &mut Build| { &mut m.args },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &Build| { &m.labels },
                    |m: &mut Build| { &mut m.labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "artifacts",
                    |m: &Build| { &m.artifacts },
                    |m: &mut Build| { &mut m.artifacts },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "cache",
                    |m: &Build| { &m.cache },
                    |m: &mut Build| { &mut m.cache },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "stop_signal",
                    |m: &Build| { &m.stop_signal },
                    |m: &mut Build| { &mut m.stop_signal },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "security",
                    |m: &Build| { &m.security },
                    |m: &mut Build| { &mut m.security },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Build>(
                    "Build",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Build {
        static mut instance: ::protobuf::lazy::Lazy<Build> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Build,
        };
        unsafe {
            instance.get(Build::new)
        }
    }
}

impl ::protobuf::Clear for Build {
    fn clear(&mut self) {
        self.base.clear();
        self.repo.clear();
        self.version.clear();
        self.dir.clear();
        self.submodule = false;
        self.commands.clear();
        self.envs.clear();
        self.args.clear();
        self.labels.clear();
        self.artifacts.clear();
        self.cache.clear();
        self.stop_signal.clear();
        self.security = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Build {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Build {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Builds {
    // message fields
    pub stages: ::protobuf::RepeatedField<::std::string::String>,
    pub builds: ::std::collections::HashMap<::std::string::String, Build>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Builds {
    fn default() -> &'a Builds {
        <Builds as ::protobuf::Message>::default_instance()
    }
}

impl Builds {
    pub fn new() -> Builds {
        ::std::default::Default::default()
    }

    // repeated string stages = 1;


    pub fn get_stages(&self) -> &[::std::string::String] {
        &self.stages
    }
    pub fn clear_stages(&mut self) {
        self.stages.clear();
    }

    // Param is passed by value, moved
    pub fn set_stages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.stages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.stages
    }

    // Take field
    pub fn take_stages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.stages, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.Builds.BuildsEntry builds = 2;


    pub fn get_builds(&self) -> &::std::collections::HashMap<::std::string::String, Build> {
        &self.builds
    }
    pub fn clear_builds(&mut self) {
        self.builds.clear();
    }

    // Param is passed by value, moved
    pub fn set_builds(&mut self, v: ::std::collections::HashMap<::std::string::String, Build>) {
        self.builds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_builds(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, Build> {
        &mut self.builds
    }

    // Take field
    pub fn take_builds(&mut self) -> ::std::collections::HashMap<::std::string::String, Build> {
        ::std::mem::replace(&mut self.builds, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Builds {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.stages)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Build>>(wire_type, is, &mut self.builds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stages {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Build>>(2, &self.builds);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stages {
            os.write_string(1, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Build>>(2, &self.builds, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Builds {
        Builds::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "stages",
                    |m: &Builds| { &m.stages },
                    |m: &mut Builds| { &mut m.stages },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Build>>(
                    "builds",
                    |m: &Builds| { &m.builds },
                    |m: &mut Builds| { &mut m.builds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Builds>(
                    "Builds",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Builds {
        static mut instance: ::protobuf::lazy::Lazy<Builds> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Builds,
        };
        unsafe {
            instance.get(Builds::new)
        }
    }
}

impl ::protobuf::Clear for Builds {
    fn clear(&mut self) {
        self.stages.clear();
        self.builds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Builds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Builds {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildImageOptions {
    // message fields
    pub name: ::std::string::String,
    pub user: ::std::string::String,
    pub uid: i32,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub builds: ::protobuf::SingularPtrField<Builds>,
    pub tar: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildImageOptions {
    fn default() -> &'a BuildImageOptions {
        <BuildImageOptions as ::protobuf::Message>::default_instance()
    }
}

impl BuildImageOptions {
    pub fn new() -> BuildImageOptions {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string user = 2;


    pub fn get_user(&self) -> &str {
        &self.user
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        &mut self.user
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user, ::std::string::String::new())
    }

    // int32 uid = 3;


    pub fn get_uid(&self) -> i32 {
        self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid = 0;
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: i32) {
        self.uid = v;
    }

    // repeated string tags = 4;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // .pb.Builds builds = 5;


    pub fn get_builds(&self) -> &Builds {
        self.builds.as_ref().unwrap_or_else(|| Builds::default_instance())
    }
    pub fn clear_builds(&mut self) {
        self.builds.clear();
    }

    pub fn has_builds(&self) -> bool {
        self.builds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_builds(&mut self, v: Builds) {
        self.builds = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_builds(&mut self) -> &mut Builds {
        if self.builds.is_none() {
            self.builds.set_default();
        }
        self.builds.as_mut().unwrap()
    }

    // Take field
    pub fn take_builds(&mut self) -> Builds {
        self.builds.take().unwrap_or_else(|| Builds::new())
    }

    // bytes tar = 6;


    pub fn get_tar(&self) -> &[u8] {
        &self.tar
    }
    pub fn clear_tar(&mut self) {
        self.tar.clear();
    }

    // Param is passed by value, moved
    pub fn set_tar(&mut self, v: ::std::vec::Vec<u8>) {
        self.tar = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tar(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tar
    }

    // Take field
    pub fn take_tar(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tar, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BuildImageOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.builds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.uid = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.builds)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tar)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user);
        }
        if self.uid != 0 {
            my_size += ::protobuf::rt::value_size(3, self.uid, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.builds.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.tar.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.tar);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.user.is_empty() {
            os.write_string(2, &self.user)?;
        }
        if self.uid != 0 {
            os.write_int32(3, self.uid)?;
        }
        for v in &self.tags {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.builds.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.tar.is_empty() {
            os.write_bytes(6, &self.tar)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildImageOptions {
        BuildImageOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &BuildImageOptions| { &m.name },
                    |m: &mut BuildImageOptions| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    |m: &BuildImageOptions| { &m.user },
                    |m: &mut BuildImageOptions| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "uid",
                    |m: &BuildImageOptions| { &m.uid },
                    |m: &mut BuildImageOptions| { &mut m.uid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tags",
                    |m: &BuildImageOptions| { &m.tags },
                    |m: &mut BuildImageOptions| { &mut m.tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Builds>>(
                    "builds",
                    |m: &BuildImageOptions| { &m.builds },
                    |m: &mut BuildImageOptions| { &mut m.builds },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "tar",
                    |m: &BuildImageOptions| { &m.tar },
                    |m: &mut BuildImageOptions| { &mut m.tar },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BuildImageOptions>(
                    "BuildImageOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BuildImageOptions {
        static mut instance: ::protobuf::lazy::Lazy<BuildImageOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BuildImageOptions,
        };
        unsafe {
            instance.get(BuildImageOptions::new)
        }
    }
}

impl ::protobuf::Clear for BuildImageOptions {
    fn clear(&mut self) {
        self.name.clear();
        self.user.clear();
        self.uid = 0;
        self.tags.clear();
        self.builds.clear();
        self.tar.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildImageOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildImageOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HookOptions {
    // message fields
    pub after_start: ::protobuf::RepeatedField<::std::string::String>,
    pub before_stop: ::protobuf::RepeatedField<::std::string::String>,
    pub force: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HookOptions {
    fn default() -> &'a HookOptions {
        <HookOptions as ::protobuf::Message>::default_instance()
    }
}

impl HookOptions {
    pub fn new() -> HookOptions {
        ::std::default::Default::default()
    }

    // repeated string after_start = 1;


    pub fn get_after_start(&self) -> &[::std::string::String] {
        &self.after_start
    }
    pub fn clear_after_start(&mut self) {
        self.after_start.clear();
    }

    // Param is passed by value, moved
    pub fn set_after_start(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.after_start = v;
    }

    // Mutable pointer to the field.
    pub fn mut_after_start(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.after_start
    }

    // Take field
    pub fn take_after_start(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.after_start, ::protobuf::RepeatedField::new())
    }

    // repeated string before_stop = 2;


    pub fn get_before_stop(&self) -> &[::std::string::String] {
        &self.before_stop
    }
    pub fn clear_before_stop(&mut self) {
        self.before_stop.clear();
    }

    // Param is passed by value, moved
    pub fn set_before_stop(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.before_stop = v;
    }

    // Mutable pointer to the field.
    pub fn mut_before_stop(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.before_stop
    }

    // Take field
    pub fn take_before_stop(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.before_stop, ::protobuf::RepeatedField::new())
    }

    // bool force = 3;


    pub fn get_force(&self) -> bool {
        self.force
    }
    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }
}

impl ::protobuf::Message for HookOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.after_start)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.before_stop)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.after_start {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.before_stop {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.force != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.after_start {
            os.write_string(1, &v)?;
        };
        for v in &self.before_stop {
            os.write_string(2, &v)?;
        };
        if self.force != false {
            os.write_bool(3, self.force)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HookOptions {
        HookOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "after_start",
                    |m: &HookOptions| { &m.after_start },
                    |m: &mut HookOptions| { &mut m.after_start },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "before_stop",
                    |m: &HookOptions| { &m.before_stop },
                    |m: &mut HookOptions| { &mut m.before_stop },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "force",
                    |m: &HookOptions| { &m.force },
                    |m: &mut HookOptions| { &mut m.force },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HookOptions>(
                    "HookOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HookOptions {
        static mut instance: ::protobuf::lazy::Lazy<HookOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HookOptions,
        };
        unsafe {
            instance.get(HookOptions::new)
        }
    }
}

impl ::protobuf::Clear for HookOptions {
    fn clear(&mut self) {
        self.after_start.clear();
        self.before_stop.clear();
        self.force = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HookOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HookOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheckOptions {
    // message fields
    pub tcp_ports: ::protobuf::RepeatedField<::std::string::String>,
    pub http_port: ::std::string::String,
    pub url: ::std::string::String,
    pub code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheckOptions {
    fn default() -> &'a HealthCheckOptions {
        <HealthCheckOptions as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheckOptions {
    pub fn new() -> HealthCheckOptions {
        ::std::default::Default::default()
    }

    // repeated string tcp_ports = 1;


    pub fn get_tcp_ports(&self) -> &[::std::string::String] {
        &self.tcp_ports
    }
    pub fn clear_tcp_ports(&mut self) {
        self.tcp_ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_tcp_ports(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tcp_ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tcp_ports(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tcp_ports
    }

    // Take field
    pub fn take_tcp_ports(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tcp_ports, ::protobuf::RepeatedField::new())
    }

    // string http_port = 2;


    pub fn get_http_port(&self) -> &str {
        &self.http_port
    }
    pub fn clear_http_port(&mut self) {
        self.http_port.clear();
    }

    // Param is passed by value, moved
    pub fn set_http_port(&mut self, v: ::std::string::String) {
        self.http_port = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_port(&mut self) -> &mut ::std::string::String {
        &mut self.http_port
    }

    // Take field
    pub fn take_http_port(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.http_port, ::std::string::String::new())
    }

    // string url = 3;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // int32 code = 4;


    pub fn get_code(&self) -> i32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = v;
    }
}

impl ::protobuf::Message for HealthCheckOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tcp_ports)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.http_port)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tcp_ports {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.http_port.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.http_port);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.url);
        }
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(4, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tcp_ports {
            os.write_string(1, &v)?;
        };
        if !self.http_port.is_empty() {
            os.write_string(2, &self.http_port)?;
        }
        if !self.url.is_empty() {
            os.write_string(3, &self.url)?;
        }
        if self.code != 0 {
            os.write_int32(4, self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheckOptions {
        HealthCheckOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tcp_ports",
                    |m: &HealthCheckOptions| { &m.tcp_ports },
                    |m: &mut HealthCheckOptions| { &mut m.tcp_ports },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "http_port",
                    |m: &HealthCheckOptions| { &m.http_port },
                    |m: &mut HealthCheckOptions| { &mut m.http_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &HealthCheckOptions| { &m.url },
                    |m: &mut HealthCheckOptions| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "code",
                    |m: &HealthCheckOptions| { &m.code },
                    |m: &mut HealthCheckOptions| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HealthCheckOptions>(
                    "HealthCheckOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HealthCheckOptions {
        static mut instance: ::protobuf::lazy::Lazy<HealthCheckOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HealthCheckOptions,
        };
        unsafe {
            instance.get(HealthCheckOptions::new)
        }
    }
}

impl ::protobuf::Clear for HealthCheckOptions {
    fn clear(&mut self) {
        self.tcp_ports.clear();
        self.http_port.clear();
        self.url.clear();
        self.code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheckOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheckOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogOptions {
    // message fields
    pub field_type: ::std::string::String,
    pub config: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogOptions {
    fn default() -> &'a LogOptions {
        <LogOptions as ::protobuf::Message>::default_instance()
    }
}

impl LogOptions {
    pub fn new() -> LogOptions {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // repeated .pb.LogOptions.ConfigEntry config = 2;


    pub fn get_config(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.config
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.config, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for LogOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.config);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.config, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogOptions {
        LogOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &LogOptions| { &m.field_type },
                    |m: &mut LogOptions| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "config",
                    |m: &LogOptions| { &m.config },
                    |m: &mut LogOptions| { &mut m.config },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LogOptions>(
                    "LogOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LogOptions {
        static mut instance: ::protobuf::lazy::Lazy<LogOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LogOptions,
        };
        unsafe {
            instance.get(LogOptions::new)
        }
    }
}

impl ::protobuf::Clear for LogOptions {
    fn clear(&mut self) {
        self.field_type.clear();
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntrypointOptions {
    // message fields
    pub name: ::std::string::String,
    pub command: ::std::string::String,
    pub privileged: bool,
    pub dir: ::std::string::String,
    pub log: ::protobuf::SingularPtrField<LogOptions>,
    pub publish: ::protobuf::RepeatedField<::std::string::String>,
    pub healthcheck: ::protobuf::SingularPtrField<HealthCheckOptions>,
    pub hook: ::protobuf::SingularPtrField<HookOptions>,
    pub restart_policy: ::std::string::String,
    pub sysctls: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntrypointOptions {
    fn default() -> &'a EntrypointOptions {
        <EntrypointOptions as ::protobuf::Message>::default_instance()
    }
}

impl EntrypointOptions {
    pub fn new() -> EntrypointOptions {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string command = 2;


    pub fn get_command(&self) -> &str {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::string::String) {
        self.command = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::std::string::String {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.command, ::std::string::String::new())
    }

    // bool privileged = 3;


    pub fn get_privileged(&self) -> bool {
        self.privileged
    }
    pub fn clear_privileged(&mut self) {
        self.privileged = false;
    }

    // Param is passed by value, moved
    pub fn set_privileged(&mut self, v: bool) {
        self.privileged = v;
    }

    // string dir = 4;


    pub fn get_dir(&self) -> &str {
        &self.dir
    }
    pub fn clear_dir(&mut self) {
        self.dir.clear();
    }

    // Param is passed by value, moved
    pub fn set_dir(&mut self, v: ::std::string::String) {
        self.dir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dir(&mut self) -> &mut ::std::string::String {
        &mut self.dir
    }

    // Take field
    pub fn take_dir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dir, ::std::string::String::new())
    }

    // .pb.LogOptions log = 5;


    pub fn get_log(&self) -> &LogOptions {
        self.log.as_ref().unwrap_or_else(|| LogOptions::default_instance())
    }
    pub fn clear_log(&mut self) {
        self.log.clear();
    }

    pub fn has_log(&self) -> bool {
        self.log.is_some()
    }

    // Param is passed by value, moved
    pub fn set_log(&mut self, v: LogOptions) {
        self.log = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_log(&mut self) -> &mut LogOptions {
        if self.log.is_none() {
            self.log.set_default();
        }
        self.log.as_mut().unwrap()
    }

    // Take field
    pub fn take_log(&mut self) -> LogOptions {
        self.log.take().unwrap_or_else(|| LogOptions::new())
    }

    // repeated string publish = 6;


    pub fn get_publish(&self) -> &[::std::string::String] {
        &self.publish
    }
    pub fn clear_publish(&mut self) {
        self.publish.clear();
    }

    // Param is passed by value, moved
    pub fn set_publish(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.publish = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publish(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.publish
    }

    // Take field
    pub fn take_publish(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.publish, ::protobuf::RepeatedField::new())
    }

    // .pb.HealthCheckOptions healthcheck = 7;


    pub fn get_healthcheck(&self) -> &HealthCheckOptions {
        self.healthcheck.as_ref().unwrap_or_else(|| HealthCheckOptions::default_instance())
    }
    pub fn clear_healthcheck(&mut self) {
        self.healthcheck.clear();
    }

    pub fn has_healthcheck(&self) -> bool {
        self.healthcheck.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthcheck(&mut self, v: HealthCheckOptions) {
        self.healthcheck = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_healthcheck(&mut self) -> &mut HealthCheckOptions {
        if self.healthcheck.is_none() {
            self.healthcheck.set_default();
        }
        self.healthcheck.as_mut().unwrap()
    }

    // Take field
    pub fn take_healthcheck(&mut self) -> HealthCheckOptions {
        self.healthcheck.take().unwrap_or_else(|| HealthCheckOptions::new())
    }

    // .pb.HookOptions hook = 8;


    pub fn get_hook(&self) -> &HookOptions {
        self.hook.as_ref().unwrap_or_else(|| HookOptions::default_instance())
    }
    pub fn clear_hook(&mut self) {
        self.hook.clear();
    }

    pub fn has_hook(&self) -> bool {
        self.hook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hook(&mut self, v: HookOptions) {
        self.hook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hook(&mut self) -> &mut HookOptions {
        if self.hook.is_none() {
            self.hook.set_default();
        }
        self.hook.as_mut().unwrap()
    }

    // Take field
    pub fn take_hook(&mut self) -> HookOptions {
        self.hook.take().unwrap_or_else(|| HookOptions::new())
    }

    // string restart_policy = 9;


    pub fn get_restart_policy(&self) -> &str {
        &self.restart_policy
    }
    pub fn clear_restart_policy(&mut self) {
        self.restart_policy.clear();
    }

    // Param is passed by value, moved
    pub fn set_restart_policy(&mut self, v: ::std::string::String) {
        self.restart_policy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_restart_policy(&mut self) -> &mut ::std::string::String {
        &mut self.restart_policy
    }

    // Take field
    pub fn take_restart_policy(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.restart_policy, ::std::string::String::new())
    }

    // repeated .pb.EntrypointOptions.SysctlsEntry sysctls = 10;


    pub fn get_sysctls(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.sysctls
    }
    pub fn clear_sysctls(&mut self) {
        self.sysctls.clear();
    }

    // Param is passed by value, moved
    pub fn set_sysctls(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.sysctls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sysctls(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.sysctls
    }

    // Take field
    pub fn take_sysctls(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.sysctls, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for EntrypointOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.log {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.healthcheck {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.command)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.privileged = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dir)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.log)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.publish)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.healthcheck)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hook)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.restart_policy)?;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.sysctls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.command.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.command);
        }
        if self.privileged != false {
            my_size += 2;
        }
        if !self.dir.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.dir);
        }
        if let Some(ref v) = self.log.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.publish {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(ref v) = self.healthcheck.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.restart_policy.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.restart_policy);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.sysctls);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.command.is_empty() {
            os.write_string(2, &self.command)?;
        }
        if self.privileged != false {
            os.write_bool(3, self.privileged)?;
        }
        if !self.dir.is_empty() {
            os.write_string(4, &self.dir)?;
        }
        if let Some(ref v) = self.log.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.publish {
            os.write_string(6, &v)?;
        };
        if let Some(ref v) = self.healthcheck.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hook.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.restart_policy.is_empty() {
            os.write_string(9, &self.restart_policy)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.sysctls, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntrypointOptions {
        EntrypointOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &EntrypointOptions| { &m.name },
                    |m: &mut EntrypointOptions| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "command",
                    |m: &EntrypointOptions| { &m.command },
                    |m: &mut EntrypointOptions| { &mut m.command },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "privileged",
                    |m: &EntrypointOptions| { &m.privileged },
                    |m: &mut EntrypointOptions| { &mut m.privileged },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dir",
                    |m: &EntrypointOptions| { &m.dir },
                    |m: &mut EntrypointOptions| { &mut m.dir },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogOptions>>(
                    "log",
                    |m: &EntrypointOptions| { &m.log },
                    |m: &mut EntrypointOptions| { &mut m.log },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "publish",
                    |m: &EntrypointOptions| { &m.publish },
                    |m: &mut EntrypointOptions| { &mut m.publish },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HealthCheckOptions>>(
                    "healthcheck",
                    |m: &EntrypointOptions| { &m.healthcheck },
                    |m: &mut EntrypointOptions| { &mut m.healthcheck },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HookOptions>>(
                    "hook",
                    |m: &EntrypointOptions| { &m.hook },
                    |m: &mut EntrypointOptions| { &mut m.hook },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "restart_policy",
                    |m: &EntrypointOptions| { &m.restart_policy },
                    |m: &mut EntrypointOptions| { &mut m.restart_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "sysctls",
                    |m: &EntrypointOptions| { &m.sysctls },
                    |m: &mut EntrypointOptions| { &mut m.sysctls },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EntrypointOptions>(
                    "EntrypointOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EntrypointOptions {
        static mut instance: ::protobuf::lazy::Lazy<EntrypointOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EntrypointOptions,
        };
        unsafe {
            instance.get(EntrypointOptions::new)
        }
    }
}

impl ::protobuf::Clear for EntrypointOptions {
    fn clear(&mut self) {
        self.name.clear();
        self.command.clear();
        self.privileged = false;
        self.dir.clear();
        self.log.clear();
        self.publish.clear();
        self.healthcheck.clear();
        self.hook.clear();
        self.restart_policy.clear();
        self.sysctls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntrypointOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntrypointOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeployOptions {
    // message fields
    pub name: ::std::string::String,
    pub entrypoint: ::protobuf::SingularPtrField<EntrypointOptions>,
    pub podname: ::std::string::String,
    pub nodename: ::std::string::String,
    pub image: ::std::string::String,
    pub extra_args: ::std::string::String,
    pub cpu_quota: f64,
    pub memory: i64,
    pub count: i32,
    pub env: ::protobuf::RepeatedField<::std::string::String>,
    pub dns: ::protobuf::RepeatedField<::std::string::String>,
    pub extra_hosts: ::protobuf::RepeatedField<::std::string::String>,
    pub volumes: ::protobuf::RepeatedField<::std::string::String>,
    pub networks: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub networkmode: ::std::string::String,
    pub user: ::std::string::String,
    pub debug: bool,
    pub openStdin: bool,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub nodelabels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub deploy_method: ::std::string::String,
    pub data: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    pub soft_limit: bool,
    pub nodes_limit: i32,
    pub cpu_bind: bool,
    pub ignore_hook: bool,
    pub after_create: ::protobuf::RepeatedField<::std::string::String>,
    pub raw_args: ::std::vec::Vec<u8>,
    pub storage: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeployOptions {
    fn default() -> &'a DeployOptions {
        <DeployOptions as ::protobuf::Message>::default_instance()
    }
}

impl DeployOptions {
    pub fn new() -> DeployOptions {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .pb.EntrypointOptions entrypoint = 2;


    pub fn get_entrypoint(&self) -> &EntrypointOptions {
        self.entrypoint.as_ref().unwrap_or_else(|| EntrypointOptions::default_instance())
    }
    pub fn clear_entrypoint(&mut self) {
        self.entrypoint.clear();
    }

    pub fn has_entrypoint(&self) -> bool {
        self.entrypoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entrypoint(&mut self, v: EntrypointOptions) {
        self.entrypoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entrypoint(&mut self) -> &mut EntrypointOptions {
        if self.entrypoint.is_none() {
            self.entrypoint.set_default();
        }
        self.entrypoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_entrypoint(&mut self) -> EntrypointOptions {
        self.entrypoint.take().unwrap_or_else(|| EntrypointOptions::new())
    }

    // string podname = 3;


    pub fn get_podname(&self) -> &str {
        &self.podname
    }
    pub fn clear_podname(&mut self) {
        self.podname.clear();
    }

    // Param is passed by value, moved
    pub fn set_podname(&mut self, v: ::std::string::String) {
        self.podname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podname(&mut self) -> &mut ::std::string::String {
        &mut self.podname
    }

    // Take field
    pub fn take_podname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.podname, ::std::string::String::new())
    }

    // string nodename = 4;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // string image = 5;


    pub fn get_image(&self) -> &str {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image, ::std::string::String::new())
    }

    // string extra_args = 6;


    pub fn get_extra_args(&self) -> &str {
        &self.extra_args
    }
    pub fn clear_extra_args(&mut self) {
        self.extra_args.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_args(&mut self, v: ::std::string::String) {
        self.extra_args = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_args(&mut self) -> &mut ::std::string::String {
        &mut self.extra_args
    }

    // Take field
    pub fn take_extra_args(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.extra_args, ::std::string::String::new())
    }

    // double cpu_quota = 7;


    pub fn get_cpu_quota(&self) -> f64 {
        self.cpu_quota
    }
    pub fn clear_cpu_quota(&mut self) {
        self.cpu_quota = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cpu_quota(&mut self, v: f64) {
        self.cpu_quota = v;
    }

    // int64 memory = 8;


    pub fn get_memory(&self) -> i64 {
        self.memory
    }
    pub fn clear_memory(&mut self) {
        self.memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: i64) {
        self.memory = v;
    }

    // int32 count = 9;


    pub fn get_count(&self) -> i32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = v;
    }

    // repeated string env = 10;


    pub fn get_env(&self) -> &[::std::string::String] {
        &self.env
    }
    pub fn clear_env(&mut self) {
        self.env.clear();
    }

    // Param is passed by value, moved
    pub fn set_env(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_env(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.env
    }

    // Take field
    pub fn take_env(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.env, ::protobuf::RepeatedField::new())
    }

    // repeated string dns = 11;


    pub fn get_dns(&self) -> &[::std::string::String] {
        &self.dns
    }
    pub fn clear_dns(&mut self) {
        self.dns.clear();
    }

    // Param is passed by value, moved
    pub fn set_dns(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dns(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dns
    }

    // Take field
    pub fn take_dns(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dns, ::protobuf::RepeatedField::new())
    }

    // repeated string extra_hosts = 12;


    pub fn get_extra_hosts(&self) -> &[::std::string::String] {
        &self.extra_hosts
    }
    pub fn clear_extra_hosts(&mut self) {
        self.extra_hosts.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_hosts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.extra_hosts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_hosts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.extra_hosts
    }

    // Take field
    pub fn take_extra_hosts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.extra_hosts, ::protobuf::RepeatedField::new())
    }

    // repeated string volumes = 13;


    pub fn get_volumes(&self) -> &[::std::string::String] {
        &self.volumes
    }
    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.DeployOptions.NetworksEntry networks = 14;


    pub fn get_networks(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.networks
    }
    pub fn clear_networks(&mut self) {
        self.networks.clear();
    }

    // Param is passed by value, moved
    pub fn set_networks(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.networks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_networks(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.networks
    }

    // Take field
    pub fn take_networks(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.networks, ::std::collections::HashMap::new())
    }

    // string networkmode = 15;


    pub fn get_networkmode(&self) -> &str {
        &self.networkmode
    }
    pub fn clear_networkmode(&mut self) {
        self.networkmode.clear();
    }

    // Param is passed by value, moved
    pub fn set_networkmode(&mut self, v: ::std::string::String) {
        self.networkmode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_networkmode(&mut self) -> &mut ::std::string::String {
        &mut self.networkmode
    }

    // Take field
    pub fn take_networkmode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.networkmode, ::std::string::String::new())
    }

    // string user = 16;


    pub fn get_user(&self) -> &str {
        &self.user
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        &mut self.user
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user, ::std::string::String::new())
    }

    // bool debug = 17;


    pub fn get_debug(&self) -> bool {
        self.debug
    }
    pub fn clear_debug(&mut self) {
        self.debug = false;
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: bool) {
        self.debug = v;
    }

    // bool openStdin = 18;


    pub fn get_openStdin(&self) -> bool {
        self.openStdin
    }
    pub fn clear_openStdin(&mut self) {
        self.openStdin = false;
    }

    // Param is passed by value, moved
    pub fn set_openStdin(&mut self, v: bool) {
        self.openStdin = v;
    }

    // repeated .pb.DeployOptions.LabelsEntry labels = 19;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .pb.DeployOptions.NodelabelsEntry nodelabels = 20;


    pub fn get_nodelabels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.nodelabels
    }
    pub fn clear_nodelabels(&mut self) {
        self.nodelabels.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodelabels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.nodelabels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodelabels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.nodelabels
    }

    // Take field
    pub fn take_nodelabels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.nodelabels, ::std::collections::HashMap::new())
    }

    // string deploy_method = 21;


    pub fn get_deploy_method(&self) -> &str {
        &self.deploy_method
    }
    pub fn clear_deploy_method(&mut self) {
        self.deploy_method.clear();
    }

    // Param is passed by value, moved
    pub fn set_deploy_method(&mut self, v: ::std::string::String) {
        self.deploy_method = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deploy_method(&mut self) -> &mut ::std::string::String {
        &mut self.deploy_method
    }

    // Take field
    pub fn take_deploy_method(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.deploy_method, ::std::string::String::new())
    }

    // repeated .pb.DeployOptions.DataEntry data = 22;


    pub fn get_data(&self) -> &::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.data, ::std::collections::HashMap::new())
    }

    // bool soft_limit = 23;


    pub fn get_soft_limit(&self) -> bool {
        self.soft_limit
    }
    pub fn clear_soft_limit(&mut self) {
        self.soft_limit = false;
    }

    // Param is passed by value, moved
    pub fn set_soft_limit(&mut self, v: bool) {
        self.soft_limit = v;
    }

    // int32 nodes_limit = 24;


    pub fn get_nodes_limit(&self) -> i32 {
        self.nodes_limit
    }
    pub fn clear_nodes_limit(&mut self) {
        self.nodes_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_nodes_limit(&mut self, v: i32) {
        self.nodes_limit = v;
    }

    // bool cpu_bind = 25;


    pub fn get_cpu_bind(&self) -> bool {
        self.cpu_bind
    }
    pub fn clear_cpu_bind(&mut self) {
        self.cpu_bind = false;
    }

    // Param is passed by value, moved
    pub fn set_cpu_bind(&mut self, v: bool) {
        self.cpu_bind = v;
    }

    // bool ignore_hook = 26;


    pub fn get_ignore_hook(&self) -> bool {
        self.ignore_hook
    }
    pub fn clear_ignore_hook(&mut self) {
        self.ignore_hook = false;
    }

    // Param is passed by value, moved
    pub fn set_ignore_hook(&mut self, v: bool) {
        self.ignore_hook = v;
    }

    // repeated string after_create = 27;


    pub fn get_after_create(&self) -> &[::std::string::String] {
        &self.after_create
    }
    pub fn clear_after_create(&mut self) {
        self.after_create.clear();
    }

    // Param is passed by value, moved
    pub fn set_after_create(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.after_create = v;
    }

    // Mutable pointer to the field.
    pub fn mut_after_create(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.after_create
    }

    // Take field
    pub fn take_after_create(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.after_create, ::protobuf::RepeatedField::new())
    }

    // bytes raw_args = 28;


    pub fn get_raw_args(&self) -> &[u8] {
        &self.raw_args
    }
    pub fn clear_raw_args(&mut self) {
        self.raw_args.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_args(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_args = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_args(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.raw_args
    }

    // Take field
    pub fn take_raw_args(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.raw_args, ::std::vec::Vec::new())
    }

    // int64 storage = 29;


    pub fn get_storage(&self) -> i64 {
        self.storage
    }
    pub fn clear_storage(&mut self) {
        self.storage = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: i64) {
        self.storage = v;
    }
}

impl ::protobuf::Message for DeployOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.entrypoint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.entrypoint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.podname)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.extra_args)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cpu_quota = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.env)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dns)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.extra_hosts)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.volumes)?;
                },
                14 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.networks)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.networkmode)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.debug = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.openStdin = tmp;
                },
                19 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                20 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.nodelabels)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.deploy_method)?;
                },
                22 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.data)?;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.soft_limit = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nodes_limit = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cpu_bind = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_hook = tmp;
                },
                27 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.after_create)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.raw_args)?;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.entrypoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.podname.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.podname);
        }
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.nodename);
        }
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.image);
        }
        if !self.extra_args.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.extra_args);
        }
        if self.cpu_quota != 0. {
            my_size += 9;
        }
        if self.memory != 0 {
            my_size += ::protobuf::rt::value_size(8, self.memory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(9, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.env {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.dns {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.extra_hosts {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.volumes {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(14, &self.networks);
        if !self.networkmode.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.networkmode);
        }
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.user);
        }
        if self.debug != false {
            my_size += 3;
        }
        if self.openStdin != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(19, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(20, &self.nodelabels);
        if !self.deploy_method.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.deploy_method);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(22, &self.data);
        if self.soft_limit != false {
            my_size += 3;
        }
        if self.nodes_limit != 0 {
            my_size += ::protobuf::rt::value_size(24, self.nodes_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cpu_bind != false {
            my_size += 3;
        }
        if self.ignore_hook != false {
            my_size += 3;
        }
        for value in &self.after_create {
            my_size += ::protobuf::rt::string_size(27, &value);
        };
        if !self.raw_args.is_empty() {
            my_size += ::protobuf::rt::bytes_size(28, &self.raw_args);
        }
        if self.storage != 0 {
            my_size += ::protobuf::rt::value_size(29, self.storage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.entrypoint.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.podname.is_empty() {
            os.write_string(3, &self.podname)?;
        }
        if !self.nodename.is_empty() {
            os.write_string(4, &self.nodename)?;
        }
        if !self.image.is_empty() {
            os.write_string(5, &self.image)?;
        }
        if !self.extra_args.is_empty() {
            os.write_string(6, &self.extra_args)?;
        }
        if self.cpu_quota != 0. {
            os.write_double(7, self.cpu_quota)?;
        }
        if self.memory != 0 {
            os.write_int64(8, self.memory)?;
        }
        if self.count != 0 {
            os.write_int32(9, self.count)?;
        }
        for v in &self.env {
            os.write_string(10, &v)?;
        };
        for v in &self.dns {
            os.write_string(11, &v)?;
        };
        for v in &self.extra_hosts {
            os.write_string(12, &v)?;
        };
        for v in &self.volumes {
            os.write_string(13, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(14, &self.networks, os)?;
        if !self.networkmode.is_empty() {
            os.write_string(15, &self.networkmode)?;
        }
        if !self.user.is_empty() {
            os.write_string(16, &self.user)?;
        }
        if self.debug != false {
            os.write_bool(17, self.debug)?;
        }
        if self.openStdin != false {
            os.write_bool(18, self.openStdin)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(19, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(20, &self.nodelabels, os)?;
        if !self.deploy_method.is_empty() {
            os.write_string(21, &self.deploy_method)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(22, &self.data, os)?;
        if self.soft_limit != false {
            os.write_bool(23, self.soft_limit)?;
        }
        if self.nodes_limit != 0 {
            os.write_int32(24, self.nodes_limit)?;
        }
        if self.cpu_bind != false {
            os.write_bool(25, self.cpu_bind)?;
        }
        if self.ignore_hook != false {
            os.write_bool(26, self.ignore_hook)?;
        }
        for v in &self.after_create {
            os.write_string(27, &v)?;
        };
        if !self.raw_args.is_empty() {
            os.write_bytes(28, &self.raw_args)?;
        }
        if self.storage != 0 {
            os.write_int64(29, self.storage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeployOptions {
        DeployOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &DeployOptions| { &m.name },
                    |m: &mut DeployOptions| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EntrypointOptions>>(
                    "entrypoint",
                    |m: &DeployOptions| { &m.entrypoint },
                    |m: &mut DeployOptions| { &mut m.entrypoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podname",
                    |m: &DeployOptions| { &m.podname },
                    |m: &mut DeployOptions| { &mut m.podname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &DeployOptions| { &m.nodename },
                    |m: &mut DeployOptions| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image",
                    |m: &DeployOptions| { &m.image },
                    |m: &mut DeployOptions| { &mut m.image },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "extra_args",
                    |m: &DeployOptions| { &m.extra_args },
                    |m: &mut DeployOptions| { &mut m.extra_args },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "cpu_quota",
                    |m: &DeployOptions| { &m.cpu_quota },
                    |m: &mut DeployOptions| { &mut m.cpu_quota },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "memory",
                    |m: &DeployOptions| { &m.memory },
                    |m: &mut DeployOptions| { &mut m.memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "count",
                    |m: &DeployOptions| { &m.count },
                    |m: &mut DeployOptions| { &mut m.count },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "env",
                    |m: &DeployOptions| { &m.env },
                    |m: &mut DeployOptions| { &mut m.env },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dns",
                    |m: &DeployOptions| { &m.dns },
                    |m: &mut DeployOptions| { &mut m.dns },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "extra_hosts",
                    |m: &DeployOptions| { &m.extra_hosts },
                    |m: &mut DeployOptions| { &mut m.extra_hosts },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumes",
                    |m: &DeployOptions| { &m.volumes },
                    |m: &mut DeployOptions| { &mut m.volumes },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "networks",
                    |m: &DeployOptions| { &m.networks },
                    |m: &mut DeployOptions| { &mut m.networks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "networkmode",
                    |m: &DeployOptions| { &m.networkmode },
                    |m: &mut DeployOptions| { &mut m.networkmode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    |m: &DeployOptions| { &m.user },
                    |m: &mut DeployOptions| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "debug",
                    |m: &DeployOptions| { &m.debug },
                    |m: &mut DeployOptions| { &mut m.debug },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "openStdin",
                    |m: &DeployOptions| { &m.openStdin },
                    |m: &mut DeployOptions| { &mut m.openStdin },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &DeployOptions| { &m.labels },
                    |m: &mut DeployOptions| { &mut m.labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "nodelabels",
                    |m: &DeployOptions| { &m.nodelabels },
                    |m: &mut DeployOptions| { &mut m.nodelabels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "deploy_method",
                    |m: &DeployOptions| { &m.deploy_method },
                    |m: &mut DeployOptions| { &mut m.deploy_method },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &DeployOptions| { &m.data },
                    |m: &mut DeployOptions| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "soft_limit",
                    |m: &DeployOptions| { &m.soft_limit },
                    |m: &mut DeployOptions| { &mut m.soft_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "nodes_limit",
                    |m: &DeployOptions| { &m.nodes_limit },
                    |m: &mut DeployOptions| { &mut m.nodes_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "cpu_bind",
                    |m: &DeployOptions| { &m.cpu_bind },
                    |m: &mut DeployOptions| { &mut m.cpu_bind },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ignore_hook",
                    |m: &DeployOptions| { &m.ignore_hook },
                    |m: &mut DeployOptions| { &mut m.ignore_hook },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "after_create",
                    |m: &DeployOptions| { &m.after_create },
                    |m: &mut DeployOptions| { &mut m.after_create },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "raw_args",
                    |m: &DeployOptions| { &m.raw_args },
                    |m: &mut DeployOptions| { &mut m.raw_args },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "storage",
                    |m: &DeployOptions| { &m.storage },
                    |m: &mut DeployOptions| { &mut m.storage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeployOptions>(
                    "DeployOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeployOptions {
        static mut instance: ::protobuf::lazy::Lazy<DeployOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeployOptions,
        };
        unsafe {
            instance.get(DeployOptions::new)
        }
    }
}

impl ::protobuf::Clear for DeployOptions {
    fn clear(&mut self) {
        self.name.clear();
        self.entrypoint.clear();
        self.podname.clear();
        self.nodename.clear();
        self.image.clear();
        self.extra_args.clear();
        self.cpu_quota = 0.;
        self.memory = 0;
        self.count = 0;
        self.env.clear();
        self.dns.clear();
        self.extra_hosts.clear();
        self.volumes.clear();
        self.networks.clear();
        self.networkmode.clear();
        self.user.clear();
        self.debug = false;
        self.openStdin = false;
        self.labels.clear();
        self.nodelabels.clear();
        self.deploy_method.clear();
        self.data.clear();
        self.soft_limit = false;
        self.nodes_limit = 0;
        self.cpu_bind = false;
        self.ignore_hook = false;
        self.after_create.clear();
        self.raw_args.clear();
        self.storage = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeployOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeployOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplaceOptions {
    // message fields
    pub deployOpt: ::protobuf::SingularPtrField<DeployOptions>,
    pub networkinherit: bool,
    pub filter_labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub copy: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplaceOptions {
    fn default() -> &'a ReplaceOptions {
        <ReplaceOptions as ::protobuf::Message>::default_instance()
    }
}

impl ReplaceOptions {
    pub fn new() -> ReplaceOptions {
        ::std::default::Default::default()
    }

    // .pb.DeployOptions deployOpt = 1;


    pub fn get_deployOpt(&self) -> &DeployOptions {
        self.deployOpt.as_ref().unwrap_or_else(|| DeployOptions::default_instance())
    }
    pub fn clear_deployOpt(&mut self) {
        self.deployOpt.clear();
    }

    pub fn has_deployOpt(&self) -> bool {
        self.deployOpt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deployOpt(&mut self, v: DeployOptions) {
        self.deployOpt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deployOpt(&mut self) -> &mut DeployOptions {
        if self.deployOpt.is_none() {
            self.deployOpt.set_default();
        }
        self.deployOpt.as_mut().unwrap()
    }

    // Take field
    pub fn take_deployOpt(&mut self) -> DeployOptions {
        self.deployOpt.take().unwrap_or_else(|| DeployOptions::new())
    }

    // bool networkinherit = 2;


    pub fn get_networkinherit(&self) -> bool {
        self.networkinherit
    }
    pub fn clear_networkinherit(&mut self) {
        self.networkinherit = false;
    }

    // Param is passed by value, moved
    pub fn set_networkinherit(&mut self, v: bool) {
        self.networkinherit = v;
    }

    // repeated .pb.ReplaceOptions.FilterLabelsEntry filter_labels = 3;


    pub fn get_filter_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.filter_labels
    }
    pub fn clear_filter_labels(&mut self) {
        self.filter_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.filter_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filter_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.filter_labels
    }

    // Take field
    pub fn take_filter_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.filter_labels, ::std::collections::HashMap::new())
    }

    // repeated .pb.ReplaceOptions.CopyEntry copy = 4;


    pub fn get_copy(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.copy
    }
    pub fn clear_copy(&mut self) {
        self.copy.clear();
    }

    // Param is passed by value, moved
    pub fn set_copy(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.copy = v;
    }

    // Mutable pointer to the field.
    pub fn mut_copy(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.copy
    }

    // Take field
    pub fn take_copy(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.copy, ::std::collections::HashMap::new())
    }

    // repeated string ids = 5;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReplaceOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.deployOpt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deployOpt)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.networkinherit = tmp;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.filter_labels)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.copy)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.deployOpt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.networkinherit != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.filter_labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.copy);
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.deployOpt.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.networkinherit != false {
            os.write_bool(2, self.networkinherit)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.filter_labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.copy, os)?;
        for v in &self.ids {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplaceOptions {
        ReplaceOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeployOptions>>(
                    "deployOpt",
                    |m: &ReplaceOptions| { &m.deployOpt },
                    |m: &mut ReplaceOptions| { &mut m.deployOpt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "networkinherit",
                    |m: &ReplaceOptions| { &m.networkinherit },
                    |m: &mut ReplaceOptions| { &mut m.networkinherit },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "filter_labels",
                    |m: &ReplaceOptions| { &m.filter_labels },
                    |m: &mut ReplaceOptions| { &mut m.filter_labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "copy",
                    |m: &ReplaceOptions| { &m.copy },
                    |m: &mut ReplaceOptions| { &mut m.copy },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &ReplaceOptions| { &m.ids },
                    |m: &mut ReplaceOptions| { &mut m.ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReplaceOptions>(
                    "ReplaceOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReplaceOptions {
        static mut instance: ::protobuf::lazy::Lazy<ReplaceOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReplaceOptions,
        };
        unsafe {
            instance.get(ReplaceOptions::new)
        }
    }
}

impl ::protobuf::Clear for ReplaceOptions {
    fn clear(&mut self) {
        self.deployOpt.clear();
        self.networkinherit = false;
        self.filter_labels.clear();
        self.copy.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplaceOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplaceOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheImageOptions {
    // message fields
    pub podname: ::std::string::String,
    pub nodename: ::std::string::String,
    pub images: ::protobuf::RepeatedField<::std::string::String>,
    pub step: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheImageOptions {
    fn default() -> &'a CacheImageOptions {
        <CacheImageOptions as ::protobuf::Message>::default_instance()
    }
}

impl CacheImageOptions {
    pub fn new() -> CacheImageOptions {
        ::std::default::Default::default()
    }

    // string podname = 1;


    pub fn get_podname(&self) -> &str {
        &self.podname
    }
    pub fn clear_podname(&mut self) {
        self.podname.clear();
    }

    // Param is passed by value, moved
    pub fn set_podname(&mut self, v: ::std::string::String) {
        self.podname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podname(&mut self) -> &mut ::std::string::String {
        &mut self.podname
    }

    // Take field
    pub fn take_podname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.podname, ::std::string::String::new())
    }

    // string nodename = 2;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // repeated string images = 3;


    pub fn get_images(&self) -> &[::std::string::String] {
        &self.images
    }
    pub fn clear_images(&mut self) {
        self.images.clear();
    }

    // Param is passed by value, moved
    pub fn set_images(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.images = v;
    }

    // Mutable pointer to the field.
    pub fn mut_images(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.images
    }

    // Take field
    pub fn take_images(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.images, ::protobuf::RepeatedField::new())
    }

    // int32 step = 4;


    pub fn get_step(&self) -> i32 {
        self.step
    }
    pub fn clear_step(&mut self) {
        self.step = 0;
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: i32) {
        self.step = v;
    }
}

impl ::protobuf::Message for CacheImageOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.podname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.images)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.step = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.podname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.podname);
        }
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.nodename);
        }
        for value in &self.images {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.step != 0 {
            my_size += ::protobuf::rt::value_size(4, self.step, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.podname.is_empty() {
            os.write_string(1, &self.podname)?;
        }
        if !self.nodename.is_empty() {
            os.write_string(2, &self.nodename)?;
        }
        for v in &self.images {
            os.write_string(3, &v)?;
        };
        if self.step != 0 {
            os.write_int32(4, self.step)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheImageOptions {
        CacheImageOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podname",
                    |m: &CacheImageOptions| { &m.podname },
                    |m: &mut CacheImageOptions| { &mut m.podname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &CacheImageOptions| { &m.nodename },
                    |m: &mut CacheImageOptions| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "images",
                    |m: &CacheImageOptions| { &m.images },
                    |m: &mut CacheImageOptions| { &mut m.images },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "step",
                    |m: &CacheImageOptions| { &m.step },
                    |m: &mut CacheImageOptions| { &mut m.step },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheImageOptions>(
                    "CacheImageOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CacheImageOptions {
        static mut instance: ::protobuf::lazy::Lazy<CacheImageOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheImageOptions,
        };
        unsafe {
            instance.get(CacheImageOptions::new)
        }
    }
}

impl ::protobuf::Clear for CacheImageOptions {
    fn clear(&mut self) {
        self.podname.clear();
        self.nodename.clear();
        self.images.clear();
        self.step = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheImageOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheImageOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveImageOptions {
    // message fields
    pub podname: ::std::string::String,
    pub nodename: ::std::string::String,
    pub images: ::protobuf::RepeatedField<::std::string::String>,
    pub step: i32,
    pub prune: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveImageOptions {
    fn default() -> &'a RemoveImageOptions {
        <RemoveImageOptions as ::protobuf::Message>::default_instance()
    }
}

impl RemoveImageOptions {
    pub fn new() -> RemoveImageOptions {
        ::std::default::Default::default()
    }

    // string podname = 1;


    pub fn get_podname(&self) -> &str {
        &self.podname
    }
    pub fn clear_podname(&mut self) {
        self.podname.clear();
    }

    // Param is passed by value, moved
    pub fn set_podname(&mut self, v: ::std::string::String) {
        self.podname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podname(&mut self) -> &mut ::std::string::String {
        &mut self.podname
    }

    // Take field
    pub fn take_podname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.podname, ::std::string::String::new())
    }

    // string nodename = 2;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // repeated string images = 3;


    pub fn get_images(&self) -> &[::std::string::String] {
        &self.images
    }
    pub fn clear_images(&mut self) {
        self.images.clear();
    }

    // Param is passed by value, moved
    pub fn set_images(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.images = v;
    }

    // Mutable pointer to the field.
    pub fn mut_images(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.images
    }

    // Take field
    pub fn take_images(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.images, ::protobuf::RepeatedField::new())
    }

    // int32 step = 4;


    pub fn get_step(&self) -> i32 {
        self.step
    }
    pub fn clear_step(&mut self) {
        self.step = 0;
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: i32) {
        self.step = v;
    }

    // bool prune = 5;


    pub fn get_prune(&self) -> bool {
        self.prune
    }
    pub fn clear_prune(&mut self) {
        self.prune = false;
    }

    // Param is passed by value, moved
    pub fn set_prune(&mut self, v: bool) {
        self.prune = v;
    }
}

impl ::protobuf::Message for RemoveImageOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.podname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.images)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.step = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prune = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.podname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.podname);
        }
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.nodename);
        }
        for value in &self.images {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.step != 0 {
            my_size += ::protobuf::rt::value_size(4, self.step, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prune != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.podname.is_empty() {
            os.write_string(1, &self.podname)?;
        }
        if !self.nodename.is_empty() {
            os.write_string(2, &self.nodename)?;
        }
        for v in &self.images {
            os.write_string(3, &v)?;
        };
        if self.step != 0 {
            os.write_int32(4, self.step)?;
        }
        if self.prune != false {
            os.write_bool(5, self.prune)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveImageOptions {
        RemoveImageOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podname",
                    |m: &RemoveImageOptions| { &m.podname },
                    |m: &mut RemoveImageOptions| { &mut m.podname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &RemoveImageOptions| { &m.nodename },
                    |m: &mut RemoveImageOptions| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "images",
                    |m: &RemoveImageOptions| { &m.images },
                    |m: &mut RemoveImageOptions| { &mut m.images },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "step",
                    |m: &RemoveImageOptions| { &m.step },
                    |m: &mut RemoveImageOptions| { &mut m.step },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prune",
                    |m: &RemoveImageOptions| { &m.prune },
                    |m: &mut RemoveImageOptions| { &mut m.prune },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveImageOptions>(
                    "RemoveImageOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveImageOptions {
        static mut instance: ::protobuf::lazy::Lazy<RemoveImageOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveImageOptions,
        };
        unsafe {
            instance.get(RemoveImageOptions::new)
        }
    }
}

impl ::protobuf::Clear for RemoveImageOptions {
    fn clear(&mut self) {
        self.podname.clear();
        self.nodename.clear();
        self.images.clear();
        self.step = 0;
        self.prune = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveImageOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveImageOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyPaths {
    // message fields
    pub paths: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyPaths {
    fn default() -> &'a CopyPaths {
        <CopyPaths as ::protobuf::Message>::default_instance()
    }
}

impl CopyPaths {
    pub fn new() -> CopyPaths {
        ::std::default::Default::default()
    }

    // repeated string paths = 1;


    pub fn get_paths(&self) -> &[::std::string::String] {
        &self.paths
    }
    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.paths, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CopyPaths {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.paths)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.paths {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.paths {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyPaths {
        CopyPaths::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "paths",
                    |m: &CopyPaths| { &m.paths },
                    |m: &mut CopyPaths| { &mut m.paths },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CopyPaths>(
                    "CopyPaths",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CopyPaths {
        static mut instance: ::protobuf::lazy::Lazy<CopyPaths> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CopyPaths,
        };
        unsafe {
            instance.get(CopyPaths::new)
        }
    }
}

impl ::protobuf::Clear for CopyPaths {
    fn clear(&mut self) {
        self.paths.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyPaths {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyPaths {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyOptions {
    // message fields
    pub targets: ::std::collections::HashMap<::std::string::String, CopyPaths>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyOptions {
    fn default() -> &'a CopyOptions {
        <CopyOptions as ::protobuf::Message>::default_instance()
    }
}

impl CopyOptions {
    pub fn new() -> CopyOptions {
        ::std::default::Default::default()
    }

    // repeated .pb.CopyOptions.TargetsEntry targets = 1;


    pub fn get_targets(&self) -> &::std::collections::HashMap<::std::string::String, CopyPaths> {
        &self.targets
    }
    pub fn clear_targets(&mut self) {
        self.targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_targets(&mut self, v: ::std::collections::HashMap<::std::string::String, CopyPaths>) {
        self.targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targets(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, CopyPaths> {
        &mut self.targets
    }

    // Take field
    pub fn take_targets(&mut self) -> ::std::collections::HashMap<::std::string::String, CopyPaths> {
        ::std::mem::replace(&mut self.targets, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for CopyOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<CopyPaths>>(wire_type, is, &mut self.targets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<CopyPaths>>(1, &self.targets);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<CopyPaths>>(1, &self.targets, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyOptions {
        CopyOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<CopyPaths>>(
                    "targets",
                    |m: &CopyOptions| { &m.targets },
                    |m: &mut CopyOptions| { &mut m.targets },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CopyOptions>(
                    "CopyOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CopyOptions {
        static mut instance: ::protobuf::lazy::Lazy<CopyOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CopyOptions,
        };
        unsafe {
            instance.get(CopyOptions::new)
        }
    }
}

impl ::protobuf::Clear for CopyOptions {
    fn clear(&mut self) {
        self.targets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendOptions {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub data: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendOptions {
    fn default() -> &'a SendOptions {
        <SendOptions as ::protobuf::Message>::default_instance()
    }
}

impl SendOptions {
    pub fn new() -> SendOptions {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.SendOptions.DataEntry data = 2;


    pub fn get_data(&self) -> &::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.data, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for SendOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(2, &self.data);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(2, &self.data, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendOptions {
        SendOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &SendOptions| { &m.ids },
                    |m: &mut SendOptions| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &SendOptions| { &m.data },
                    |m: &mut SendOptions| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendOptions>(
                    "SendOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendOptions {
        static mut instance: ::protobuf::lazy::Lazy<SendOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendOptions,
        };
        unsafe {
            instance.get(SendOptions::new)
        }
    }
}

impl ::protobuf::Clear for SendOptions {
    fn clear(&mut self) {
        self.ids.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ErrorDetail {
    // message fields
    pub code: i64,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ErrorDetail {
    fn default() -> &'a ErrorDetail {
        <ErrorDetail as ::protobuf::Message>::default_instance()
    }
}

impl ErrorDetail {
    pub fn new() -> ErrorDetail {
        ::std::default::Default::default()
    }

    // int64 code = 1;


    pub fn get_code(&self) -> i64 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i64) {
        self.code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ErrorDetail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int64(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ErrorDetail {
        ErrorDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "code",
                    |m: &ErrorDetail| { &m.code },
                    |m: &mut ErrorDetail| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &ErrorDetail| { &m.message },
                    |m: &mut ErrorDetail| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ErrorDetail>(
                    "ErrorDetail",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ErrorDetail {
        static mut instance: ::protobuf::lazy::Lazy<ErrorDetail> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ErrorDetail,
        };
        unsafe {
            instance.get(ErrorDetail::new)
        }
    }
}

impl ::protobuf::Clear for ErrorDetail {
    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ErrorDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildImageMessage {
    // message fields
    pub id: ::std::string::String,
    pub status: ::std::string::String,
    pub progress: ::std::string::String,
    pub error: ::std::string::String,
    pub stream: ::std::string::String,
    pub error_detail: ::protobuf::SingularPtrField<ErrorDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildImageMessage {
    fn default() -> &'a BuildImageMessage {
        <BuildImageMessage as ::protobuf::Message>::default_instance()
    }
}

impl BuildImageMessage {
    pub fn new() -> BuildImageMessage {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string status = 2;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }

    // string progress = 3;


    pub fn get_progress(&self) -> &str {
        &self.progress
    }
    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: ::std::string::String) {
        self.progress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut ::std::string::String {
        &mut self.progress
    }

    // Take field
    pub fn take_progress(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.progress, ::std::string::String::new())
    }

    // string error = 4;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // string stream = 5;


    pub fn get_stream(&self) -> &str {
        &self.stream
    }
    pub fn clear_stream(&mut self) {
        self.stream.clear();
    }

    // Param is passed by value, moved
    pub fn set_stream(&mut self, v: ::std::string::String) {
        self.stream = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream(&mut self) -> &mut ::std::string::String {
        &mut self.stream
    }

    // Take field
    pub fn take_stream(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stream, ::std::string::String::new())
    }

    // .pb.ErrorDetail error_detail = 6;


    pub fn get_error_detail(&self) -> &ErrorDetail {
        self.error_detail.as_ref().unwrap_or_else(|| ErrorDetail::default_instance())
    }
    pub fn clear_error_detail(&mut self) {
        self.error_detail.clear();
    }

    pub fn has_error_detail(&self) -> bool {
        self.error_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_detail(&mut self, v: ErrorDetail) {
        self.error_detail = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_detail(&mut self) -> &mut ErrorDetail {
        if self.error_detail.is_none() {
            self.error_detail.set_default();
        }
        self.error_detail.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_detail(&mut self) -> ErrorDetail {
        self.error_detail.take().unwrap_or_else(|| ErrorDetail::new())
    }
}

impl ::protobuf::Message for BuildImageMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.error_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.progress)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stream)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_detail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.status);
        }
        if !self.progress.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.progress);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.error);
        }
        if !self.stream.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.stream);
        }
        if let Some(ref v) = self.error_detail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.status.is_empty() {
            os.write_string(2, &self.status)?;
        }
        if !self.progress.is_empty() {
            os.write_string(3, &self.progress)?;
        }
        if !self.error.is_empty() {
            os.write_string(4, &self.error)?;
        }
        if !self.stream.is_empty() {
            os.write_string(5, &self.stream)?;
        }
        if let Some(ref v) = self.error_detail.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildImageMessage {
        BuildImageMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &BuildImageMessage| { &m.id },
                    |m: &mut BuildImageMessage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "status",
                    |m: &BuildImageMessage| { &m.status },
                    |m: &mut BuildImageMessage| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "progress",
                    |m: &BuildImageMessage| { &m.progress },
                    |m: &mut BuildImageMessage| { &mut m.progress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &BuildImageMessage| { &m.error },
                    |m: &mut BuildImageMessage| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "stream",
                    |m: &BuildImageMessage| { &m.stream },
                    |m: &mut BuildImageMessage| { &mut m.stream },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ErrorDetail>>(
                    "error_detail",
                    |m: &BuildImageMessage| { &m.error_detail },
                    |m: &mut BuildImageMessage| { &mut m.error_detail },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BuildImageMessage>(
                    "BuildImageMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BuildImageMessage {
        static mut instance: ::protobuf::lazy::Lazy<BuildImageMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BuildImageMessage,
        };
        unsafe {
            instance.get(BuildImageMessage::new)
        }
    }
}

impl ::protobuf::Clear for BuildImageMessage {
    fn clear(&mut self) {
        self.id.clear();
        self.status.clear();
        self.progress.clear();
        self.error.clear();
        self.stream.clear();
        self.error_detail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildImageMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildImageMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateContainerMessage {
    // message fields
    pub podname: ::std::string::String,
    pub nodename: ::std::string::String,
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub error: ::std::string::String,
    pub success: bool,
    pub cpu: ::std::collections::HashMap<::std::string::String, i32>,
    pub quota: f64,
    pub memory: i64,
    pub publish: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub hook: ::std::vec::Vec<u8>,
    pub storage: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateContainerMessage {
    fn default() -> &'a CreateContainerMessage {
        <CreateContainerMessage as ::protobuf::Message>::default_instance()
    }
}

impl CreateContainerMessage {
    pub fn new() -> CreateContainerMessage {
        ::std::default::Default::default()
    }

    // string podname = 1;


    pub fn get_podname(&self) -> &str {
        &self.podname
    }
    pub fn clear_podname(&mut self) {
        self.podname.clear();
    }

    // Param is passed by value, moved
    pub fn set_podname(&mut self, v: ::std::string::String) {
        self.podname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podname(&mut self) -> &mut ::std::string::String {
        &mut self.podname
    }

    // Take field
    pub fn take_podname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.podname, ::std::string::String::new())
    }

    // string nodename = 2;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // string id = 3;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string error = 5;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // bool success = 6;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // repeated .pb.CreateContainerMessage.CpuEntry cpu = 7;


    pub fn get_cpu(&self) -> &::std::collections::HashMap<::std::string::String, i32> {
        &self.cpu
    }
    pub fn clear_cpu(&mut self) {
        self.cpu.clear();
    }

    // Param is passed by value, moved
    pub fn set_cpu(&mut self, v: ::std::collections::HashMap<::std::string::String, i32>) {
        self.cpu = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cpu(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i32> {
        &mut self.cpu
    }

    // Take field
    pub fn take_cpu(&mut self) -> ::std::collections::HashMap<::std::string::String, i32> {
        ::std::mem::replace(&mut self.cpu, ::std::collections::HashMap::new())
    }

    // double quota = 8;


    pub fn get_quota(&self) -> f64 {
        self.quota
    }
    pub fn clear_quota(&mut self) {
        self.quota = 0.;
    }

    // Param is passed by value, moved
    pub fn set_quota(&mut self, v: f64) {
        self.quota = v;
    }

    // int64 memory = 9;


    pub fn get_memory(&self) -> i64 {
        self.memory
    }
    pub fn clear_memory(&mut self) {
        self.memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: i64) {
        self.memory = v;
    }

    // repeated .pb.CreateContainerMessage.PublishEntry publish = 10;


    pub fn get_publish(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.publish
    }
    pub fn clear_publish(&mut self) {
        self.publish.clear();
    }

    // Param is passed by value, moved
    pub fn set_publish(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.publish = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publish(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.publish
    }

    // Take field
    pub fn take_publish(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.publish, ::std::collections::HashMap::new())
    }

    // bytes hook = 11;


    pub fn get_hook(&self) -> &[u8] {
        &self.hook
    }
    pub fn clear_hook(&mut self) {
        self.hook.clear();
    }

    // Param is passed by value, moved
    pub fn set_hook(&mut self, v: ::std::vec::Vec<u8>) {
        self.hook = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hook(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hook
    }

    // Take field
    pub fn take_hook(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hook, ::std::vec::Vec::new())
    }

    // int64 storage = 12;


    pub fn get_storage(&self) -> i64 {
        self.storage
    }
    pub fn clear_storage(&mut self) {
        self.storage = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: i64) {
        self.storage = v;
    }
}

impl ::protobuf::Message for CreateContainerMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.podname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.cpu)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.quota = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory = tmp;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.publish)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hook)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.podname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.podname);
        }
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.nodename);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.error);
        }
        if self.success != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(7, &self.cpu);
        if self.quota != 0. {
            my_size += 9;
        }
        if self.memory != 0 {
            my_size += ::protobuf::rt::value_size(9, self.memory, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.publish);
        if !self.hook.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.hook);
        }
        if self.storage != 0 {
            my_size += ::protobuf::rt::value_size(12, self.storage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.podname.is_empty() {
            os.write_string(1, &self.podname)?;
        }
        if !self.nodename.is_empty() {
            os.write_string(2, &self.nodename)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.error.is_empty() {
            os.write_string(5, &self.error)?;
        }
        if self.success != false {
            os.write_bool(6, self.success)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(7, &self.cpu, os)?;
        if self.quota != 0. {
            os.write_double(8, self.quota)?;
        }
        if self.memory != 0 {
            os.write_int64(9, self.memory)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.publish, os)?;
        if !self.hook.is_empty() {
            os.write_bytes(11, &self.hook)?;
        }
        if self.storage != 0 {
            os.write_int64(12, self.storage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateContainerMessage {
        CreateContainerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podname",
                    |m: &CreateContainerMessage| { &m.podname },
                    |m: &mut CreateContainerMessage| { &mut m.podname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &CreateContainerMessage| { &m.nodename },
                    |m: &mut CreateContainerMessage| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &CreateContainerMessage| { &m.id },
                    |m: &mut CreateContainerMessage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CreateContainerMessage| { &m.name },
                    |m: &mut CreateContainerMessage| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &CreateContainerMessage| { &m.error },
                    |m: &mut CreateContainerMessage| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &CreateContainerMessage| { &m.success },
                    |m: &mut CreateContainerMessage| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(
                    "cpu",
                    |m: &CreateContainerMessage| { &m.cpu },
                    |m: &mut CreateContainerMessage| { &mut m.cpu },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "quota",
                    |m: &CreateContainerMessage| { &m.quota },
                    |m: &mut CreateContainerMessage| { &mut m.quota },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "memory",
                    |m: &CreateContainerMessage| { &m.memory },
                    |m: &mut CreateContainerMessage| { &mut m.memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "publish",
                    |m: &CreateContainerMessage| { &m.publish },
                    |m: &mut CreateContainerMessage| { &mut m.publish },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hook",
                    |m: &CreateContainerMessage| { &m.hook },
                    |m: &mut CreateContainerMessage| { &mut m.hook },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "storage",
                    |m: &CreateContainerMessage| { &m.storage },
                    |m: &mut CreateContainerMessage| { &mut m.storage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateContainerMessage>(
                    "CreateContainerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateContainerMessage {
        static mut instance: ::protobuf::lazy::Lazy<CreateContainerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateContainerMessage,
        };
        unsafe {
            instance.get(CreateContainerMessage::new)
        }
    }
}

impl ::protobuf::Clear for CreateContainerMessage {
    fn clear(&mut self) {
        self.podname.clear();
        self.nodename.clear();
        self.id.clear();
        self.name.clear();
        self.error.clear();
        self.success = false;
        self.cpu.clear();
        self.quota = 0.;
        self.memory = 0;
        self.publish.clear();
        self.hook.clear();
        self.storage = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateContainerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateContainerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplaceContainerMessage {
    // message fields
    pub create: ::protobuf::SingularPtrField<CreateContainerMessage>,
    pub remove: ::protobuf::SingularPtrField<RemoveContainerMessage>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplaceContainerMessage {
    fn default() -> &'a ReplaceContainerMessage {
        <ReplaceContainerMessage as ::protobuf::Message>::default_instance()
    }
}

impl ReplaceContainerMessage {
    pub fn new() -> ReplaceContainerMessage {
        ::std::default::Default::default()
    }

    // .pb.CreateContainerMessage create = 1;


    pub fn get_create(&self) -> &CreateContainerMessage {
        self.create.as_ref().unwrap_or_else(|| CreateContainerMessage::default_instance())
    }
    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: CreateContainerMessage) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create(&mut self) -> &mut CreateContainerMessage {
        if self.create.is_none() {
            self.create.set_default();
        }
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> CreateContainerMessage {
        self.create.take().unwrap_or_else(|| CreateContainerMessage::new())
    }

    // .pb.RemoveContainerMessage remove = 2;


    pub fn get_remove(&self) -> &RemoveContainerMessage {
        self.remove.as_ref().unwrap_or_else(|| RemoveContainerMessage::default_instance())
    }
    pub fn clear_remove(&mut self) {
        self.remove.clear();
    }

    pub fn has_remove(&self) -> bool {
        self.remove.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove(&mut self, v: RemoveContainerMessage) {
        self.remove = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remove(&mut self) -> &mut RemoveContainerMessage {
        if self.remove.is_none() {
            self.remove.set_default();
        }
        self.remove.as_mut().unwrap()
    }

    // Take field
    pub fn take_remove(&mut self) -> RemoveContainerMessage {
        self.remove.take().unwrap_or_else(|| RemoveContainerMessage::new())
    }

    // string error = 3;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReplaceContainerMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.create {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remove {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remove)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.create.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.remove.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.create.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.remove.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(3, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplaceContainerMessage {
        ReplaceContainerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateContainerMessage>>(
                    "create",
                    |m: &ReplaceContainerMessage| { &m.create },
                    |m: &mut ReplaceContainerMessage| { &mut m.create },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoveContainerMessage>>(
                    "remove",
                    |m: &ReplaceContainerMessage| { &m.remove },
                    |m: &mut ReplaceContainerMessage| { &mut m.remove },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &ReplaceContainerMessage| { &m.error },
                    |m: &mut ReplaceContainerMessage| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReplaceContainerMessage>(
                    "ReplaceContainerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReplaceContainerMessage {
        static mut instance: ::protobuf::lazy::Lazy<ReplaceContainerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReplaceContainerMessage,
        };
        unsafe {
            instance.get(ReplaceContainerMessage::new)
        }
    }
}

impl ::protobuf::Clear for ReplaceContainerMessage {
    fn clear(&mut self) {
        self.create.clear();
        self.remove.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplaceContainerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplaceContainerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheImageMessage {
    // message fields
    pub image: ::std::string::String,
    pub success: bool,
    pub nodename: ::std::string::String,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheImageMessage {
    fn default() -> &'a CacheImageMessage {
        <CacheImageMessage as ::protobuf::Message>::default_instance()
    }
}

impl CacheImageMessage {
    pub fn new() -> CacheImageMessage {
        ::std::default::Default::default()
    }

    // string image = 1;


    pub fn get_image(&self) -> &str {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image, ::std::string::String::new())
    }

    // bool success = 2;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string nodename = 3;


    pub fn get_nodename(&self) -> &str {
        &self.nodename
    }
    pub fn clear_nodename(&mut self) {
        self.nodename.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodename(&mut self, v: ::std::string::String) {
        self.nodename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodename(&mut self) -> &mut ::std::string::String {
        &mut self.nodename
    }

    // Take field
    pub fn take_nodename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodename, ::std::string::String::new())
    }

    // string message = 4;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CacheImageMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodename)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.image);
        }
        if self.success != false {
            my_size += 2;
        }
        if !self.nodename.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.nodename);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.image.is_empty() {
            os.write_string(1, &self.image)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        if !self.nodename.is_empty() {
            os.write_string(3, &self.nodename)?;
        }
        if !self.message.is_empty() {
            os.write_string(4, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheImageMessage {
        CacheImageMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image",
                    |m: &CacheImageMessage| { &m.image },
                    |m: &mut CacheImageMessage| { &mut m.image },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &CacheImageMessage| { &m.success },
                    |m: &mut CacheImageMessage| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodename",
                    |m: &CacheImageMessage| { &m.nodename },
                    |m: &mut CacheImageMessage| { &mut m.nodename },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CacheImageMessage| { &m.message },
                    |m: &mut CacheImageMessage| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheImageMessage>(
                    "CacheImageMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CacheImageMessage {
        static mut instance: ::protobuf::lazy::Lazy<CacheImageMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheImageMessage,
        };
        unsafe {
            instance.get(CacheImageMessage::new)
        }
    }
}

impl ::protobuf::Clear for CacheImageMessage {
    fn clear(&mut self) {
        self.image.clear();
        self.success = false;
        self.nodename.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheImageMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheImageMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveImageMessage {
    // message fields
    pub image: ::std::string::String,
    pub success: bool,
    pub messages: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveImageMessage {
    fn default() -> &'a RemoveImageMessage {
        <RemoveImageMessage as ::protobuf::Message>::default_instance()
    }
}

impl RemoveImageMessage {
    pub fn new() -> RemoveImageMessage {
        ::std::default::Default::default()
    }

    // string image = 1;


    pub fn get_image(&self) -> &str {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image, ::std::string::String::new())
    }

    // bool success = 2;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // repeated string messages = 3;


    pub fn get_messages(&self) -> &[::std::string::String] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RemoveImageMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.image);
        }
        if self.success != false {
            my_size += 2;
        }
        for value in &self.messages {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.image.is_empty() {
            os.write_string(1, &self.image)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        for v in &self.messages {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveImageMessage {
        RemoveImageMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image",
                    |m: &RemoveImageMessage| { &m.image },
                    |m: &mut RemoveImageMessage| { &mut m.image },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &RemoveImageMessage| { &m.success },
                    |m: &mut RemoveImageMessage| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "messages",
                    |m: &RemoveImageMessage| { &m.messages },
                    |m: &mut RemoveImageMessage| { &mut m.messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveImageMessage>(
                    "RemoveImageMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveImageMessage {
        static mut instance: ::protobuf::lazy::Lazy<RemoveImageMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveImageMessage,
        };
        unsafe {
            instance.get(RemoveImageMessage::new)
        }
    }
}

impl ::protobuf::Clear for RemoveImageMessage {
    fn clear(&mut self) {
        self.image.clear();
        self.success = false;
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveImageMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveImageMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveContainerMessage {
    // message fields
    pub id: ::std::string::String,
    pub success: bool,
    pub hook: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveContainerMessage {
    fn default() -> &'a RemoveContainerMessage {
        <RemoveContainerMessage as ::protobuf::Message>::default_instance()
    }
}

impl RemoveContainerMessage {
    pub fn new() -> RemoveContainerMessage {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bool success = 2;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string hook = 3;


    pub fn get_hook(&self) -> &str {
        &self.hook
    }
    pub fn clear_hook(&mut self) {
        self.hook.clear();
    }

    // Param is passed by value, moved
    pub fn set_hook(&mut self, v: ::std::string::String) {
        self.hook = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hook(&mut self) -> &mut ::std::string::String {
        &mut self.hook
    }

    // Take field
    pub fn take_hook(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hook, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoveContainerMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hook)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.success != false {
            my_size += 2;
        }
        if !self.hook.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.hook);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        if !self.hook.is_empty() {
            os.write_string(3, &self.hook)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveContainerMessage {
        RemoveContainerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &RemoveContainerMessage| { &m.id },
                    |m: &mut RemoveContainerMessage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &RemoveContainerMessage| { &m.success },
                    |m: &mut RemoveContainerMessage| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hook",
                    |m: &RemoveContainerMessage| { &m.hook },
                    |m: &mut RemoveContainerMessage| { &mut m.hook },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveContainerMessage>(
                    "RemoveContainerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveContainerMessage {
        static mut instance: ::protobuf::lazy::Lazy<RemoveContainerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveContainerMessage,
        };
        unsafe {
            instance.get(RemoveContainerMessage::new)
        }
    }
}

impl ::protobuf::Clear for RemoveContainerMessage {
    fn clear(&mut self) {
        self.id.clear();
        self.success = false;
        self.hook.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveContainerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveContainerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DissociateContainerMessage {
    // message fields
    pub id: ::std::string::String,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DissociateContainerMessage {
    fn default() -> &'a DissociateContainerMessage {
        <DissociateContainerMessage as ::protobuf::Message>::default_instance()
    }
}

impl DissociateContainerMessage {
    pub fn new() -> DissociateContainerMessage {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DissociateContainerMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DissociateContainerMessage {
        DissociateContainerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &DissociateContainerMessage| { &m.id },
                    |m: &mut DissociateContainerMessage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &DissociateContainerMessage| { &m.error },
                    |m: &mut DissociateContainerMessage| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DissociateContainerMessage>(
                    "DissociateContainerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DissociateContainerMessage {
        static mut instance: ::protobuf::lazy::Lazy<DissociateContainerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DissociateContainerMessage,
        };
        unsafe {
            instance.get(DissociateContainerMessage::new)
        }
    }
}

impl ::protobuf::Clear for DissociateContainerMessage {
    fn clear(&mut self) {
        self.id.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DissociateContainerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DissociateContainerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReallocResourceMessage {
    // message fields
    pub id: ::std::string::String,
    pub success: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReallocResourceMessage {
    fn default() -> &'a ReallocResourceMessage {
        <ReallocResourceMessage as ::protobuf::Message>::default_instance()
    }
}

impl ReallocResourceMessage {
    pub fn new() -> ReallocResourceMessage {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bool success = 2;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }
}

impl ::protobuf::Message for ReallocResourceMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.success != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReallocResourceMessage {
        ReallocResourceMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &ReallocResourceMessage| { &m.id },
                    |m: &mut ReallocResourceMessage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &ReallocResourceMessage| { &m.success },
                    |m: &mut ReallocResourceMessage| { &mut m.success },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReallocResourceMessage>(
                    "ReallocResourceMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReallocResourceMessage {
        static mut instance: ::protobuf::lazy::Lazy<ReallocResourceMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReallocResourceMessage,
        };
        unsafe {
            instance.get(ReallocResourceMessage::new)
        }
    }
}

impl ::protobuf::Clear for ReallocResourceMessage {
    fn clear(&mut self) {
        self.id.clear();
        self.success = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReallocResourceMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReallocResourceMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyMessage {
    // message fields
    pub id: ::std::string::String,
    pub status: ::std::string::String,
    pub name: ::std::string::String,
    pub path: ::std::string::String,
    pub error: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyMessage {
    fn default() -> &'a CopyMessage {
        <CopyMessage as ::protobuf::Message>::default_instance()
    }
}

impl CopyMessage {
    pub fn new() -> CopyMessage {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string status = 2;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string path = 4;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string error = 5;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // bytes data = 6;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CopyMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.status);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.path);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.error);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.status.is_empty() {
            os.write_string(2, &self.status)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.path.is_empty() {
            os.write_string(4, &self.path)?;
        }
        if !self.error.is_empty() {
            os.write_string(5, &self.error)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(6, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyMessage {
        CopyMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &CopyMessage| { &m.id },
                    |m: &mut CopyMessage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "status",
                    |m: &CopyMessage| { &m.status },
                    |m: &mut CopyMessage| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CopyMessage| { &m.name },
                    |m: &mut CopyMessage| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &CopyMessage| { &m.path },
                    |m: &mut CopyMessage| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &CopyMessage| { &m.error },
                    |m: &mut CopyMessage| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &CopyMessage| { &m.data },
                    |m: &mut CopyMessage| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CopyMessage>(
                    "CopyMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CopyMessage {
        static mut instance: ::protobuf::lazy::Lazy<CopyMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CopyMessage,
        };
        unsafe {
            instance.get(CopyMessage::new)
        }
    }
}

impl ::protobuf::Clear for CopyMessage {
    fn clear(&mut self) {
        self.id.clear();
        self.status.clear();
        self.name.clear();
        self.path.clear();
        self.error.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendMessage {
    // message fields
    pub id: ::std::string::String,
    pub path: ::std::string::String,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendMessage {
    fn default() -> &'a SendMessage {
        <SendMessage as ::protobuf::Message>::default_instance()
    }
}

impl SendMessage {
    pub fn new() -> SendMessage {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string path = 2;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string error = 3;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if !self.error.is_empty() {
            os.write_string(3, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendMessage {
        SendMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &SendMessage| { &m.id },
                    |m: &mut SendMessage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &SendMessage| { &m.path },
                    |m: &mut SendMessage| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &SendMessage| { &m.error },
                    |m: &mut SendMessage| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendMessage>(
                    "SendMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendMessage {
        static mut instance: ::protobuf::lazy::Lazy<SendMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendMessage,
        };
        unsafe {
            instance.get(SendMessage::new)
        }
    }
}

impl ::protobuf::Clear for SendMessage {
    fn clear(&mut self) {
        self.id.clear();
        self.path.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttachContainerMessage {
    // message fields
    pub container_id: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttachContainerMessage {
    fn default() -> &'a AttachContainerMessage {
        <AttachContainerMessage as ::protobuf::Message>::default_instance()
    }
}

impl AttachContainerMessage {
    pub fn new() -> AttachContainerMessage {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AttachContainerMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttachContainerMessage {
        AttachContainerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &AttachContainerMessage| { &m.container_id },
                    |m: &mut AttachContainerMessage| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &AttachContainerMessage| { &m.data },
                    |m: &mut AttachContainerMessage| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttachContainerMessage>(
                    "AttachContainerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttachContainerMessage {
        static mut instance: ::protobuf::lazy::Lazy<AttachContainerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttachContainerMessage,
        };
        unsafe {
            instance.get(AttachContainerMessage::new)
        }
    }
}

impl ::protobuf::Clear for AttachContainerMessage {
    fn clear(&mut self) {
        self.container_id.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttachContainerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachContainerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunAndWaitOptions {
    // message fields
    pub deploy_options: ::protobuf::SingularPtrField<DeployOptions>,
    pub cmd: ::std::vec::Vec<u8>,
    pub r#async: bool,
    pub async_timeout: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RunAndWaitOptions {
    fn default() -> &'a RunAndWaitOptions {
        <RunAndWaitOptions as ::protobuf::Message>::default_instance()
    }
}

impl RunAndWaitOptions {
    pub fn new() -> RunAndWaitOptions {
        ::std::default::Default::default()
    }

    // .pb.DeployOptions deploy_options = 1;


    pub fn get_deploy_options(&self) -> &DeployOptions {
        self.deploy_options.as_ref().unwrap_or_else(|| DeployOptions::default_instance())
    }
    pub fn clear_deploy_options(&mut self) {
        self.deploy_options.clear();
    }

    pub fn has_deploy_options(&self) -> bool {
        self.deploy_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deploy_options(&mut self, v: DeployOptions) {
        self.deploy_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deploy_options(&mut self) -> &mut DeployOptions {
        if self.deploy_options.is_none() {
            self.deploy_options.set_default();
        }
        self.deploy_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_deploy_options(&mut self) -> DeployOptions {
        self.deploy_options.take().unwrap_or_else(|| DeployOptions::new())
    }

    // bytes cmd = 2;


    pub fn get_cmd(&self) -> &[u8] {
        &self.cmd
    }
    pub fn clear_cmd(&mut self) {
        self.cmd.clear();
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: ::std::vec::Vec<u8>) {
        self.cmd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmd(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.cmd
    }

    // Take field
    pub fn take_cmd(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.cmd, ::std::vec::Vec::new())
    }

    // bool r#async = 3;


    pub fn get_async(&self) -> bool {
        self.r#async
    }
    pub fn clear_async(&mut self) {
        self.r#async = false;
    }

    // Param is passed by value, moved
    pub fn set_async(&mut self, v: bool) {
        self.r#async = v;
    }

    // int32 async_timeout = 4;


    pub fn get_async_timeout(&self) -> i32 {
        self.async_timeout
    }
    pub fn clear_async_timeout(&mut self) {
        self.async_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_async_timeout(&mut self, v: i32) {
        self.async_timeout = v;
    }
}

impl ::protobuf::Message for RunAndWaitOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.deploy_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deploy_options)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.cmd)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.r#async = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.async_timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.deploy_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cmd.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.cmd);
        }
        if self.r#async != false {
            my_size += 2;
        }
        if self.async_timeout != 0 {
            my_size += ::protobuf::rt::value_size(4, self.async_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.deploy_options.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cmd.is_empty() {
            os.write_bytes(2, &self.cmd)?;
        }
        if self.r#async != false {
            os.write_bool(3, self.r#async)?;
        }
        if self.async_timeout != 0 {
            os.write_int32(4, self.async_timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunAndWaitOptions {
        RunAndWaitOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeployOptions>>(
                    "deploy_options",
                    |m: &RunAndWaitOptions| { &m.deploy_options },
                    |m: &mut RunAndWaitOptions| { &mut m.deploy_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "cmd",
                    |m: &RunAndWaitOptions| { &m.cmd },
                    |m: &mut RunAndWaitOptions| { &mut m.cmd },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "r#async",
                    |m: &RunAndWaitOptions| { &m.r#async },
                    |m: &mut RunAndWaitOptions| { &mut m.r#async },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "async_timeout",
                    |m: &RunAndWaitOptions| { &m.async_timeout },
                    |m: &mut RunAndWaitOptions| { &mut m.async_timeout },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RunAndWaitOptions>(
                    "RunAndWaitOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RunAndWaitOptions {
        static mut instance: ::protobuf::lazy::Lazy<RunAndWaitOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RunAndWaitOptions,
        };
        unsafe {
            instance.get(RunAndWaitOptions::new)
        }
    }
}

impl ::protobuf::Clear for RunAndWaitOptions {
    fn clear(&mut self) {
        self.deploy_options.clear();
        self.cmd.clear();
        self.r#async = false;
        self.async_timeout = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunAndWaitOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunAndWaitOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ControlContainerOptions {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub field_type: ::std::string::String,
    pub force: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlContainerOptions {
    fn default() -> &'a ControlContainerOptions {
        <ControlContainerOptions as ::protobuf::Message>::default_instance()
    }
}

impl ControlContainerOptions {
    pub fn new() -> ControlContainerOptions {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // string type = 2;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // bool force = 3;


    pub fn get_force(&self) -> bool {
        self.force
    }
    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }
}

impl ::protobuf::Message for ControlContainerOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if self.force != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if self.force != false {
            os.write_bool(3, self.force)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlContainerOptions {
        ControlContainerOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &ControlContainerOptions| { &m.ids },
                    |m: &mut ControlContainerOptions| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &ControlContainerOptions| { &m.field_type },
                    |m: &mut ControlContainerOptions| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "force",
                    |m: &ControlContainerOptions| { &m.force },
                    |m: &mut ControlContainerOptions| { &mut m.force },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ControlContainerOptions>(
                    "ControlContainerOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ControlContainerOptions {
        static mut instance: ::protobuf::lazy::Lazy<ControlContainerOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ControlContainerOptions,
        };
        unsafe {
            instance.get(ControlContainerOptions::new)
        }
    }
}

impl ::protobuf::Clear for ControlContainerOptions {
    fn clear(&mut self) {
        self.ids.clear();
        self.field_type.clear();
        self.force = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlContainerOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlContainerOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ControlContainerMessage {
    // message fields
    pub id: ::std::string::String,
    pub error: ::std::string::String,
    pub hook: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlContainerMessage {
    fn default() -> &'a ControlContainerMessage {
        <ControlContainerMessage as ::protobuf::Message>::default_instance()
    }
}

impl ControlContainerMessage {
    pub fn new() -> ControlContainerMessage {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // bytes hook = 3;


    pub fn get_hook(&self) -> &[u8] {
        &self.hook
    }
    pub fn clear_hook(&mut self) {
        self.hook.clear();
    }

    // Param is passed by value, moved
    pub fn set_hook(&mut self, v: ::std::vec::Vec<u8>) {
        self.hook = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hook(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hook
    }

    // Take field
    pub fn take_hook(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hook, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ControlContainerMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hook)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if !self.hook.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.hook);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if !self.hook.is_empty() {
            os.write_bytes(3, &self.hook)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlContainerMessage {
        ControlContainerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &ControlContainerMessage| { &m.id },
                    |m: &mut ControlContainerMessage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &ControlContainerMessage| { &m.error },
                    |m: &mut ControlContainerMessage| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hook",
                    |m: &ControlContainerMessage| { &m.hook },
                    |m: &mut ControlContainerMessage| { &mut m.hook },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ControlContainerMessage>(
                    "ControlContainerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ControlContainerMessage {
        static mut instance: ::protobuf::lazy::Lazy<ControlContainerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ControlContainerMessage,
        };
        unsafe {
            instance.get(ControlContainerMessage::new)
        }
    }
}

impl ::protobuf::Clear for ControlContainerMessage {
    fn clear(&mut self) {
        self.id.clear();
        self.error.clear();
        self.hook.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlContainerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlContainerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogStreamMessage {
    // message fields
    pub id: ::std::string::String,
    pub error: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogStreamMessage {
    fn default() -> &'a LogStreamMessage {
        <LogStreamMessage as ::protobuf::Message>::default_instance()
    }
}

impl LogStreamMessage {
    pub fn new() -> LogStreamMessage {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for LogStreamMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogStreamMessage {
        LogStreamMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &LogStreamMessage| { &m.id },
                    |m: &mut LogStreamMessage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &LogStreamMessage| { &m.error },
                    |m: &mut LogStreamMessage| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &LogStreamMessage| { &m.data },
                    |m: &mut LogStreamMessage| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LogStreamMessage>(
                    "LogStreamMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LogStreamMessage {
        static mut instance: ::protobuf::lazy::Lazy<LogStreamMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LogStreamMessage,
        };
        unsafe {
            instance.get(LogStreamMessage::new)
        }
    }
}

impl ::protobuf::Clear for LogStreamMessage {
    fn clear(&mut self) {
        self.id.clear();
        self.error.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogStreamMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogStreamMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteContainerOptions {
    // message fields
    pub container_id: ::std::string::String,
    pub commands: ::protobuf::RepeatedField<::std::string::String>,
    pub envs: ::protobuf::RepeatedField<::std::string::String>,
    pub workdir: ::std::string::String,
    pub open_stdin: bool,
    pub repl_cmd: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteContainerOptions {
    fn default() -> &'a ExecuteContainerOptions {
        <ExecuteContainerOptions as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteContainerOptions {
    pub fn new() -> ExecuteContainerOptions {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // repeated string commands = 2;


    pub fn get_commands(&self) -> &[::std::string::String] {
        &self.commands
    }
    pub fn clear_commands(&mut self) {
        self.commands.clear();
    }

    // Param is passed by value, moved
    pub fn set_commands(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.commands = v;
    }

    // Mutable pointer to the field.
    pub fn mut_commands(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.commands
    }

    // Take field
    pub fn take_commands(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.commands, ::protobuf::RepeatedField::new())
    }

    // repeated string envs = 3;


    pub fn get_envs(&self) -> &[::std::string::String] {
        &self.envs
    }
    pub fn clear_envs(&mut self) {
        self.envs.clear();
    }

    // Param is passed by value, moved
    pub fn set_envs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.envs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_envs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.envs
    }

    // Take field
    pub fn take_envs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.envs, ::protobuf::RepeatedField::new())
    }

    // string workdir = 4;


    pub fn get_workdir(&self) -> &str {
        &self.workdir
    }
    pub fn clear_workdir(&mut self) {
        self.workdir.clear();
    }

    // Param is passed by value, moved
    pub fn set_workdir(&mut self, v: ::std::string::String) {
        self.workdir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workdir(&mut self) -> &mut ::std::string::String {
        &mut self.workdir
    }

    // Take field
    pub fn take_workdir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workdir, ::std::string::String::new())
    }

    // bool open_stdin = 5;


    pub fn get_open_stdin(&self) -> bool {
        self.open_stdin
    }
    pub fn clear_open_stdin(&mut self) {
        self.open_stdin = false;
    }

    // Param is passed by value, moved
    pub fn set_open_stdin(&mut self, v: bool) {
        self.open_stdin = v;
    }

    // bytes repl_cmd = 6;


    pub fn get_repl_cmd(&self) -> &[u8] {
        &self.repl_cmd
    }
    pub fn clear_repl_cmd(&mut self) {
        self.repl_cmd.clear();
    }

    // Param is passed by value, moved
    pub fn set_repl_cmd(&mut self, v: ::std::vec::Vec<u8>) {
        self.repl_cmd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_repl_cmd(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.repl_cmd
    }

    // Take field
    pub fn take_repl_cmd(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.repl_cmd, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ExecuteContainerOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.commands)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.envs)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workdir)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.open_stdin = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.repl_cmd)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        for value in &self.commands {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.envs {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.workdir.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.workdir);
        }
        if self.open_stdin != false {
            my_size += 2;
        }
        if !self.repl_cmd.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.repl_cmd);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        for v in &self.commands {
            os.write_string(2, &v)?;
        };
        for v in &self.envs {
            os.write_string(3, &v)?;
        };
        if !self.workdir.is_empty() {
            os.write_string(4, &self.workdir)?;
        }
        if self.open_stdin != false {
            os.write_bool(5, self.open_stdin)?;
        }
        if !self.repl_cmd.is_empty() {
            os.write_bytes(6, &self.repl_cmd)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteContainerOptions {
        ExecuteContainerOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container_id",
                    |m: &ExecuteContainerOptions| { &m.container_id },
                    |m: &mut ExecuteContainerOptions| { &mut m.container_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "commands",
                    |m: &ExecuteContainerOptions| { &m.commands },
                    |m: &mut ExecuteContainerOptions| { &mut m.commands },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "envs",
                    |m: &ExecuteContainerOptions| { &m.envs },
                    |m: &mut ExecuteContainerOptions| { &mut m.envs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "workdir",
                    |m: &ExecuteContainerOptions| { &m.workdir },
                    |m: &mut ExecuteContainerOptions| { &mut m.workdir },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "open_stdin",
                    |m: &ExecuteContainerOptions| { &m.open_stdin },
                    |m: &mut ExecuteContainerOptions| { &mut m.open_stdin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "repl_cmd",
                    |m: &ExecuteContainerOptions| { &m.repl_cmd },
                    |m: &mut ExecuteContainerOptions| { &mut m.repl_cmd },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecuteContainerOptions>(
                    "ExecuteContainerOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteContainerOptions {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteContainerOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecuteContainerOptions,
        };
        unsafe {
            instance.get(ExecuteContainerOptions::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteContainerOptions {
    fn clear(&mut self) {
        self.container_id.clear();
        self.commands.clear();
        self.envs.clear();
        self.workdir.clear();
        self.open_stdin = false;
        self.repl_cmd.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteContainerOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteContainerOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\ncore.proto\x12\x02pb\"\x07\n\x05Empty\"\xfd\x01\n\x15ListContainersO\
    ptions\x12\x18\n\x07appname\x18\x01\x20\x01(\tR\x07appname\x12\x1e\n\nen\
    trypoint\x18\x02\x20\x01(\tR\nentrypoint\x12\x1a\n\x08nodename\x18\x03\
    \x20\x01(\tR\x08nodename\x12=\n\x06labels\x18\x04\x20\x03(\x0b2%.pb.List\
    ContainersOptions.LabelsEntryR\x06labels\x12\x14\n\x05limit\x18\x05\x20\
    \x01(\x03R\x05limit\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"-\n\x03Pod\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\
    \x04desc\x18\x02\x20\x01(\tR\x04desc\"#\n\x04Pods\x12\x1b\n\x04pods\x18\
    \x01\x20\x03(\x0b2\x07.pb.PodR\x04pods\"\xcc\x05\n\x0bPodResource\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12C\n\x0ccpu_percents\x18\
    \x02\x20\x03(\x0b2\x20.pb.PodResource.CpuPercentsEntryR\x0bcpuPercents\
    \x12L\n\x0fmemory_percents\x18\x03\x20\x03(\x0b2#.pb.PodResource.MemoryP\
    ercentsEntryR\x0ememoryPercents\x12H\n\rverifications\x18\x04\x20\x03(\
    \x0b2\".pb.PodResource.VerificationsEntryR\rverifications\x126\n\x07deta\
    ils\x18\x05\x20\x03(\x0b2\x1c.pb.PodResource.DetailsEntryR\x07details\
    \x12O\n\x10storage_percents\x18\x06\x20\x03(\x0b2$.pb.PodResource.Storag\
    ePercentsEntryR\x0fstoragePercents\x1a>\n\x10CpuPercentsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x01R\x05value:\x028\x01\x1aA\n\x13MemoryPercentsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05\
    value:\x028\x01\x1a@\n\x12VerificationsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x08R\x05value:\
    \x028\x01\x1a:\n\x0cDetailsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aB\n\
    \x14StoragePercentsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\x01R\x05value:\x028\x01\"\xd1\x01\n\x0c\
    NodeResource\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1f\n\x0b\
    cpu_percent\x18\x02\x20\x01(\x01R\ncpuPercent\x12%\n\x0ememory_percent\
    \x18\x03\x20\x01(\x01R\rmemoryPercent\x12\"\n\x0cverification\x18\x04\
    \x20\x01(\x08R\x0cverification\x12\x18\n\x07details\x18\x05\x20\x03(\tR\
    \x07details\x12'\n\x0fstorage_percent\x18\x06\x20\x01(\x01R\x0estoragePe\
    rcent\"F\n\x12ListNetworkOptions\x12\x18\n\x07podname\x18\x01\x20\x01(\t\
    R\x07podname\x12\x16\n\x06driver\x18\x02\x20\x01(\tR\x06driver\"7\n\x07N\
    etwork\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07subnet\
    s\x18\x02\x20\x03(\tR\x07subnets\"3\n\x08Networks\x12'\n\x08networks\x18\
    \x01\x20\x03(\x0b2\x0b.pb.NetworkR\x08networks\"\xe6\x06\n\x04Node\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08endpoint\x18\x02\
    \x20\x01(\tR\x08endpoint\x12\x18\n\x07podname\x18\x03\x20\x01(\tR\x07pod\
    name\x12#\n\x03cpu\x18\x04\x20\x03(\x0b2\x11.pb.Node.CpuEntryR\x03cpu\
    \x12\x19\n\x08cpu_used\x18\x05\x20\x01(\x01R\x07cpuUsed\x12\x16\n\x06mem\
    ory\x18\x06\x20\x01(\x03R\x06memory\x12\x1f\n\x0bmemory_used\x18\x07\x20\
    \x01(\x03R\nmemoryUsed\x12\x1c\n\tavailable\x18\x08\x20\x01(\x08R\tavail\
    able\x12,\n\x06labels\x18\t\x20\x03(\x0b2\x14.pb.Node.LabelsEntryR\x06la\
    bels\x12\x1f\n\x0binit_memory\x18\n\x20\x01(\x03R\ninitMemory\x120\n\x08\
    init_cpu\x18\x0b\x20\x03(\x0b2\x15.pb.Node.InitCpuEntryR\x07initCpu\x12\
    \x12\n\x04info\x18\x0c\x20\x01(\tR\x04info\x12&\n\x04numa\x18\r\x20\x03(\
    \x0b2\x12.pb.Node.NumaEntryR\x04numa\x129\n\x0bnuma_memory\x18\x0e\x20\
    \x03(\x0b2\x18.pb.Node.NumaMemoryEntryR\nnumaMemory\x12\x18\n\x07storage\
    \x18\x0f\x20\x01(\x03R\x07storage\x12!\n\x0cstorage_used\x18\x10\x20\x01\
    (\x03R\x0bstorageUsed\x12!\n\x0cinit_storage\x18\x11\x20\x01(\x03R\x0bin\
    itStorage\x1a6\n\x08CpuEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05value:\x028\x01\x1a9\n\x0bL\
    abelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05valu\
    e\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a:\n\x0cInitCpuEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x05R\x05value:\x028\x01\x1a7\n\tNumaEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\x1a=\n\x0fNumaMemoryEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05value:\x028\x01\"'\n\x05N\
    odes\x12\x1e\n\x05nodes\x18\x01\x20\x03(\x0b2\x08.pb.NodeR\x05nodes\"E\n\
    \rNodeAvailable\x12\x1a\n\x08nodename\x18\x01\x20\x01(\tR\x08nodename\
    \x12\x18\n\x07podname\x18\x02\x20\x01(\tR\x07podname\"\xff\x04\n\x0eSetN\
    odeOptions\x12\x1a\n\x08nodename\x18\x01\x20\x01(\tR\x08nodename\x12\x16\
    \n\x06status\x18\x02\x20\x01(\x05R\x06status\x12=\n\tdelta_cpu\x18\x03\
    \x20\x03(\x0b2\x20.pb.SetNodeOptions.DeltaCpuEntryR\x08deltaCpu\x12!\n\
    \x0cdelta_memory\x18\x04\x20\x01(\x03R\x0bdeltaMemory\x12#\n\rdelta_stor\
    age\x18\x05\x20\x01(\x03R\x0cdeltaStorage\x12S\n\x11delta_numa_memory\
    \x18\x06\x20\x03(\x0b2'.pb.SetNodeOptions.DeltaNumaMemoryEntryR\x0fdelta\
    NumaMemory\x120\n\x04numa\x18\x07\x20\x03(\x0b2\x1c.pb.SetNodeOptions.Nu\
    maEntryR\x04numa\x126\n\x06labels\x18\x08\x20\x03(\x0b2\x1e.pb.SetNodeOp\
    tions.LabelsEntryR\x06labels\x1a;\n\rDeltaCpuEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05valu\
    e:\x028\x01\x1aB\n\x14DeltaNumaMemoryEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05value:\x028\
    \x01\x1a7\n\tNumaEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a9\n\x0bLabelsE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"\xd2\x04\n\tContainer\x12\x0e\n\x02\
    id\x18\x01\x20\x01(\tR\x02id\x12\x18\n\x07podname\x18\x02\x20\x01(\tR\
    \x07podname\x12\x1a\n\x08nodename\x18\x03\x20\x01(\tR\x08nodename\x12\
    \x12\n\x04name\x18\x04\x20\x01(\tR\x04name\x12(\n\x03cpu\x18\x05\x20\x03\
    (\x0b2\x16.pb.Container.CpuEntryR\x03cpu\x12\x14\n\x05quota\x18\x06\x20\
    \x01(\x01R\x05quota\x12\x16\n\x06memory\x18\x07\x20\x01(\x03R\x06memory\
    \x12\x1e\n\nprivileged\x18\x08\x20\x01(\x08R\nprivileged\x121\n\x06label\
    s\x18\t\x20\x03(\x0b2\x19.pb.Container.LabelsEntryR\x06labels\x124\n\x07\
    publish\x18\n\x20\x03(\x0b2\x1a.pb.Container.PublishEntryR\x07publish\
    \x12\x14\n\x05image\x18\x0b\x20\x01(\tR\x05image\x12\x18\n\x07storage\
    \x18\x0c\x20\x01(\x03R\x07storage\x12+\n\x06status\x18\r\x20\x01(\x0b2\
    \x13.pb.ContainerStatusR\x06status\x1a6\n\x08CpuEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05\
    value:\x028\x01\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    :\n\x0cPublishEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\
    \n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x81\x02\n\x0fContai\
    nerStatus\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x18\n\x07running\
    \x18\x02\x20\x01(\x08R\x07running\x12\x18\n\x07healthy\x18\x03\x20\x01(\
    \x08R\x07healthy\x12=\n\x08networks\x18\x04\x20\x03(\x0b2!.pb.ContainerS\
    tatus.NetworksEntryR\x08networks\x12\x1c\n\textension\x18\x05\x20\x01(\
    \x0cR\textension\x12\x10\n\x03ttl\x18\x06\x20\x01(\x03R\x03ttl\x1a;\n\rN\
    etworksEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05va\
    lue\x18\x02\x20\x01(\tR\x05value:\x028\x01\"?\n\x10ContainersStatus\x12+\
    \n\x06status\x18\x01\x20\x03(\x0b2\x13.pb.ContainerStatusR\x06status\"\
    \xb6\x01\n\x1cContainerStatusStreamMessage\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12+\n\tcontainer\x18\x02\x20\x01(\x0b2\r.pb.ContainerR\t\
    container\x12+\n\x06status\x18\x03\x20\x01(\x0b2\x13.pb.ContainerStatusR\
    \x06status\x12\x14\n\x05error\x18\x04\x20\x01(\tR\x05error\x12\x16\n\x06\
    delete\x18\x05\x20\x01(\x08R\x06delete\"I\n\x1aSetContainersStatusOption\
    s\x12+\n\x06status\x18\x01\x20\x03(\x0b2\x13.pb.ContainerStatusR\x06stat\
    us\"\xf5\x01\n\x1cContainerStatusStreamOptions\x12\x18\n\x07appname\x18\
    \x01\x20\x01(\tR\x07appname\x12\x1e\n\nentrypoint\x18\x02\x20\x01(\tR\ne\
    ntrypoint\x12\x1a\n\x08nodename\x18\x03\x20\x01(\tR\x08nodename\x12D\n\
    \x06labels\x18\x04\x20\x03(\x0b2,.pb.ContainerStatusStreamOptions.Labels\
    EntryR\x06labels\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\";\
    \n\nContainers\x12-\n\ncontainers\x18\x01\x20\x03(\x0b2\r.pb.ContainerR\
    \ncontainers\"\x1d\n\x0bContainerID\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\"\x20\n\x0cContainerIDs\x12\x10\n\x03ids\x18\x01\x20\x03(\tR\x03i\
    ds\"T\n\x16RemoveContainerOptions\x12\x10\n\x03ids\x18\x01\x20\x03(\tR\
    \x03ids\x12\x14\n\x05force\x18\x02\x20\x01(\x08R\x05force\x12\x12\n\x04s\
    tep\x18\x03\x20\x01(\x05R\x04step\".\n\x1aDissociateContainerOptions\x12\
    \x10\n\x03ids\x18\x01\x20\x03(\tR\x03ids\"L\n\x0eReallocOptions\x12\x10\
    \n\x03ids\x18\x01\x20\x03(\tR\x03ids\x12\x10\n\x03cpu\x18\x02\x20\x01(\
    \x01R\x03cpu\x12\x16\n\x06memory\x18\x03\x20\x01(\x03R\x06memory\"7\n\rA\
    ddPodOptions\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04\
    desc\x18\x02\x20\x01(\tR\x04desc\"&\n\x10RemovePodOptions\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\"#\n\rGetPodOptions\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\"\xd4\x04\n\x0eAddNodeOptions\x12\x1a\n\x08\
    nodename\x18\x01\x20\x01(\tR\x08nodename\x12\x1a\n\x08endpoint\x18\x02\
    \x20\x01(\tR\x08endpoint\x12\x18\n\x07podname\x18\x03\x20\x01(\tR\x07pod\
    name\x12\x0e\n\x02ca\x18\x04\x20\x01(\tR\x02ca\x12\x12\n\x04cert\x18\x05\
    \x20\x01(\tR\x04cert\x12\x10\n\x03key\x18\x06\x20\x01(\tR\x03key\x12\x10\
    \n\x03cpu\x18\x07\x20\x01(\x05R\x03cpu\x12\x14\n\x05share\x18\x08\x20\
    \x01(\x05R\x05share\x12\x16\n\x06memory\x18\t\x20\x01(\x03R\x06memory\
    \x126\n\x06labels\x18\n\x20\x03(\x0b2\x1e.pb.AddNodeOptions.LabelsEntryR\
    \x06labels\x120\n\x04numa\x18\x0b\x20\x03(\x0b2\x1c.pb.AddNodeOptions.Nu\
    maEntryR\x04numa\x12C\n\x0bnuma_memory\x18\x0c\x20\x03(\x0b2\".pb.AddNod\
    eOptions.NumaMemoryEntryR\nnumaMemory\x12\x18\n\x07storage\x18\r\x20\x01\
    (\x03R\x07storage\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\
    \x1a7\n\tNumaEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a=\n\x0fNumaMemoryEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x03R\x05value:\x028\x01\"/\n\x11RemoveNodeOptions\x12\x1a\
    \n\x08nodename\x18\x01\x20\x01(\tR\x08nodename\"\x9f\x01\n\x0eGetNodeOpt\
    ions\x12\x1a\n\x08nodename\x18\x01\x20\x01(\tR\x08nodename\x126\n\x06lab\
    els\x18\x02\x20\x03(\x0b2\x1e.pb.GetNodeOptions.LabelsEntryR\x06labels\
    \x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xb3\x01\n\x10Li\
    stNodesOptions\x12\x18\n\x07podname\x18\x01\x20\x01(\tR\x07podname\x12\
    \x10\n\x03all\x18\x02\x20\x01(\x08R\x03all\x128\n\x06labels\x18\x03\x20\
    \x03(\x0b2\x20.pb.ListNodesOptions.LabelsEntryR\x06labels\x1a9\n\x0bLabe\
    lsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xdc\x05\n\x05Build\x12\x12\n\
    \x04base\x18\x01\x20\x01(\tR\x04base\x12\x12\n\x04repo\x18\x02\x20\x01(\
    \tR\x04repo\x12\x18\n\x07version\x18\x03\x20\x01(\tR\x07version\x12\x10\
    \n\x03dir\x18\x04\x20\x01(\tR\x03dir\x12\x1c\n\tsubmodule\x18\x05\x20\
    \x01(\x08R\tsubmodule\x12\x1a\n\x08commands\x18\x06\x20\x03(\tR\x08comma\
    nds\x12'\n\x04envs\x18\x07\x20\x03(\x0b2\x13.pb.Build.EnvsEntryR\x04envs\
    \x12'\n\x04args\x18\x08\x20\x03(\x0b2\x13.pb.Build.ArgsEntryR\x04args\
    \x12-\n\x06labels\x18\t\x20\x03(\x0b2\x15.pb.Build.LabelsEntryR\x06label\
    s\x126\n\tartifacts\x18\n\x20\x03(\x0b2\x18.pb.Build.ArtifactsEntryR\tar\
    tifacts\x12*\n\x05cache\x18\x0b\x20\x03(\x0b2\x14.pb.Build.CacheEntryR\
    \x05cache\x12\x1f\n\x0bstop_signal\x18\x0c\x20\x01(\tR\nstopSignal\x12\
    \x1a\n\x08security\x18\r\x20\x01(\x08R\x08security\x1a7\n\tEnvsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a7\n\tArgsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a<\n\x0eArt\
    ifactsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a8\n\nCacheEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\"\x96\x01\n\x06Builds\x12\x16\n\x06stages\x18\x01\
    \x20\x03(\tR\x06stages\x12.\n\x06builds\x18\x02\x20\x03(\x0b2\x16.pb.Bui\
    lds.BuildsEntryR\x06builds\x1aD\n\x0bBuildsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x1f\n\x05value\x18\x02\x20\x01(\x0b2\t.pb.Bu\
    ildR\x05value:\x028\x01\"\x97\x01\n\x11BuildImageOptions\x12\x12\n\x04na\
    me\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04user\x18\x02\x20\x01(\tR\x04\
    user\x12\x10\n\x03uid\x18\x03\x20\x01(\x05R\x03uid\x12\x12\n\x04tags\x18\
    \x04\x20\x03(\tR\x04tags\x12\"\n\x06builds\x18\x05\x20\x01(\x0b2\n.pb.Bu\
    ildsR\x06builds\x12\x10\n\x03tar\x18\x06\x20\x01(\x0cR\x03tar\"e\n\x0bHo\
    okOptions\x12\x1f\n\x0bafter_start\x18\x01\x20\x03(\tR\nafterStart\x12\
    \x1f\n\x0bbefore_stop\x18\x02\x20\x03(\tR\nbeforeStop\x12\x14\n\x05force\
    \x18\x03\x20\x01(\x08R\x05force\"t\n\x12HealthCheckOptions\x12\x1b\n\ttc\
    p_ports\x18\x01\x20\x03(\tR\x08tcpPorts\x12\x1b\n\thttp_port\x18\x02\x20\
    \x01(\tR\x08httpPort\x12\x10\n\x03url\x18\x03\x20\x01(\tR\x03url\x12\x12\
    \n\x04code\x18\x04\x20\x01(\x05R\x04code\"\x8f\x01\n\nLogOptions\x12\x12\
    \n\x04type\x18\x01\x20\x01(\tR\x04type\x122\n\x06config\x18\x02\x20\x03(\
    \x0b2\x1a.pb.LogOptions.ConfigEntryR\x06config\x1a9\n\x0bConfigEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\"\xaf\x03\n\x11EntrypointOptions\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07command\x18\x02\x20\
    \x01(\tR\x07command\x12\x1e\n\nprivileged\x18\x03\x20\x01(\x08R\nprivile\
    ged\x12\x10\n\x03dir\x18\x04\x20\x01(\tR\x03dir\x12\x20\n\x03log\x18\x05\
    \x20\x01(\x0b2\x0e.pb.LogOptionsR\x03log\x12\x18\n\x07publish\x18\x06\
    \x20\x03(\tR\x07publish\x128\n\x0bhealthcheck\x18\x07\x20\x01(\x0b2\x16.\
    pb.HealthCheckOptionsR\x0bhealthcheck\x12#\n\x04hook\x18\x08\x20\x01(\
    \x0b2\x0f.pb.HookOptionsR\x04hook\x12%\n\x0erestart_policy\x18\t\x20\x01\
    (\tR\rrestartPolicy\x12<\n\x07sysctls\x18\n\x20\x03(\x0b2\".pb.Entrypoin\
    tOptions.SysctlsEntryR\x07sysctls\x1a:\n\x0cSysctlsEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alue:\x028\x01\"\xaa\t\n\rDeployOptions\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x125\n\nentrypoint\x18\x02\x20\x01(\x0b2\x15.pb.Entrypo\
    intOptionsR\nentrypoint\x12\x18\n\x07podname\x18\x03\x20\x01(\tR\x07podn\
    ame\x12\x1a\n\x08nodename\x18\x04\x20\x01(\tR\x08nodename\x12\x14\n\x05i\
    mage\x18\x05\x20\x01(\tR\x05image\x12\x1d\n\nextra_args\x18\x06\x20\x01(\
    \tR\textraArgs\x12\x1b\n\tcpu_quota\x18\x07\x20\x01(\x01R\x08cpuQuota\
    \x12\x16\n\x06memory\x18\x08\x20\x01(\x03R\x06memory\x12\x14\n\x05count\
    \x18\t\x20\x01(\x05R\x05count\x12\x10\n\x03env\x18\n\x20\x03(\tR\x03env\
    \x12\x10\n\x03dns\x18\x0b\x20\x03(\tR\x03dns\x12\x1f\n\x0bextra_hosts\
    \x18\x0c\x20\x03(\tR\nextraHosts\x12\x18\n\x07volumes\x18\r\x20\x03(\tR\
    \x07volumes\x12;\n\x08networks\x18\x0e\x20\x03(\x0b2\x1f.pb.DeployOption\
    s.NetworksEntryR\x08networks\x12\x20\n\x0bnetworkmode\x18\x0f\x20\x01(\t\
    R\x0bnetworkmode\x12\x12\n\x04user\x18\x10\x20\x01(\tR\x04user\x12\x14\n\
    \x05debug\x18\x11\x20\x01(\x08R\x05debug\x12\x1c\n\topenStdin\x18\x12\
    \x20\x01(\x08R\topenStdin\x125\n\x06labels\x18\x13\x20\x03(\x0b2\x1d.pb.\
    DeployOptions.LabelsEntryR\x06labels\x12A\n\nnodelabels\x18\x14\x20\x03(\
    \x0b2!.pb.DeployOptions.NodelabelsEntryR\nnodelabels\x12#\n\rdeploy_meth\
    od\x18\x15\x20\x01(\tR\x0cdeployMethod\x12/\n\x04data\x18\x16\x20\x03(\
    \x0b2\x1b.pb.DeployOptions.DataEntryR\x04data\x12\x1d\n\nsoft_limit\x18\
    \x17\x20\x01(\x08R\tsoftLimit\x12\x1f\n\x0bnodes_limit\x18\x18\x20\x01(\
    \x05R\nnodesLimit\x12\x19\n\x08cpu_bind\x18\x19\x20\x01(\x08R\x07cpuBind\
    \x12\x1f\n\x0bignore_hook\x18\x1a\x20\x01(\x08R\nignoreHook\x12!\n\x0caf\
    ter_create\x18\x1b\x20\x03(\tR\x0bafterCreate\x12\x19\n\x08raw_args\x18\
    \x1c\x20\x01(\x0cR\x07rawArgs\x12\x18\n\x07storage\x18\x1d\x20\x01(\x03R\
    \x07storage\x1a;\n\rNetworksEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a9\n\
    \x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a=\n\x0fNodelabelsEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\x1a7\n\tDataEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05\
    value:\x028\x01\"\xf2\x02\n\x0eReplaceOptions\x12/\n\tdeployOpt\x18\x01\
    \x20\x01(\x0b2\x11.pb.DeployOptionsR\tdeployOpt\x12&\n\x0enetworkinherit\
    \x18\x02\x20\x01(\x08R\x0enetworkinherit\x12I\n\rfilter_labels\x18\x03\
    \x20\x03(\x0b2$.pb.ReplaceOptions.FilterLabelsEntryR\x0cfilterLabels\x12\
    0\n\x04copy\x18\x04\x20\x03(\x0b2\x1c.pb.ReplaceOptions.CopyEntryR\x04co\
    py\x12\x10\n\x03ids\x18\x05\x20\x03(\tR\x03ids\x1a?\n\x11FilterLabelsEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\x1a7\n\tCopyEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"u\n\x11CacheImageOptions\x12\x18\n\x07podname\x18\x01\x20\
    \x01(\tR\x07podname\x12\x1a\n\x08nodename\x18\x02\x20\x01(\tR\x08nodenam\
    e\x12\x16\n\x06images\x18\x03\x20\x03(\tR\x06images\x12\x12\n\x04step\
    \x18\x04\x20\x01(\x05R\x04step\"\x8c\x01\n\x12RemoveImageOptions\x12\x18\
    \n\x07podname\x18\x01\x20\x01(\tR\x07podname\x12\x1a\n\x08nodename\x18\
    \x02\x20\x01(\tR\x08nodename\x12\x16\n\x06images\x18\x03\x20\x03(\tR\x06\
    images\x12\x12\n\x04step\x18\x04\x20\x01(\x05R\x04step\x12\x14\n\x05prun\
    e\x18\x05\x20\x01(\x08R\x05prune\"!\n\tCopyPaths\x12\x14\n\x05paths\x18\
    \x01\x20\x03(\tR\x05paths\"\x90\x01\n\x0bCopyOptions\x126\n\x07targets\
    \x18\x01\x20\x03(\x0b2\x1c.pb.CopyOptions.TargetsEntryR\x07targets\x1aI\
    \n\x0cTargetsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12#\n\
    \x05value\x18\x02\x20\x01(\x0b2\r.pb.CopyPathsR\x05value:\x028\x01\"\x87\
    \x01\n\x0bSendOptions\x12\x10\n\x03ids\x18\x01\x20\x03(\tR\x03ids\x12-\n\
    \x04data\x18\x02\x20\x03(\x0b2\x19.pb.SendOptions.DataEntryR\x04data\x1a\
    7\n\tDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05\
    value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01\";\n\x0bErrorDetail\x12\
    \x12\n\x04code\x18\x01\x20\x01(\x03R\x04code\x12\x18\n\x07message\x18\
    \x02\x20\x01(\tR\x07message\"\xb9\x01\n\x11BuildImageMessage\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\x12\x16\n\x06status\x18\x02\x20\x01(\tR\
    \x06status\x12\x1a\n\x08progress\x18\x03\x20\x01(\tR\x08progress\x12\x14\
    \n\x05error\x18\x04\x20\x01(\tR\x05error\x12\x16\n\x06stream\x18\x05\x20\
    \x01(\tR\x06stream\x122\n\x0cerror_detail\x18\x06\x20\x01(\x0b2\x0f.pb.E\
    rrorDetailR\x0berrorDetail\"\xec\x03\n\x16CreateContainerMessage\x12\x18\
    \n\x07podname\x18\x01\x20\x01(\tR\x07podname\x12\x1a\n\x08nodename\x18\
    \x02\x20\x01(\tR\x08nodename\x12\x0e\n\x02id\x18\x03\x20\x01(\tR\x02id\
    \x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name\x12\x14\n\x05error\x18\
    \x05\x20\x01(\tR\x05error\x12\x18\n\x07success\x18\x06\x20\x01(\x08R\x07\
    success\x125\n\x03cpu\x18\x07\x20\x03(\x0b2#.pb.CreateContainerMessage.C\
    puEntryR\x03cpu\x12\x14\n\x05quota\x18\x08\x20\x01(\x01R\x05quota\x12\
    \x16\n\x06memory\x18\t\x20\x01(\x03R\x06memory\x12A\n\x07publish\x18\n\
    \x20\x03(\x0b2'.pb.CreateContainerMessage.PublishEntryR\x07publish\x12\
    \x12\n\x04hook\x18\x0b\x20\x01(\x0cR\x04hook\x12\x18\n\x07storage\x18\
    \x0c\x20\x01(\x03R\x07storage\x1a6\n\x08CpuEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05valu\
    e:\x028\x01\x1a:\n\x0cPublishEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x97\
    \x01\n\x17ReplaceContainerMessage\x122\n\x06create\x18\x01\x20\x01(\x0b2\
    \x1a.pb.CreateContainerMessageR\x06create\x122\n\x06remove\x18\x02\x20\
    \x01(\x0b2\x1a.pb.RemoveContainerMessageR\x06remove\x12\x14\n\x05error\
    \x18\x03\x20\x01(\tR\x05error\"y\n\x11CacheImageMessage\x12\x14\n\x05ima\
    ge\x18\x01\x20\x01(\tR\x05image\x12\x18\n\x07success\x18\x02\x20\x01(\
    \x08R\x07success\x12\x1a\n\x08nodename\x18\x03\x20\x01(\tR\x08nodename\
    \x12\x18\n\x07message\x18\x04\x20\x01(\tR\x07message\"`\n\x12RemoveImage\
    Message\x12\x14\n\x05image\x18\x01\x20\x01(\tR\x05image\x12\x18\n\x07suc\
    cess\x18\x02\x20\x01(\x08R\x07success\x12\x1a\n\x08messages\x18\x03\x20\
    \x03(\tR\x08messages\"V\n\x16RemoveContainerMessage\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x18\n\x07success\x18\x02\x20\x01(\x08R\x07suc\
    cess\x12\x12\n\x04hook\x18\x03\x20\x01(\tR\x04hook\"B\n\x1aDissociateCon\
    tainerMessage\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05err\
    or\x18\x02\x20\x01(\tR\x05error\"B\n\x16ReallocResourceMessage\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\x12\x18\n\x07success\x18\x02\x20\x01(\
    \x08R\x07success\"\x87\x01\n\x0bCopyMessage\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12\x12\
    \n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x12\n\x04path\x18\x04\x20\x01\
    (\tR\x04path\x12\x14\n\x05error\x18\x05\x20\x01(\tR\x05error\x12\x12\n\
    \x04data\x18\x06\x20\x01(\x0cR\x04data\"G\n\x0bSendMessage\x12\x0e\n\x02\
    id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04pa\
    th\x12\x14\n\x05error\x18\x03\x20\x01(\tR\x05error\"O\n\x16AttachContain\
    erMessage\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\x12\
    \x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\"\x9a\x01\n\x11RunAndWaitOp\
    tions\x128\n\x0edeploy_options\x18\x01\x20\x01(\x0b2\x11.pb.DeployOption\
    sR\rdeployOptions\x12\x10\n\x03cmd\x18\x02\x20\x01(\x0cR\x03cmd\x12\x14\
    \n\x05async\x18\x03\x20\x01(\x08R\x05async\x12#\n\rasync_timeout\x18\x04\
    \x20\x01(\x05R\x0casyncTimeout\"U\n\x17ControlContainerOptions\x12\x10\n\
    \x03ids\x18\x01\x20\x03(\tR\x03ids\x12\x12\n\x04type\x18\x02\x20\x01(\tR\
    \x04type\x12\x14\n\x05force\x18\x03\x20\x01(\x08R\x05force\"S\n\x17Contr\
    olContainerMessage\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\
    \x05error\x18\x02\x20\x01(\tR\x05error\x12\x12\n\x04hook\x18\x03\x20\x01\
    (\x0cR\x04hook\"L\n\x10LogStreamMessage\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \tR\x02id\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05error\x12\x12\n\x04d\
    ata\x18\x03\x20\x01(\x0cR\x04data\"\xc0\x01\n\x17ExecuteContainerOptions\
    \x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\x12\x1a\n\x08\
    commands\x18\x02\x20\x03(\tR\x08commands\x12\x12\n\x04envs\x18\x03\x20\
    \x03(\tR\x04envs\x12\x18\n\x07workdir\x18\x04\x20\x01(\tR\x07workdir\x12\
    \x1d\n\nopen_stdin\x18\x05\x20\x01(\x08R\topenStdin\x12\x19\n\x08repl_cm\
    d\x18\x06\x20\x01(\x0cR\x07replCmd2\xd4\x0f\n\x07CoreRPC\x126\n\x0cListN\
    etworks\x12\x16.pb.ListNetworkOptions\x1a\x0c.pb.Networks\"\0\x12!\n\x08\
    ListPods\x12\t.pb.Empty\x1a\x08.pb.Pods\"\0\x12&\n\x06AddPod\x12\x11.pb.\
    AddPodOptions\x1a\x07.pb.Pod\"\0\x12.\n\tRemovePod\x12\x14.pb.RemovePodO\
    ptions\x1a\t.pb.Empty\"\0\x12&\n\x06GetPod\x12\x11.pb.GetPodOptions\x1a\
    \x07.pb.Pod\"\0\x126\n\x0eGetPodResource\x12\x11.pb.GetPodOptions\x1a\
    \x0f.pb.PodResource\"\0\x121\n\x0cListPodNodes\x12\x14.pb.ListNodesOptio\
    ns\x1a\t.pb.Nodes\"\0\x12)\n\x07AddNode\x12\x12.pb.AddNodeOptions\x1a\
    \x08.pb.Node\"\0\x120\n\nRemoveNode\x12\x15.pb.RemoveNodeOptions\x1a\t.p\
    b.Empty\"\0\x12)\n\x07SetNode\x12\x12.pb.SetNodeOptions\x1a\x08.pb.Node\
    \"\0\x12)\n\x07GetNode\x12\x12.pb.GetNodeOptions\x1a\x08.pb.Node\"\0\x12\
    9\n\x0fGetNodeResource\x12\x12.pb.GetNodeOptions\x1a\x10.pb.NodeResource\
    \"\0\x120\n\x0cGetContainer\x12\x0f.pb.ContainerID\x1a\r.pb.Container\"\
    \0\x123\n\rGetContainers\x12\x10.pb.ContainerIDs\x1a\x0e.pb.Containers\"\
    \0\x12>\n\x0eListContainers\x12\x19.pb.ListContainersOptions\x1a\r.pb.Co\
    ntainer\"\00\x01\x12:\n\x12ListNodeContainers\x12\x12.pb.GetNodeOptions\
    \x1a\x0e.pb.Containers\"\0\x12?\n\x13GetContainersStatus\x12\x10.pb.Cont\
    ainerIDs\x1a\x14.pb.ContainersStatus\"\0\x12M\n\x13SetContainersStatus\
    \x12\x1e.pb.SetContainersStatusOptions\x1a\x14.pb.ContainersStatus\"\0\
    \x12_\n\x15ContainerStatusStream\x12\x20.pb.ContainerStatusStreamOptions\
    \x1a\x20.pb.ContainerStatusStreamMessage\"\00\x01\x12,\n\x04Copy\x12\x0f\
    .pb.CopyOptions\x1a\x0f.pb.CopyMessage\"\00\x01\x12,\n\x04Send\x12\x0f.p\
    b.SendOptions\x1a\x0f.pb.SendMessage\"\00\x01\x12>\n\nBuildImage\x12\x15\
    .pb.BuildImageOptions\x1a\x15.pb.BuildImageMessage\"\00\x01\x12>\n\nCach\
    eImage\x12\x15.pb.CacheImageOptions\x1a\x15.pb.CacheImageMessage\"\00\
    \x01\x12A\n\x0bRemoveImage\x12\x16.pb.RemoveImageOptions\x1a\x16.pb.Remo\
    veImageMessage\"\00\x01\x12D\n\x0fCreateContainer\x12\x11.pb.DeployOptio\
    ns\x1a\x1a.pb.CreateContainerMessage\"\00\x01\x12G\n\x10ReplaceContainer\
    \x12\x12.pb.ReplaceOptions\x1a\x1b.pb.ReplaceContainerMessage\"\00\x01\
    \x12M\n\x0fRemoveContainer\x12\x1a.pb.RemoveContainerOptions\x1a\x1a.pb.\
    RemoveContainerMessage\"\00\x01\x12Y\n\x13DissociateContainer\x12\x1e.pb\
    .DissociateContainerOptions\x1a\x1e.pb.DissociateContainerMessage\"\00\
    \x01\x12P\n\x10ControlContainer\x12\x1b.pb.ControlContainerOptions\x1a\
    \x1b.pb.ControlContainerMessage\"\00\x01\x12E\n\x0fReallocResource\x12\
    \x12.pb.ReallocOptions\x1a\x1a.pb.ReallocResourceMessage\"\00\x01\x126\n\
    \tLogStream\x12\x0f.pb.ContainerID\x1a\x14.pb.LogStreamMessage\"\00\x01\
    \x12E\n\nRunAndWait\x12\x15.pb.RunAndWaitOptions\x1a\x1a.pb.AttachContai\
    nerMessage\"\0(\x010\x01\x12Q\n\x10ExecuteContainer\x12\x1b.pb.ExecuteCo\
    ntainerOptions\x1a\x1a.pb.AttachContainerMessage\"\0(\x010\x01J\xc6\xbb\
    \x01\n\x07\x12\x05\0\0\xf7\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\
    \n\x01\x02\x12\x03\x02\0\x0b\n\n\n\x02\x06\0\x12\x04\x04\0,\x01\n\n\n\
    \x03\x06\0\x01\x12\x03\x04\x08\x0f\n\x0b\n\x04\x06\0\x02\0\x12\x03\x05\
    \x04>\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x05\x08\x14\n\x0c\n\x05\x06\0\
    \x02\0\x02\x12\x03\x05\x15'\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x052:\n\
    \x0b\n\x04\x06\0\x02\x01\x12\x03\x07\x04)\n\x0c\n\x05\x06\0\x02\x01\x01\
    \x12\x03\x07\x08\x10\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x07\x11\x16\n\
    \x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x07!%\n\x0b\n\x04\x06\0\x02\x02\x12\
    \x03\x08\x04.\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x08\x08\x0e\n\x0c\n\
    \x05\x06\0\x02\x02\x02\x12\x03\x08\x0f\x1c\n\x0c\n\x05\x06\0\x02\x02\x03\
    \x12\x03\x08'*\n\x0b\n\x04\x06\0\x02\x03\x12\x03\t\x046\n\x0c\n\x05\x06\
    \0\x02\x03\x01\x12\x03\t\x08\x11\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\t\
    \x12\"\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\t-2\n\x0b\n\x04\x06\0\x02\
    \x04\x12\x03\n\x04.\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03\n\x08\x0e\n\
    \x0c\n\x05\x06\0\x02\x04\x02\x12\x03\n\x0f\x1c\n\x0c\n\x05\x06\0\x02\x04\
    \x03\x12\x03\n'*\n\x0b\n\x04\x06\0\x02\x05\x12\x03\x0b\x04>\n\x0c\n\x05\
    \x06\0\x02\x05\x01\x12\x03\x0b\x08\x16\n\x0c\n\x05\x06\0\x02\x05\x02\x12\
    \x03\x0b\x17$\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03\x0b/:\n\x0b\n\x04\
    \x06\0\x02\x06\x12\x03\x0c\x049\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03\
    \x0c\x08\x14\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03\x0c\x15%\n\x0c\n\x05\
    \x06\0\x02\x06\x03\x12\x03\x0c05\n\x0b\n\x04\x06\0\x02\x07\x12\x03\x0e\
    \x041\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x03\x0e\x08\x0f\n\x0c\n\x05\x06\
    \0\x02\x07\x02\x12\x03\x0e\x10\x1e\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03\
    \x0e)-\n\x0b\n\x04\x06\0\x02\x08\x12\x03\x0f\x048\n\x0c\n\x05\x06\0\x02\
    \x08\x01\x12\x03\x0f\x08\x12\n\x0c\n\x05\x06\0\x02\x08\x02\x12\x03\x0f\
    \x13$\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03\x0f/4\n\x0b\n\x04\x06\0\x02\
    \t\x12\x03\x10\x041\n\x0c\n\x05\x06\0\x02\t\x01\x12\x03\x10\x08\x0f\n\
    \x0c\n\x05\x06\0\x02\t\x02\x12\x03\x10\x10\x1e\n\x0c\n\x05\x06\0\x02\t\
    \x03\x12\x03\x10)-\n\x0b\n\x04\x06\0\x02\n\x12\x03\x11\x041\n\x0c\n\x05\
    \x06\0\x02\n\x01\x12\x03\x11\x08\x0f\n\x0c\n\x05\x06\0\x02\n\x02\x12\x03\
    \x11\x10\x1e\n\x0c\n\x05\x06\0\x02\n\x03\x12\x03\x11)-\n\x0b\n\x04\x06\0\
    \x02\x0b\x12\x03\x12\x04A\n\x0c\n\x05\x06\0\x02\x0b\x01\x12\x03\x12\x08\
    \x17\n\x0c\n\x05\x06\0\x02\x0b\x02\x12\x03\x12\x18&\n\x0c\n\x05\x06\0\
    \x02\x0b\x03\x12\x03\x121=\n\x0b\n\x04\x06\0\x02\x0c\x12\x03\x14\x048\n\
    \x0c\n\x05\x06\0\x02\x0c\x01\x12\x03\x14\x08\x14\n\x0c\n\x05\x06\0\x02\
    \x0c\x02\x12\x03\x14\x15\x20\n\x0c\n\x05\x06\0\x02\x0c\x03\x12\x03\x14+4\
    \n\x0b\n\x04\x06\0\x02\r\x12\x03\x15\x04;\n\x0c\n\x05\x06\0\x02\r\x01\
    \x12\x03\x15\x08\x15\n\x0c\n\x05\x06\0\x02\r\x02\x12\x03\x15\x16\"\n\x0c\
    \n\x05\x06\0\x02\r\x03\x12\x03\x15-7\n\x0b\n\x04\x06\0\x02\x0e\x12\x03\
    \x16\x04K\n\x0c\n\x05\x06\0\x02\x0e\x01\x12\x03\x16\x08\x16\n\x0c\n\x05\
    \x06\0\x02\x0e\x02\x12\x03\x16\x17,\n\x0c\n\x05\x06\0\x02\x0e\x06\x12\
    \x03\x167=\n\x0c\n\x05\x06\0\x02\x0e\x03\x12\x03\x16>G\n\x0b\n\x04\x06\0\
    \x02\x0f\x12\x03\x17\x04B\n\x0c\n\x05\x06\0\x02\x0f\x01\x12\x03\x17\x08\
    \x1a\n\x0c\n\x05\x06\0\x02\x0f\x02\x12\x03\x17\x1b)\n\x0c\n\x05\x06\0\
    \x02\x0f\x03\x12\x03\x174>\n\x0b\n\x04\x06\0\x02\x10\x12\x03\x18\x04G\n\
    \x0c\n\x05\x06\0\x02\x10\x01\x12\x03\x18\x08\x1b\n\x0c\n\x05\x06\0\x02\
    \x10\x02\x12\x03\x18\x1c(\n\x0c\n\x05\x06\0\x02\x10\x03\x12\x03\x183C\n\
    \x0b\n\x04\x06\0\x02\x11\x12\x03\x19\x04U\n\x0c\n\x05\x06\0\x02\x11\x01\
    \x12\x03\x19\x08\x1b\n\x0c\n\x05\x06\0\x02\x11\x02\x12\x03\x19\x1c6\n\
    \x0c\n\x05\x06\0\x02\x11\x03\x12\x03\x19AQ\n\x0b\n\x04\x06\0\x02\x12\x12\
    \x03\x1a\x04l\n\x0c\n\x05\x06\0\x02\x12\x01\x12\x03\x1a\x08\x1d\n\x0c\n\
    \x05\x06\0\x02\x12\x02\x12\x03\x1a\x1e:\n\x0c\n\x05\x06\0\x02\x12\x06\
    \x12\x03\x1aEK\n\x0c\n\x05\x06\0\x02\x12\x03\x12\x03\x1aLh\n\x0b\n\x04\
    \x06\0\x02\x13\x12\x03\x1c\x049\n\x0c\n\x05\x06\0\x02\x13\x01\x12\x03\
    \x1c\x08\x0c\n\x0c\n\x05\x06\0\x02\x13\x02\x12\x03\x1c\r\x18\n\x0c\n\x05\
    \x06\0\x02\x13\x06\x12\x03\x1c#)\n\x0c\n\x05\x06\0\x02\x13\x03\x12\x03\
    \x1c*5\n\x0b\n\x04\x06\0\x02\x14\x12\x03\x1d\x049\n\x0c\n\x05\x06\0\x02\
    \x14\x01\x12\x03\x1d\x08\x0c\n\x0c\n\x05\x06\0\x02\x14\x02\x12\x03\x1d\r\
    \x18\n\x0c\n\x05\x06\0\x02\x14\x06\x12\x03\x1d#)\n\x0c\n\x05\x06\0\x02\
    \x14\x03\x12\x03\x1d*5\n\x0b\n\x04\x06\0\x02\x15\x12\x03\x1f\x04K\n\x0c\
    \n\x05\x06\0\x02\x15\x01\x12\x03\x1f\x08\x12\n\x0c\n\x05\x06\0\x02\x15\
    \x02\x12\x03\x1f\x13$\n\x0c\n\x05\x06\0\x02\x15\x06\x12\x03\x1f/5\n\x0c\
    \n\x05\x06\0\x02\x15\x03\x12\x03\x1f6G\n\x0b\n\x04\x06\0\x02\x16\x12\x03\
    \x20\x04K\n\x0c\n\x05\x06\0\x02\x16\x01\x12\x03\x20\x08\x12\n\x0c\n\x05\
    \x06\0\x02\x16\x02\x12\x03\x20\x13$\n\x0c\n\x05\x06\0\x02\x16\x06\x12\
    \x03\x20/5\n\x0c\n\x05\x06\0\x02\x16\x03\x12\x03\x206G\n\x0b\n\x04\x06\0\
    \x02\x17\x12\x03!\x04N\n\x0c\n\x05\x06\0\x02\x17\x01\x12\x03!\x08\x13\n\
    \x0c\n\x05\x06\0\x02\x17\x02\x12\x03!\x14&\n\x0c\n\x05\x06\0\x02\x17\x06\
    \x12\x03!17\n\x0c\n\x05\x06\0\x02\x17\x03\x12\x03!8J\n\x0b\n\x04\x06\0\
    \x02\x18\x12\x03#\x04Q\n\x0c\n\x05\x06\0\x02\x18\x01\x12\x03#\x08\x17\n\
    \x0c\n\x05\x06\0\x02\x18\x02\x12\x03#\x18%\n\x0c\n\x05\x06\0\x02\x18\x06\
    \x12\x03#06\n\x0c\n\x05\x06\0\x02\x18\x03\x12\x03#7M\n\x0b\n\x04\x06\0\
    \x02\x19\x12\x03$\x04T\n\x0c\n\x05\x06\0\x02\x19\x01\x12\x03$\x08\x18\n\
    \x0c\n\x05\x06\0\x02\x19\x02\x12\x03$\x19'\n\x0c\n\x05\x06\0\x02\x19\x06\
    \x12\x03$28\n\x0c\n\x05\x06\0\x02\x19\x03\x12\x03$9P\n\x0b\n\x04\x06\0\
    \x02\x1a\x12\x03%\x04Z\n\x0c\n\x05\x06\0\x02\x1a\x01\x12\x03%\x08\x17\n\
    \x0c\n\x05\x06\0\x02\x1a\x02\x12\x03%\x18.\n\x0c\n\x05\x06\0\x02\x1a\x06\
    \x12\x03%9?\n\x0c\n\x05\x06\0\x02\x1a\x03\x12\x03%@V\n\x0b\n\x04\x06\0\
    \x02\x1b\x12\x03&\x04f\n\x0c\n\x05\x06\0\x02\x1b\x01\x12\x03&\x08\x1b\n\
    \x0c\n\x05\x06\0\x02\x1b\x02\x12\x03&\x1c6\n\x0c\n\x05\x06\0\x02\x1b\x06\
    \x12\x03&AG\n\x0c\n\x05\x06\0\x02\x1b\x03\x12\x03&Hb\n\x0b\n\x04\x06\0\
    \x02\x1c\x12\x03'\x04]\n\x0c\n\x05\x06\0\x02\x1c\x01\x12\x03'\x08\x18\n\
    \x0c\n\x05\x06\0\x02\x1c\x02\x12\x03'\x190\n\x0c\n\x05\x06\0\x02\x1c\x06\
    \x12\x03';A\n\x0c\n\x05\x06\0\x02\x1c\x03\x12\x03'BY\n\x0b\n\x04\x06\0\
    \x02\x1d\x12\x03(\x04R\n\x0c\n\x05\x06\0\x02\x1d\x01\x12\x03(\x08\x17\n\
    \x0c\n\x05\x06\0\x02\x1d\x02\x12\x03(\x18&\n\x0c\n\x05\x06\0\x02\x1d\x06\
    \x12\x03(17\n\x0c\n\x05\x06\0\x02\x1d\x03\x12\x03(8N\n\x0b\n\x04\x06\0\
    \x02\x1e\x12\x03)\x04C\n\x0c\n\x05\x06\0\x02\x1e\x01\x12\x03)\x08\x11\n\
    \x0c\n\x05\x06\0\x02\x1e\x02\x12\x03)\x12\x1d\n\x0c\n\x05\x06\0\x02\x1e\
    \x06\x12\x03)(.\n\x0c\n\x05\x06\0\x02\x1e\x03\x12\x03)/?\n\x0b\n\x04\x06\
    \0\x02\x1f\x12\x03*\x04W\n\x0c\n\x05\x06\0\x02\x1f\x01\x12\x03*\x08\x12\
    \n\x0c\n\x05\x06\0\x02\x1f\x05\x12\x03*\x13\x19\n\x0c\n\x05\x06\0\x02\
    \x1f\x02\x12\x03*\x1a+\n\x0c\n\x05\x06\0\x02\x1f\x06\x12\x03*6<\n\x0c\n\
    \x05\x06\0\x02\x1f\x03\x12\x03*=S\n\x0b\n\x04\x06\0\x02\x20\x12\x03+\x04\
    c\n\x0c\n\x05\x06\0\x02\x20\x01\x12\x03+\x08\x18\n\x0c\n\x05\x06\0\x02\
    \x20\x05\x12\x03+\x19\x1f\n\x0c\n\x05\x06\0\x02\x20\x02\x12\x03+\x207\n\
    \x0c\n\x05\x06\0\x02\x20\x06\x12\x03+BH\n\x0c\n\x05\x06\0\x02\x20\x03\
    \x12\x03+I_\n\t\n\x02\x04\0\x12\x03.\0\x10\n\n\n\x03\x04\0\x01\x12\x03.\
    \x08\r\n\n\n\x02\x04\x01\x12\x040\06\x01\n\n\n\x03\x04\x01\x01\x12\x030\
    \x08\x1d\n\x0b\n\x04\x04\x01\x02\0\x12\x031\x04\x17\n\r\n\x05\x04\x01\
    \x02\0\x04\x12\x041\x040\x1f\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x031\x04\
    \n\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x031\x0b\x12\n\x0c\n\x05\x04\x01\
    \x02\0\x03\x12\x031\x15\x16\n\x0b\n\x04\x04\x01\x02\x01\x12\x032\x04\x1a\
    \n\r\n\x05\x04\x01\x02\x01\x04\x12\x042\x041\x17\n\x0c\n\x05\x04\x01\x02\
    \x01\x05\x12\x032\x04\n\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x032\x0b\x15\
    \n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x032\x18\x19\n\x0b\n\x04\x04\x01\
    \x02\x02\x12\x033\x04\x18\n\r\n\x05\x04\x01\x02\x02\x04\x12\x043\x042\
    \x1a\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x033\x04\n\n\x0c\n\x05\x04\x01\
    \x02\x02\x01\x12\x033\x0b\x13\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x033\
    \x16\x17\n\x0b\n\x04\x04\x01\x02\x03\x12\x034\x04#\n\r\n\x05\x04\x01\x02\
    \x03\x04\x12\x044\x043\x18\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x034\x04\
    \x17\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x034\x18\x1e\n\x0c\n\x05\x04\
    \x01\x02\x03\x03\x12\x034!\"\n\x0b\n\x04\x04\x01\x02\x04\x12\x035\x04\
    \x14\n\r\n\x05\x04\x01\x02\x04\x04\x12\x045\x044#\n\x0c\n\x05\x04\x01\
    \x02\x04\x05\x12\x035\x04\t\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x035\n\
    \x0f\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x035\x12\x13\n.\n\x02\x04\x02\
    \x12\x049\0<\x01\x1a\"\x20\xe5\xaf\xb9\xe7\x9a\x84,\x20protobuf\x20\xe5\
    \xb0\xb1\xe6\x98\xaf\xe8\xbf\x99\xe6\xa0\xb7...\n\n\n\n\x03\x04\x02\x01\
    \x12\x039\x08\x0b\n\x0b\n\x04\x04\x02\x02\0\x12\x03:\x04\x14\n\r\n\x05\
    \x04\x02\x02\0\x04\x12\x04:\x049\r\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\
    :\x04\n\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03:\x0b\x0f\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03:\x12\x13\n\x0b\n\x04\x04\x02\x02\x01\x12\x03;\x04\
    \x14\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04;\x04:\x14\n\x0c\n\x05\x04\x02\
    \x02\x01\x05\x12\x03;\x04\n\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03;\x0b\
    \x0f\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03;\x12\x13\n\n\n\x02\x04\x03\
    \x12\x04>\0@\x01\n\n\n\x03\x04\x03\x01\x12\x03>\x08\x0c\n\x0b\n\x04\x04\
    \x03\x02\0\x12\x03?\x04\x1a\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03?\x04\
    \x0c\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03?\r\x10\n\x0c\n\x05\x04\x03\
    \x02\0\x01\x12\x03?\x11\x15\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03?\x18\
    \x19\n\n\n\x02\x04\x04\x12\x04B\0I\x01\n\n\n\x03\x04\x04\x01\x12\x03B\
    \x08\x13\n\x0b\n\x04\x04\x04\x02\0\x12\x03C\x04\x14\n\r\n\x05\x04\x04\
    \x02\0\x04\x12\x04C\x04B\x15\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03C\x04\
    \n\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03C\x0b\x0f\n\x0c\n\x05\x04\x04\
    \x02\0\x03\x12\x03C\x12\x13\n\x0b\n\x04\x04\x04\x02\x01\x12\x03D\x04(\n\
    \r\n\x05\x04\x04\x02\x01\x04\x12\x04D\x04C\x14\n\x0c\n\x05\x04\x04\x02\
    \x01\x06\x12\x03D\x04\x16\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03D\x17#\
    \n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03D&'\n\x0b\n\x04\x04\x04\x02\x02\
    \x12\x03E\x04+\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04E\x04D(\n\x0c\n\x05\
    \x04\x04\x02\x02\x06\x12\x03E\x04\x16\n\x0c\n\x05\x04\x04\x02\x02\x01\
    \x12\x03E\x17&\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03E)*\n\x0b\n\x04\
    \x04\x04\x02\x03\x12\x03F\x04(\n\r\n\x05\x04\x04\x02\x03\x04\x12\x04F\
    \x04E+\n\x0c\n\x05\x04\x04\x02\x03\x06\x12\x03F\x04\x15\n\x0c\n\x05\x04\
    \x04\x02\x03\x01\x12\x03F\x16#\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03F&\
    '\n\x0b\n\x04\x04\x04\x02\x04\x12\x03G\x04$\n\r\n\x05\x04\x04\x02\x04\
    \x04\x12\x04G\x04F(\n\x0c\n\x05\x04\x04\x02\x04\x06\x12\x03G\x04\x17\n\
    \x0c\n\x05\x04\x04\x02\x04\x01\x12\x03G\x18\x1f\n\x0c\n\x05\x04\x04\x02\
    \x04\x03\x12\x03G\"#\n\x0b\n\x04\x04\x04\x02\x05\x12\x03H\x04-\n\r\n\x05\
    \x04\x04\x02\x05\x04\x12\x04H\x04G$\n\x0c\n\x05\x04\x04\x02\x05\x06\x12\
    \x03H\x04\x17\n\x0c\n\x05\x04\x04\x02\x05\x01\x12\x03H\x18(\n\x0c\n\x05\
    \x04\x04\x02\x05\x03\x12\x03H+,\n\n\n\x02\x04\x05\x12\x04K\0R\x01\n\n\n\
    \x03\x04\x05\x01\x12\x03K\x08\x14\n\x0b\n\x04\x04\x05\x02\0\x12\x03L\x04\
    \x14\n\r\n\x05\x04\x05\x02\0\x04\x12\x04L\x04K\x16\n\x0c\n\x05\x04\x05\
    \x02\0\x05\x12\x03L\x04\n\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03L\x0b\x0f\
    \n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03L\x12\x13\n\x0b\n\x04\x04\x05\x02\
    \x01\x12\x03M\x04\x1b\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04M\x04L\x14\n\
    \x0c\n\x05\x04\x05\x02\x01\x05\x12\x03M\x04\n\n\x0c\n\x05\x04\x05\x02\
    \x01\x01\x12\x03M\x0b\x16\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03M\x19\
    \x1a\n\x0b\n\x04\x04\x05\x02\x02\x12\x03N\x04\x1e\n\r\n\x05\x04\x05\x02\
    \x02\x04\x12\x04N\x04M\x1b\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x03N\x04\
    \n\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03N\x0b\x19\n\x0c\n\x05\x04\x05\
    \x02\x02\x03\x12\x03N\x1c\x1d\n\x0b\n\x04\x04\x05\x02\x03\x12\x03O\x04\
    \x1a\n\r\n\x05\x04\x05\x02\x03\x04\x12\x04O\x04N\x1e\n\x0c\n\x05\x04\x05\
    \x02\x03\x05\x12\x03O\x04\x08\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03O\t\
    \x15\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03O\x18\x19\n\x0b\n\x04\x04\
    \x05\x02\x04\x12\x03P\x04\x20\n\x0c\n\x05\x04\x05\x02\x04\x04\x12\x03P\
    \x04\x0c\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\x03P\r\x13\n\x0c\n\x05\x04\
    \x05\x02\x04\x01\x12\x03P\x14\x1b\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\
    \x03P\x1e\x1f\n\x0b\n\x04\x04\x05\x02\x05\x12\x03Q\x04\x1f\n\r\n\x05\x04\
    \x05\x02\x05\x04\x12\x04Q\x04P\x20\n\x0c\n\x05\x04\x05\x02\x05\x05\x12\
    \x03Q\x04\n\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03Q\x0b\x1a\n\x0c\n\x05\
    \x04\x05\x02\x05\x03\x12\x03Q\x1d\x1e\n\n\n\x02\x04\x06\x12\x04T\0W\x01\
    \n\n\n\x03\x04\x06\x01\x12\x03T\x08\x1a\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03U\x04\x17\n\r\n\x05\x04\x06\x02\0\x04\x12\x04U\x04T\x1c\n\x0c\n\x05\
    \x04\x06\x02\0\x05\x12\x03U\x04\n\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03U\
    \x0b\x12\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03U\x15\x16\n\x0b\n\x04\x04\
    \x06\x02\x01\x12\x03V\x04\x16\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04V\x04\
    U\x17\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03V\x04\n\n\x0c\n\x05\x04\x06\
    \x02\x01\x01\x12\x03V\x0b\x11\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03V\
    \x14\x15\n\n\n\x02\x04\x07\x12\x04Y\0\\\x01\n\n\n\x03\x04\x07\x01\x12\
    \x03Y\x08\x0f\n\x0b\n\x04\x04\x07\x02\0\x12\x03Z\x04\x14\n\r\n\x05\x04\
    \x07\x02\0\x04\x12\x04Z\x04Y\x11\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03Z\
    \x04\n\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03Z\x0b\x0f\n\x0c\n\x05\x04\
    \x07\x02\0\x03\x12\x03Z\x12\x13\n\x0b\n\x04\x04\x07\x02\x01\x12\x03[\x04\
    \x20\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03[\x04\x0c\n\x0c\n\x05\x04\
    \x07\x02\x01\x05\x12\x03[\r\x13\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03[\
    \x14\x1b\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03[\x1e\x1f\n\n\n\x02\x04\
    \x08\x12\x04^\0`\x01\n\n\n\x03\x04\x08\x01\x12\x03^\x08\x10\n\x0b\n\x04\
    \x04\x08\x02\0\x12\x03_\x04\"\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03_\x04\
    \x0c\n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03_\r\x14\n\x0c\n\x05\x04\x08\
    \x02\0\x01\x12\x03_\x15\x1d\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03_\x20!\
    \n\n\n\x02\x04\t\x12\x04b\0t\x01\n\n\n\x03\x04\t\x01\x12\x03b\x08\x0c\n\
    \x0b\n\x04\x04\t\x02\0\x12\x03c\x04\x14\n\r\n\x05\x04\t\x02\0\x04\x12\
    \x04c\x04b\x0e\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03c\x04\n\n\x0c\n\x05\
    \x04\t\x02\0\x01\x12\x03c\x0b\x0f\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03c\
    \x12\x13\n\x0b\n\x04\x04\t\x02\x01\x12\x03d\x04\x18\n\r\n\x05\x04\t\x02\
    \x01\x04\x12\x04d\x04c\x14\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03d\x04\n\
    \n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03d\x0b\x13\n\x0c\n\x05\x04\t\x02\
    \x01\x03\x12\x03d\x16\x17\n\x0b\n\x04\x04\t\x02\x02\x12\x03e\x04\x17\n\r\
    \n\x05\x04\t\x02\x02\x04\x12\x04e\x04d\x18\n\x0c\n\x05\x04\t\x02\x02\x05\
    \x12\x03e\x04\n\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03e\x0b\x12\n\x0c\n\
    \x05\x04\t\x02\x02\x03\x12\x03e\x15\x16\n\x0b\n\x04\x04\t\x02\x03\x12\
    \x03f\x04\x1f\n\r\n\x05\x04\t\x02\x03\x04\x12\x04f\x04e\x17\n\x0c\n\x05\
    \x04\t\x02\x03\x06\x12\x03f\x04\x16\n\x0c\n\x05\x04\t\x02\x03\x01\x12\
    \x03f\x17\x1a\n\x0c\n\x05\x04\t\x02\x03\x03\x12\x03f\x1d\x1e\n\x0b\n\x04\
    \x04\t\x02\x04\x12\x03g\x04\x17\n\r\n\x05\x04\t\x02\x04\x04\x12\x04g\x04\
    f\x1f\n\x0c\n\x05\x04\t\x02\x04\x05\x12\x03g\x04\n\n\x0c\n\x05\x04\t\x02\
    \x04\x01\x12\x03g\x0b\x13\n\x0c\n\x05\x04\t\x02\x04\x03\x12\x03g\x15\x16\
    \n\x0b\n\x04\x04\t\x02\x05\x12\x03h\x04\x15\n\r\n\x05\x04\t\x02\x05\x04\
    \x12\x04h\x04g\x17\n\x0c\n\x05\x04\t\x02\x05\x05\x12\x03h\x04\t\n\x0c\n\
    \x05\x04\t\x02\x05\x01\x12\x03h\n\x10\n\x0c\n\x05\x04\t\x02\x05\x03\x12\
    \x03h\x13\x14\n\x0b\n\x04\x04\t\x02\x06\x12\x03i\x04\x1a\n\r\n\x05\x04\t\
    \x02\x06\x04\x12\x04i\x04h\x15\n\x0c\n\x05\x04\t\x02\x06\x05\x12\x03i\
    \x04\t\n\x0c\n\x05\x04\t\x02\x06\x01\x12\x03i\n\x15\n\x0c\n\x05\x04\t\
    \x02\x06\x03\x12\x03i\x18\x19\n\x0b\n\x04\x04\t\x02\x07\x12\x03j\x04\x17\
    \n\r\n\x05\x04\t\x02\x07\x04\x12\x04j\x04i\x1a\n\x0c\n\x05\x04\t\x02\x07\
    \x05\x12\x03j\x04\x08\n\x0c\n\x05\x04\t\x02\x07\x01\x12\x03j\t\x12\n\x0c\
    \n\x05\x04\t\x02\x07\x03\x12\x03j\x15\x16\n\x0b\n\x04\x04\t\x02\x08\x12\
    \x03k\x04#\n\r\n\x05\x04\t\x02\x08\x04\x12\x04k\x04j\x17\n\x0c\n\x05\x04\
    \t\x02\x08\x06\x12\x03k\x04\x17\n\x0c\n\x05\x04\t\x02\x08\x01\x12\x03k\
    \x18\x1e\n\x0c\n\x05\x04\t\x02\x08\x03\x12\x03k!\"\n\x0b\n\x04\x04\t\x02\
    \t\x12\x03l\x04\x1b\n\r\n\x05\x04\t\x02\t\x04\x12\x04l\x04k#\n\x0c\n\x05\
    \x04\t\x02\t\x05\x12\x03l\x04\t\n\x0c\n\x05\x04\t\x02\t\x01\x12\x03l\n\
    \x15\n\x0c\n\x05\x04\t\x02\t\x03\x12\x03l\x18\x1a\n\x0b\n\x04\x04\t\x02\
    \n\x12\x03m\x04%\n\r\n\x05\x04\t\x02\n\x04\x12\x04m\x04l\x1b\n\x0c\n\x05\
    \x04\t\x02\n\x06\x12\x03m\x04\x16\n\x0c\n\x05\x04\t\x02\n\x01\x12\x03m\
    \x17\x1f\n\x0c\n\x05\x04\t\x02\n\x03\x12\x03m\"$\n\x0b\n\x04\x04\t\x02\
    \x0b\x12\x03n\x04\x15\n\r\n\x05\x04\t\x02\x0b\x04\x12\x04n\x04m%\n\x0c\n\
    \x05\x04\t\x02\x0b\x05\x12\x03n\x04\n\n\x0c\n\x05\x04\t\x02\x0b\x01\x12\
    \x03n\x0b\x0f\n\x0c\n\x05\x04\t\x02\x0b\x03\x12\x03n\x12\x14\n\x0b\n\x04\
    \x04\t\x02\x0c\x12\x03o\x04\"\n\r\n\x05\x04\t\x02\x0c\x04\x12\x04o\x04n\
    \x15\n\x0c\n\x05\x04\t\x02\x0c\x06\x12\x03o\x04\x17\n\x0c\n\x05\x04\t\
    \x02\x0c\x01\x12\x03o\x18\x1c\n\x0c\n\x05\x04\t\x02\x0c\x03\x12\x03o\x1f\
    !\n\x0b\n\x04\x04\t\x02\r\x12\x03p\x04(\n\r\n\x05\x04\t\x02\r\x04\x12\
    \x04p\x04o\"\n\x0c\n\x05\x04\t\x02\r\x06\x12\x03p\x04\x16\n\x0c\n\x05\
    \x04\t\x02\r\x01\x12\x03p\x17\"\n\x0c\n\x05\x04\t\x02\r\x03\x12\x03p%'\n\
    \x0b\n\x04\x04\t\x02\x0e\x12\x03q\x04\x17\n\r\n\x05\x04\t\x02\x0e\x04\
    \x12\x04q\x04p(\n\x0c\n\x05\x04\t\x02\x0e\x05\x12\x03q\x04\t\n\x0c\n\x05\
    \x04\t\x02\x0e\x01\x12\x03q\n\x11\n\x0c\n\x05\x04\t\x02\x0e\x03\x12\x03q\
    \x14\x16\n\x0b\n\x04\x04\t\x02\x0f\x12\x03r\x04\x1c\n\r\n\x05\x04\t\x02\
    \x0f\x04\x12\x04r\x04q\x17\n\x0c\n\x05\x04\t\x02\x0f\x05\x12\x03r\x04\t\
    \n\x0c\n\x05\x04\t\x02\x0f\x01\x12\x03r\n\x16\n\x0c\n\x05\x04\t\x02\x0f\
    \x03\x12\x03r\x19\x1b\n\x0b\n\x04\x04\t\x02\x10\x12\x03s\x04\x1c\n\r\n\
    \x05\x04\t\x02\x10\x04\x12\x04s\x04r\x1c\n\x0c\n\x05\x04\t\x02\x10\x05\
    \x12\x03s\x04\t\n\x0c\n\x05\x04\t\x02\x10\x01\x12\x03s\n\x16\n\x0c\n\x05\
    \x04\t\x02\x10\x03\x12\x03s\x19\x1b\n\n\n\x02\x04\n\x12\x04v\0x\x01\n\n\
    \n\x03\x04\n\x01\x12\x03v\x08\r\n\x0b\n\x04\x04\n\x02\0\x12\x03w\x04\x1c\
    \n\x0c\n\x05\x04\n\x02\0\x04\x12\x03w\x04\x0c\n\x0c\n\x05\x04\n\x02\0\
    \x06\x12\x03w\r\x11\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03w\x12\x17\n\x0c\n\
    \x05\x04\n\x02\0\x03\x12\x03w\x1a\x1b\n\n\n\x02\x04\x0b\x12\x04z\0}\x01\
    \n\n\n\x03\x04\x0b\x01\x12\x03z\x08\x15\n\x0b\n\x04\x04\x0b\x02\0\x12\
    \x03{\x04\x18\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04{\x04z\x17\n\x0c\n\x05\
    \x04\x0b\x02\0\x05\x12\x03{\x04\n\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03{\
    \x0b\x13\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03{\x16\x17\n\x0b\n\x04\x04\
    \x0b\x02\x01\x12\x03|\x04\x17\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04|\x04\
    {\x18\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03|\x04\n\n\x0c\n\x05\x04\x0b\
    \x02\x01\x01\x12\x03|\x0b\x12\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03|\
    \x15\x16\n\x0b\n\x02\x04\x0c\x12\x05\x7f\0\x88\x01\x01\n\n\n\x03\x04\x0c\
    \x01\x12\x03\x7f\x08\x16\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x80\x01\x04\
    \x18\n\x0e\n\x05\x04\x0c\x02\0\x04\x12\x05\x80\x01\x04\x7f\x18\n\r\n\x05\
    \x04\x0c\x02\0\x05\x12\x04\x80\x01\x04\n\n\r\n\x05\x04\x0c\x02\0\x01\x12\
    \x04\x80\x01\x0b\x13\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\x80\x01\x16\x17\
    \n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\x81\x01\x04\x15\n\x0f\n\x05\x04\x0c\
    \x02\x01\x04\x12\x06\x81\x01\x04\x80\x01\x18\n\r\n\x05\x04\x0c\x02\x01\
    \x05\x12\x04\x81\x01\x04\t\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\x81\x01\
    \n\x10\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\x81\x01\x13\x14\n\x0c\n\x04\
    \x04\x0c\x02\x02\x12\x04\x82\x01\x04%\n\x0f\n\x05\x04\x0c\x02\x02\x04\
    \x12\x06\x82\x01\x04\x81\x01\x15\n\r\n\x05\x04\x0c\x02\x02\x06\x12\x04\
    \x82\x01\x04\x16\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\x82\x01\x17\x20\n\
    \r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x82\x01#$\n\x0c\n\x04\x04\x0c\x02\
    \x03\x12\x04\x83\x01\x04\x1b\n\x0f\n\x05\x04\x0c\x02\x03\x04\x12\x06\x83\
    \x01\x04\x82\x01%\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\x83\x01\x04\t\n\
    \r\n\x05\x04\x0c\x02\x03\x01\x12\x04\x83\x01\n\x16\n\r\n\x05\x04\x0c\x02\
    \x03\x03\x12\x04\x83\x01\x19\x1a\n\x0c\n\x04\x04\x0c\x02\x04\x12\x04\x84\
    \x01\x04\x1c\n\x0f\n\x05\x04\x0c\x02\x04\x04\x12\x06\x84\x01\x04\x83\x01\
    \x1b\n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\x84\x01\x04\t\n\r\n\x05\x04\
    \x0c\x02\x04\x01\x12\x04\x84\x01\n\x17\n\r\n\x05\x04\x0c\x02\x04\x03\x12\
    \x04\x84\x01\x1a\x1b\n\x0c\n\x04\x04\x0c\x02\x05\x12\x04\x85\x01\x04-\n\
    \x0f\n\x05\x04\x0c\x02\x05\x04\x12\x06\x85\x01\x04\x84\x01\x1c\n\r\n\x05\
    \x04\x0c\x02\x05\x06\x12\x04\x85\x01\x04\x16\n\r\n\x05\x04\x0c\x02\x05\
    \x01\x12\x04\x85\x01\x17(\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\x85\x01+\
    ,\n\x0c\n\x04\x04\x0c\x02\x06\x12\x04\x86\x01\x04!\n\x0f\n\x05\x04\x0c\
    \x02\x06\x04\x12\x06\x86\x01\x04\x85\x01-\n\r\n\x05\x04\x0c\x02\x06\x06\
    \x12\x04\x86\x01\x04\x17\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\x86\x01\
    \x18\x1c\n\r\n\x05\x04\x0c\x02\x06\x03\x12\x04\x86\x01\x1f\x20\n\x0c\n\
    \x04\x04\x0c\x02\x07\x12\x04\x87\x01\x04#\n\x0f\n\x05\x04\x0c\x02\x07\
    \x04\x12\x06\x87\x01\x04\x86\x01!\n\r\n\x05\x04\x0c\x02\x07\x06\x12\x04\
    \x87\x01\x04\x17\n\r\n\x05\x04\x0c\x02\x07\x01\x12\x04\x87\x01\x18\x1e\n\
    \r\n\x05\x04\x0c\x02\x07\x03\x12\x04\x87\x01!\"\n\x0c\n\x02\x04\r\x12\
    \x06\x8a\x01\0\x98\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x8a\x01\x08\x11\
    \n\x0c\n\x04\x04\r\x02\0\x12\x04\x8b\x01\x04\x12\n\x0f\n\x05\x04\r\x02\0\
    \x04\x12\x06\x8b\x01\x04\x8a\x01\x13\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \x8b\x01\x04\n\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x8b\x01\x0b\r\n\r\n\x05\
    \x04\r\x02\0\x03\x12\x04\x8b\x01\x10\x11\n\x0c\n\x04\x04\r\x02\x01\x12\
    \x04\x8c\x01\x04\x17\n\x0f\n\x05\x04\r\x02\x01\x04\x12\x06\x8c\x01\x04\
    \x8b\x01\x12\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x8c\x01\x04\n\n\r\n\x05\
    \x04\r\x02\x01\x01\x12\x04\x8c\x01\x0b\x12\n\r\n\x05\x04\r\x02\x01\x03\
    \x12\x04\x8c\x01\x15\x16\n\x0c\n\x04\x04\r\x02\x02\x12\x04\x8d\x01\x04\
    \x18\n\x0f\n\x05\x04\r\x02\x02\x04\x12\x06\x8d\x01\x04\x8c\x01\x17\n\r\n\
    \x05\x04\r\x02\x02\x05\x12\x04\x8d\x01\x04\n\n\r\n\x05\x04\r\x02\x02\x01\
    \x12\x04\x8d\x01\x0b\x13\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\x8d\x01\x16\
    \x17\n\x0c\n\x04\x04\r\x02\x03\x12\x04\x8e\x01\x04\x14\n\x0f\n\x05\x04\r\
    \x02\x03\x04\x12\x06\x8e\x01\x04\x8d\x01\x18\n\r\n\x05\x04\r\x02\x03\x05\
    \x12\x04\x8e\x01\x04\n\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\x8e\x01\x0b\
    \x0f\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\x8e\x01\x12\x13\n\x0c\n\x04\x04\
    \r\x02\x04\x12\x04\x8f\x01\x04\x1f\n\x0f\n\x05\x04\r\x02\x04\x04\x12\x06\
    \x8f\x01\x04\x8e\x01\x14\n\r\n\x05\x04\r\x02\x04\x06\x12\x04\x8f\x01\x04\
    \x16\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\x8f\x01\x17\x1a\n\r\n\x05\x04\r\
    \x02\x04\x03\x12\x04\x8f\x01\x1d\x1e\n\x0c\n\x04\x04\r\x02\x05\x12\x04\
    \x90\x01\x04\x15\n\x0f\n\x05\x04\r\x02\x05\x04\x12\x06\x90\x01\x04\x8f\
    \x01\x1f\n\r\n\x05\x04\r\x02\x05\x05\x12\x04\x90\x01\x04\n\n\r\n\x05\x04\
    \r\x02\x05\x01\x12\x04\x90\x01\x0b\x10\n\r\n\x05\x04\r\x02\x05\x03\x12\
    \x04\x90\x01\x13\x14\n\x0c\n\x04\x04\r\x02\x06\x12\x04\x91\x01\x04\x15\n\
    \x0f\n\x05\x04\r\x02\x06\x04\x12\x06\x91\x01\x04\x90\x01\x15\n\r\n\x05\
    \x04\r\x02\x06\x05\x12\x04\x91\x01\x04\t\n\r\n\x05\x04\r\x02\x06\x01\x12\
    \x04\x91\x01\n\x10\n\r\n\x05\x04\r\x02\x06\x03\x12\x04\x91\x01\x13\x14\n\
    \x0c\n\x04\x04\r\x02\x07\x12\x04\x92\x01\x04\x18\n\x0f\n\x05\x04\r\x02\
    \x07\x04\x12\x06\x92\x01\x04\x91\x01\x15\n\r\n\x05\x04\r\x02\x07\x05\x12\
    \x04\x92\x01\x04\x08\n\r\n\x05\x04\r\x02\x07\x01\x12\x04\x92\x01\t\x13\n\
    \r\n\x05\x04\r\x02\x07\x03\x12\x04\x92\x01\x16\x17\n\x0c\n\x04\x04\r\x02\
    \x08\x12\x04\x93\x01\x04#\n\x0f\n\x05\x04\r\x02\x08\x04\x12\x06\x93\x01\
    \x04\x92\x01\x18\n\r\n\x05\x04\r\x02\x08\x06\x12\x04\x93\x01\x04\x17\n\r\
    \n\x05\x04\r\x02\x08\x01\x12\x04\x93\x01\x18\x1e\n\r\n\x05\x04\r\x02\x08\
    \x03\x12\x04\x93\x01!\"\n\x0c\n\x04\x04\r\x02\t\x12\x04\x94\x01\x04%\n\
    \x0f\n\x05\x04\r\x02\t\x04\x12\x06\x94\x01\x04\x93\x01#\n\r\n\x05\x04\r\
    \x02\t\x06\x12\x04\x94\x01\x04\x17\n\r\n\x05\x04\r\x02\t\x01\x12\x04\x94\
    \x01\x18\x1f\n\r\n\x05\x04\r\x02\t\x03\x12\x04\x94\x01\"$\n\x0c\n\x04\
    \x04\r\x02\n\x12\x04\x95\x01\x04\x16\n\x0f\n\x05\x04\r\x02\n\x04\x12\x06\
    \x95\x01\x04\x94\x01%\n\r\n\x05\x04\r\x02\n\x05\x12\x04\x95\x01\x04\n\n\
    \r\n\x05\x04\r\x02\n\x01\x12\x04\x95\x01\x0b\x10\n\r\n\x05\x04\r\x02\n\
    \x03\x12\x04\x95\x01\x13\x15\n\x0c\n\x04\x04\r\x02\x0b\x12\x04\x96\x01\
    \x04\x17\n\x0f\n\x05\x04\r\x02\x0b\x04\x12\x06\x96\x01\x04\x95\x01\x16\n\
    \r\n\x05\x04\r\x02\x0b\x05\x12\x04\x96\x01\x04\t\n\r\n\x05\x04\r\x02\x0b\
    \x01\x12\x04\x96\x01\n\x11\n\r\n\x05\x04\r\x02\x0b\x03\x12\x04\x96\x01\
    \x14\x16\n\x0c\n\x04\x04\r\x02\x0c\x12\x04\x97\x01\x04\x20\n\x0f\n\x05\
    \x04\r\x02\x0c\x04\x12\x06\x97\x01\x04\x96\x01\x17\n\r\n\x05\x04\r\x02\
    \x0c\x06\x12\x04\x97\x01\x04\x13\n\r\n\x05\x04\r\x02\x0c\x01\x12\x04\x97\
    \x01\x14\x1a\n\r\n\x05\x04\r\x02\x0c\x03\x12\x04\x97\x01\x1d\x1f\n\x0c\n\
    \x02\x04\x0e\x12\x06\x9a\x01\0\xa1\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\
    \x04\x9a\x01\x08\x17\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x9b\x01\x04\x12\n\
    \x0f\n\x05\x04\x0e\x02\0\x04\x12\x06\x9b\x01\x04\x9a\x01\x19\n\r\n\x05\
    \x04\x0e\x02\0\x05\x12\x04\x9b\x01\x04\n\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\x9b\x01\x0b\r\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x9b\x01\x10\x11\n\
    \x0c\n\x04\x04\x0e\x02\x01\x12\x04\x9c\x01\x04\x15\n\x0f\n\x05\x04\x0e\
    \x02\x01\x04\x12\x06\x9c\x01\x04\x9b\x01\x12\n\r\n\x05\x04\x0e\x02\x01\
    \x05\x12\x04\x9c\x01\x04\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\x9c\
    \x01\t\x10\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x9c\x01\x13\x14\n\x0c\n\
    \x04\x04\x0e\x02\x02\x12\x04\x9d\x01\x04\x15\n\x0f\n\x05\x04\x0e\x02\x02\
    \x04\x12\x06\x9d\x01\x04\x9c\x01\x15\n\r\n\x05\x04\x0e\x02\x02\x05\x12\
    \x04\x9d\x01\x04\x08\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\x9d\x01\t\x10\
    \n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x9d\x01\x13\x14\n\x0c\n\x04\x04\
    \x0e\x02\x03\x12\x04\x9e\x01\x04%\n\x0f\n\x05\x04\x0e\x02\x03\x04\x12\
    \x06\x9e\x01\x04\x9d\x01\x15\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\x9e\
    \x01\x04\x17\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\x9e\x01\x18\x20\n\r\n\
    \x05\x04\x0e\x02\x03\x03\x12\x04\x9e\x01#$\n\x0c\n\x04\x04\x0e\x02\x04\
    \x12\x04\x9f\x01\x04\x18\n\x0f\n\x05\x04\x0e\x02\x04\x04\x12\x06\x9f\x01\
    \x04\x9e\x01%\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\x9f\x01\x04\t\n\r\n\
    \x05\x04\x0e\x02\x04\x01\x12\x04\x9f\x01\n\x13\n\r\n\x05\x04\x0e\x02\x04\
    \x03\x12\x04\x9f\x01\x16\x17\n\x0c\n\x04\x04\x0e\x02\x05\x12\x04\xa0\x01\
    \x04\x12\n\x0f\n\x05\x04\x0e\x02\x05\x04\x12\x06\xa0\x01\x04\x9f\x01\x18\
    \n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xa0\x01\x04\t\n\r\n\x05\x04\x0e\
    \x02\x05\x01\x12\x04\xa0\x01\n\r\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\
    \xa0\x01\x10\x11\n\x0c\n\x02\x04\x0f\x12\x06\xa3\x01\0\xa5\x01\x01\n\x0b\
    \n\x03\x04\x0f\x01\x12\x04\xa3\x01\x08\x18\n\x0c\n\x04\x04\x0f\x02\0\x12\
    \x04\xa4\x01\x04(\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xa4\x01\x04\x0c\n\
    \r\n\x05\x04\x0f\x02\0\x06\x12\x04\xa4\x01\r\x1c\n\r\n\x05\x04\x0f\x02\0\
    \x01\x12\x04\xa4\x01\x1d#\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xa4\x01&'\
    \n\x0c\n\x02\x04\x10\x12\x06\xa7\x01\0\xad\x01\x01\n\x0b\n\x03\x04\x10\
    \x01\x12\x04\xa7\x01\x08$\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xa8\x01\x04\
    \x12\n\x0f\n\x05\x04\x10\x02\0\x04\x12\x06\xa8\x01\x04\xa7\x01&\n\r\n\
    \x05\x04\x10\x02\0\x05\x12\x04\xa8\x01\x04\n\n\r\n\x05\x04\x10\x02\0\x01\
    \x12\x04\xa8\x01\x0b\r\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa8\x01\x10\
    \x11\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xa9\x01\x04\x1c\n\x0f\n\x05\x04\
    \x10\x02\x01\x04\x12\x06\xa9\x01\x04\xa8\x01\x12\n\r\n\x05\x04\x10\x02\
    \x01\x06\x12\x04\xa9\x01\x04\r\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xa9\
    \x01\x0e\x17\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xa9\x01\x1a\x1b\n\x0c\
    \n\x04\x04\x10\x02\x02\x12\x04\xaa\x01\x04\x1f\n\x0f\n\x05\x04\x10\x02\
    \x02\x04\x12\x06\xaa\x01\x04\xa9\x01\x1c\n\r\n\x05\x04\x10\x02\x02\x06\
    \x12\x04\xaa\x01\x04\x13\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xaa\x01\
    \x14\x1a\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xaa\x01\x1d\x1e\n\x0c\n\
    \x04\x04\x10\x02\x03\x12\x04\xab\x01\x04\x15\n\x0f\n\x05\x04\x10\x02\x03\
    \x04\x12\x06\xab\x01\x04\xaa\x01\x1f\n\r\n\x05\x04\x10\x02\x03\x05\x12\
    \x04\xab\x01\x04\n\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xab\x01\x0b\x10\
    \n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xab\x01\x13\x14\n\x0c\n\x04\x04\
    \x10\x02\x04\x12\x04\xac\x01\x04\x14\n\x0f\n\x05\x04\x10\x02\x04\x04\x12\
    \x06\xac\x01\x04\xab\x01\x15\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xac\
    \x01\x04\x08\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\xac\x01\t\x0f\n\r\n\
    \x05\x04\x10\x02\x04\x03\x12\x04\xac\x01\x12\x13\n\x0c\n\x02\x04\x11\x12\
    \x06\xaf\x01\0\xb1\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xaf\x01\x08\"\
    \n\x0c\n\x04\x04\x11\x02\0\x12\x04\xb0\x01\x04(\n\r\n\x05\x04\x11\x02\0\
    \x04\x12\x04\xb0\x01\x04\x0c\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xb0\x01\
    \r\x1c\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xb0\x01\x1d#\n\r\n\x05\x04\
    \x11\x02\0\x03\x12\x04\xb0\x01&'\n\x0c\n\x02\x04\x12\x12\x06\xb3\x01\0\
    \xb8\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xb3\x01\x08$\n\x0c\n\x04\
    \x04\x12\x02\0\x12\x04\xb4\x01\x04\x17\n\x0f\n\x05\x04\x12\x02\0\x04\x12\
    \x06\xb4\x01\x04\xb3\x01&\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xb4\x01\
    \x04\n\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xb4\x01\x0b\x12\n\r\n\x05\x04\
    \x12\x02\0\x03\x12\x04\xb4\x01\x15\x16\n\x0c\n\x04\x04\x12\x02\x01\x12\
    \x04\xb5\x01\x04\x1a\n\x0f\n\x05\x04\x12\x02\x01\x04\x12\x06\xb5\x01\x04\
    \xb4\x01\x17\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xb5\x01\x04\n\n\r\n\
    \x05\x04\x12\x02\x01\x01\x12\x04\xb5\x01\x0b\x15\n\r\n\x05\x04\x12\x02\
    \x01\x03\x12\x04\xb5\x01\x18\x19\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xb6\
    \x01\x04\x18\n\x0f\n\x05\x04\x12\x02\x02\x04\x12\x06\xb6\x01\x04\xb5\x01\
    \x1a\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xb6\x01\x04\n\n\r\n\x05\x04\
    \x12\x02\x02\x01\x12\x04\xb6\x01\x0b\x13\n\r\n\x05\x04\x12\x02\x02\x03\
    \x12\x04\xb6\x01\x16\x17\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xb7\x01\x04\
    #\n\x0f\n\x05\x04\x12\x02\x03\x04\x12\x06\xb7\x01\x04\xb6\x01\x18\n\r\n\
    \x05\x04\x12\x02\x03\x06\x12\x04\xb7\x01\x04\x17\n\r\n\x05\x04\x12\x02\
    \x03\x01\x12\x04\xb7\x01\x18\x1e\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\
    \xb7\x01!\"\n\x0c\n\x02\x04\x13\x12\x06\xba\x01\0\xbc\x01\x01\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\xba\x01\x08\x12\n\x0c\n\x04\x04\x13\x02\0\x12\
    \x04\xbb\x01\x04&\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xbb\x01\x04\x0c\n\
    \r\n\x05\x04\x13\x02\0\x06\x12\x04\xbb\x01\r\x16\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\xbb\x01\x17!\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xbb\x01$%\
    \n\x0c\n\x02\x04\x14\x12\x06\xbe\x01\0\xc0\x01\x01\n\x0b\n\x03\x04\x14\
    \x01\x12\x04\xbe\x01\x08\x13\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xbf\x01\
    \x04\x12\n\x0f\n\x05\x04\x14\x02\0\x04\x12\x06\xbf\x01\x04\xbe\x01\x15\n\
    \r\n\x05\x04\x14\x02\0\x05\x12\x04\xbf\x01\x04\n\n\r\n\x05\x04\x14\x02\0\
    \x01\x12\x04\xbf\x01\x0b\r\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xbf\x01\
    \x10\x11\n\x0c\n\x02\x04\x15\x12\x06\xc2\x01\0\xc4\x01\x01\n\x0b\n\x03\
    \x04\x15\x01\x12\x04\xc2\x01\x08\x14\n\x0c\n\x04\x04\x15\x02\0\x12\x04\
    \xc3\x01\x04\x1c\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xc3\x01\x04\x0c\n\r\
    \n\x05\x04\x15\x02\0\x05\x12\x04\xc3\x01\r\x13\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\xc3\x01\x14\x17\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xc3\x01\
    \x1a\x1b\n\x0c\n\x02\x04\x16\x12\x06\xc6\x01\0\xca\x01\x01\n\x0b\n\x03\
    \x04\x16\x01\x12\x04\xc6\x01\x08\x1e\n\x0c\n\x04\x04\x16\x02\0\x12\x04\
    \xc7\x01\x04\x1c\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xc7\x01\x04\x0c\n\r\
    \n\x05\x04\x16\x02\0\x05\x12\x04\xc7\x01\r\x13\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\xc7\x01\x14\x17\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xc7\x01\
    \x1a\x1b\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xc8\x01\x04\x13\n\x0f\n\x05\
    \x04\x16\x02\x01\x04\x12\x06\xc8\x01\x04\xc7\x01\x1c\n\r\n\x05\x04\x16\
    \x02\x01\x05\x12\x04\xc8\x01\x04\x08\n\r\n\x05\x04\x16\x02\x01\x01\x12\
    \x04\xc8\x01\t\x0e\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xc8\x01\x11\x12\
    \n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xc9\x01\x04\x13\n\x0f\n\x05\x04\x16\
    \x02\x02\x04\x12\x06\xc9\x01\x04\xc8\x01\x13\n\r\n\x05\x04\x16\x02\x02\
    \x05\x12\x04\xc9\x01\x04\t\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xc9\x01\
    \n\x0e\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xc9\x01\x11\x12\n\x0c\n\x02\
    \x04\x17\x12\x06\xcc\x01\0\xce\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\
    \xcc\x01\x08\"\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xcd\x01\x04\x1c\n\r\n\
    \x05\x04\x17\x02\0\x04\x12\x04\xcd\x01\x04\x0c\n\r\n\x05\x04\x17\x02\0\
    \x05\x12\x04\xcd\x01\r\x13\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xcd\x01\
    \x14\x17\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xcd\x01\x1a\x1b\n\x0c\n\x02\
    \x04\x18\x12\x06\xd0\x01\0\xd4\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \xd0\x01\x08\x16\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xd1\x01\x04\x1c\n\r\n\
    \x05\x04\x18\x02\0\x04\x12\x04\xd1\x01\x04\x0c\n\r\n\x05\x04\x18\x02\0\
    \x05\x12\x04\xd1\x01\r\x13\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xd1\x01\
    \x14\x17\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xd1\x01\x1a\x1b\n\x0c\n\x04\
    \x04\x18\x02\x01\x12\x04\xd2\x01\x04\x13\n\x0f\n\x05\x04\x18\x02\x01\x04\
    \x12\x06\xd2\x01\x04\xd1\x01\x1c\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\
    \xd2\x01\x04\n\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xd2\x01\x0b\x0e\n\r\
    \n\x05\x04\x18\x02\x01\x03\x12\x04\xd2\x01\x11\x12\n\x0c\n\x04\x04\x18\
    \x02\x02\x12\x04\xd3\x01\x04\x15\n\x0f\n\x05\x04\x18\x02\x02\x04\x12\x06\
    \xd3\x01\x04\xd2\x01\x13\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xd3\x01\
    \x04\t\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xd3\x01\n\x10\n\r\n\x05\x04\
    \x18\x02\x02\x03\x12\x04\xd3\x01\x13\x14\n\x0c\n\x02\x04\x19\x12\x06\xd6\
    \x01\0\xd9\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xd6\x01\x08\x15\n\x0c\
    \n\x04\x04\x19\x02\0\x12\x04\xd7\x01\x04\x14\n\x0f\n\x05\x04\x19\x02\0\
    \x04\x12\x06\xd7\x01\x04\xd6\x01\x17\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\
    \xd7\x01\x04\n\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xd7\x01\x0b\x0f\n\r\n\
    \x05\x04\x19\x02\0\x03\x12\x04\xd7\x01\x12\x13\n\x0c\n\x04\x04\x19\x02\
    \x01\x12\x04\xd8\x01\x04\x14\n\x0f\n\x05\x04\x19\x02\x01\x04\x12\x06\xd8\
    \x01\x04\xd7\x01\x14\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xd8\x01\x04\n\
    \n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xd8\x01\x0b\x0f\n\r\n\x05\x04\x19\
    \x02\x01\x03\x12\x04\xd8\x01\x12\x13\n\x0c\n\x02\x04\x1a\x12\x06\xdb\x01\
    \0\xdd\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xdb\x01\x08\x18\n\x0c\n\
    \x04\x04\x1a\x02\0\x12\x04\xdc\x01\x04\x14\n\x0f\n\x05\x04\x1a\x02\0\x04\
    \x12\x06\xdc\x01\x04\xdb\x01\x1a\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xdc\
    \x01\x04\n\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xdc\x01\x0b\x0f\n\r\n\x05\
    \x04\x1a\x02\0\x03\x12\x04\xdc\x01\x12\x13\n\x0c\n\x02\x04\x1b\x12\x06\
    \xdf\x01\0\xe1\x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xdf\x01\x08\x15\n\
    \x0c\n\x04\x04\x1b\x02\0\x12\x04\xe0\x01\x04\x14\n\x0f\n\x05\x04\x1b\x02\
    \0\x04\x12\x06\xe0\x01\x04\xdf\x01\x17\n\r\n\x05\x04\x1b\x02\0\x05\x12\
    \x04\xe0\x01\x04\n\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xe0\x01\x0b\x0f\n\
    \r\n\x05\x04\x1b\x02\0\x03\x12\x04\xe0\x01\x12\x13\n\x0c\n\x02\x04\x1c\
    \x12\x06\xe3\x01\0\xf1\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xe3\x01\
    \x08\x16\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xe4\x01\x04\x18\n\x0f\n\x05\
    \x04\x1c\x02\0\x04\x12\x06\xe4\x01\x04\xe3\x01\x18\n\r\n\x05\x04\x1c\x02\
    \0\x05\x12\x04\xe4\x01\x04\n\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xe4\x01\
    \x0b\x13\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xe4\x01\x16\x17\n\x0c\n\x04\
    \x04\x1c\x02\x01\x12\x04\xe5\x01\x04\x18\n\x0f\n\x05\x04\x1c\x02\x01\x04\
    \x12\x06\xe5\x01\x04\xe4\x01\x18\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\
    \xe5\x01\x04\n\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xe5\x01\x0b\x13\n\r\
    \n\x05\x04\x1c\x02\x01\x03\x12\x04\xe5\x01\x16\x17\n\x0c\n\x04\x04\x1c\
    \x02\x02\x12\x04\xe6\x01\x04\x17\n\x0f\n\x05\x04\x1c\x02\x02\x04\x12\x06\
    \xe6\x01\x04\xe5\x01\x18\n\r\n\x05\x04\x1c\x02\x02\x05\x12\x04\xe6\x01\
    \x04\n\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xe6\x01\x0b\x12\n\r\n\x05\
    \x04\x1c\x02\x02\x03\x12\x04\xe6\x01\x15\x16\n\x0c\n\x04\x04\x1c\x02\x03\
    \x12\x04\xe7\x01\x04\x12\n\x0f\n\x05\x04\x1c\x02\x03\x04\x12\x06\xe7\x01\
    \x04\xe6\x01\x17\n\r\n\x05\x04\x1c\x02\x03\x05\x12\x04\xe7\x01\x04\n\n\r\
    \n\x05\x04\x1c\x02\x03\x01\x12\x04\xe7\x01\x0b\r\n\r\n\x05\x04\x1c\x02\
    \x03\x03\x12\x04\xe7\x01\x10\x11\n\x0c\n\x04\x04\x1c\x02\x04\x12\x04\xe8\
    \x01\x04\x14\n\x0f\n\x05\x04\x1c\x02\x04\x04\x12\x06\xe8\x01\x04\xe7\x01\
    \x12\n\r\n\x05\x04\x1c\x02\x04\x05\x12\x04\xe8\x01\x04\n\n\r\n\x05\x04\
    \x1c\x02\x04\x01\x12\x04\xe8\x01\x0b\x0f\n\r\n\x05\x04\x1c\x02\x04\x03\
    \x12\x04\xe8\x01\x12\x13\n\x0c\n\x04\x04\x1c\x02\x05\x12\x04\xe9\x01\x04\
    \x13\n\x0f\n\x05\x04\x1c\x02\x05\x04\x12\x06\xe9\x01\x04\xe8\x01\x14\n\r\
    \n\x05\x04\x1c\x02\x05\x05\x12\x04\xe9\x01\x04\n\n\r\n\x05\x04\x1c\x02\
    \x05\x01\x12\x04\xe9\x01\x0b\x0e\n\r\n\x05\x04\x1c\x02\x05\x03\x12\x04\
    \xe9\x01\x11\x12\n\x0c\n\x04\x04\x1c\x02\x06\x12\x04\xea\x01\x04\x12\n\
    \x0f\n\x05\x04\x1c\x02\x06\x04\x12\x06\xea\x01\x04\xe9\x01\x13\n\r\n\x05\
    \x04\x1c\x02\x06\x05\x12\x04\xea\x01\x04\t\n\r\n\x05\x04\x1c\x02\x06\x01\
    \x12\x04\xea\x01\n\r\n\r\n\x05\x04\x1c\x02\x06\x03\x12\x04\xea\x01\x10\
    \x11\n\x0c\n\x04\x04\x1c\x02\x07\x12\x04\xeb\x01\x04\x14\n\x0f\n\x05\x04\
    \x1c\x02\x07\x04\x12\x06\xeb\x01\x04\xea\x01\x12\n\r\n\x05\x04\x1c\x02\
    \x07\x05\x12\x04\xeb\x01\x04\t\n\r\n\x05\x04\x1c\x02\x07\x01\x12\x04\xeb\
    \x01\n\x0f\n\r\n\x05\x04\x1c\x02\x07\x03\x12\x04\xeb\x01\x12\x13\n\x0c\n\
    \x04\x04\x1c\x02\x08\x12\x04\xec\x01\x04\x15\n\x0f\n\x05\x04\x1c\x02\x08\
    \x04\x12\x06\xec\x01\x04\xeb\x01\x14\n\r\n\x05\x04\x1c\x02\x08\x05\x12\
    \x04\xec\x01\x04\t\n\r\n\x05\x04\x1c\x02\x08\x01\x12\x04\xec\x01\n\x10\n\
    \r\n\x05\x04\x1c\x02\x08\x03\x12\x04\xec\x01\x13\x14\n\x0c\n\x04\x04\x1c\
    \x02\t\x12\x04\xed\x01\x04$\n\x0f\n\x05\x04\x1c\x02\t\x04\x12\x06\xed\
    \x01\x04\xec\x01\x15\n\r\n\x05\x04\x1c\x02\t\x06\x12\x04\xed\x01\x04\x17\
    \n\r\n\x05\x04\x1c\x02\t\x01\x12\x04\xed\x01\x18\x1e\n\r\n\x05\x04\x1c\
    \x02\t\x03\x12\x04\xed\x01!#\n\x0c\n\x04\x04\x1c\x02\n\x12\x04\xee\x01\
    \x04\"\n\x0f\n\x05\x04\x1c\x02\n\x04\x12\x06\xee\x01\x04\xed\x01$\n\r\n\
    \x05\x04\x1c\x02\n\x06\x12\x04\xee\x01\x04\x17\n\r\n\x05\x04\x1c\x02\n\
    \x01\x12\x04\xee\x01\x18\x1c\n\r\n\x05\x04\x1c\x02\n\x03\x12\x04\xee\x01\
    \x1f!\n\x0c\n\x04\x04\x1c\x02\x0b\x12\x04\xef\x01\x04(\n\x0f\n\x05\x04\
    \x1c\x02\x0b\x04\x12\x06\xef\x01\x04\xee\x01\"\n\r\n\x05\x04\x1c\x02\x0b\
    \x06\x12\x04\xef\x01\x04\x16\n\r\n\x05\x04\x1c\x02\x0b\x01\x12\x04\xef\
    \x01\x17\"\n\r\n\x05\x04\x1c\x02\x0b\x03\x12\x04\xef\x01%'\n\x0c\n\x04\
    \x04\x1c\x02\x0c\x12\x04\xf0\x01\x04\x17\n\x0f\n\x05\x04\x1c\x02\x0c\x04\
    \x12\x06\xf0\x01\x04\xef\x01(\n\r\n\x05\x04\x1c\x02\x0c\x05\x12\x04\xf0\
    \x01\x04\t\n\r\n\x05\x04\x1c\x02\x0c\x01\x12\x04\xf0\x01\n\x11\n\r\n\x05\
    \x04\x1c\x02\x0c\x03\x12\x04\xf0\x01\x14\x16\n\x0c\n\x02\x04\x1d\x12\x06\
    \xf3\x01\0\xf5\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xf3\x01\x08\x19\n\
    \x0c\n\x04\x04\x1d\x02\0\x12\x04\xf4\x01\x04\x18\n\x0f\n\x05\x04\x1d\x02\
    \0\x04\x12\x06\xf4\x01\x04\xf3\x01\x1b\n\r\n\x05\x04\x1d\x02\0\x05\x12\
    \x04\xf4\x01\x04\n\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xf4\x01\x0b\x13\n\
    \r\n\x05\x04\x1d\x02\0\x03\x12\x04\xf4\x01\x16\x17\n\x0c\n\x02\x04\x1e\
    \x12\x06\xf7\x01\0\xfa\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xf7\x01\
    \x08\x16\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xf8\x01\x04\x18\n\x0f\n\x05\
    \x04\x1e\x02\0\x04\x12\x06\xf8\x01\x04\xf7\x01\x18\n\r\n\x05\x04\x1e\x02\
    \0\x05\x12\x04\xf8\x01\x04\n\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xf8\x01\
    \x0b\x13\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xf8\x01\x16\x17\n\x0c\n\x04\
    \x04\x1e\x02\x01\x12\x04\xf9\x01\x04#\n\x0f\n\x05\x04\x1e\x02\x01\x04\
    \x12\x06\xf9\x01\x04\xf8\x01\x18\n\r\n\x05\x04\x1e\x02\x01\x06\x12\x04\
    \xf9\x01\x04\x17\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xf9\x01\x18\x1e\n\
    \r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xf9\x01!\"\n\x0c\n\x02\x04\x1f\x12\
    \x06\xfc\x01\0\x80\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xfc\x01\x08\
    \x18\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xfd\x01\x04\x17\n\x0f\n\x05\x04\
    \x1f\x02\0\x04\x12\x06\xfd\x01\x04\xfc\x01\x1a\n\r\n\x05\x04\x1f\x02\0\
    \x05\x12\x04\xfd\x01\x04\n\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xfd\x01\
    \x0b\x12\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xfd\x01\x15\x16\n\x0c\n\x04\
    \x04\x1f\x02\x01\x12\x04\xfe\x01\x04\x11\n\x0f\n\x05\x04\x1f\x02\x01\x04\
    \x12\x06\xfe\x01\x04\xfd\x01\x17\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\
    \xfe\x01\x04\x08\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xfe\x01\t\x0c\n\r\
    \n\x05\x04\x1f\x02\x01\x03\x12\x04\xfe\x01\x0f\x10\n\x0c\n\x04\x04\x1f\
    \x02\x02\x12\x04\xff\x01\x04#\n\x0f\n\x05\x04\x1f\x02\x02\x04\x12\x06\
    \xff\x01\x04\xfe\x01\x11\n\r\n\x05\x04\x1f\x02\x02\x06\x12\x04\xff\x01\
    \x04\x17\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\xff\x01\x18\x1e\n\r\n\x05\
    \x04\x1f\x02\x02\x03\x12\x04\xff\x01!\"\n\x0c\n\x02\x04\x20\x12\x06\x82\
    \x02\0\x90\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x82\x02\x08\r\n\x0c\n\
    \x04\x04\x20\x02\0\x12\x04\x83\x02\x04\x14\n\x0f\n\x05\x04\x20\x02\0\x04\
    \x12\x06\x83\x02\x04\x82\x02\x0f\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\x83\
    \x02\x04\n\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\x83\x02\x0b\x0f\n\r\n\x05\
    \x04\x20\x02\0\x03\x12\x04\x83\x02\x12\x13\n\x0c\n\x04\x04\x20\x02\x01\
    \x12\x04\x84\x02\x04\x14\n\x0f\n\x05\x04\x20\x02\x01\x04\x12\x06\x84\x02\
    \x04\x83\x02\x14\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\x84\x02\x04\n\n\r\
    \n\x05\x04\x20\x02\x01\x01\x12\x04\x84\x02\x0b\x0f\n\r\n\x05\x04\x20\x02\
    \x01\x03\x12\x04\x84\x02\x12\x13\n\x0c\n\x04\x04\x20\x02\x02\x12\x04\x85\
    \x02\x04\x17\n\x0f\n\x05\x04\x20\x02\x02\x04\x12\x06\x85\x02\x04\x84\x02\
    \x14\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\x85\x02\x04\n\n\r\n\x05\x04\
    \x20\x02\x02\x01\x12\x04\x85\x02\x0b\x12\n\r\n\x05\x04\x20\x02\x02\x03\
    \x12\x04\x85\x02\x15\x16\n\x0c\n\x04\x04\x20\x02\x03\x12\x04\x86\x02\x04\
    \x13\n\x0f\n\x05\x04\x20\x02\x03\x04\x12\x06\x86\x02\x04\x85\x02\x17\n\r\
    \n\x05\x04\x20\x02\x03\x05\x12\x04\x86\x02\x04\n\n\r\n\x05\x04\x20\x02\
    \x03\x01\x12\x04\x86\x02\x0b\x0e\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\
    \x86\x02\x11\x12\n\x0c\n\x04\x04\x20\x02\x04\x12\x04\x87\x02\x04\x17\n\
    \x0f\n\x05\x04\x20\x02\x04\x04\x12\x06\x87\x02\x04\x86\x02\x13\n\r\n\x05\
    \x04\x20\x02\x04\x05\x12\x04\x87\x02\x04\x08\n\r\n\x05\x04\x20\x02\x04\
    \x01\x12\x04\x87\x02\t\x12\n\r\n\x05\x04\x20\x02\x04\x03\x12\x04\x87\x02\
    \x15\x16\n\x0c\n\x04\x04\x20\x02\x05\x12\x04\x88\x02\x04!\n\r\n\x05\x04\
    \x20\x02\x05\x04\x12\x04\x88\x02\x04\x0c\n\r\n\x05\x04\x20\x02\x05\x05\
    \x12\x04\x88\x02\r\x13\n\r\n\x05\x04\x20\x02\x05\x01\x12\x04\x88\x02\x14\
    \x1c\n\r\n\x05\x04\x20\x02\x05\x03\x12\x04\x88\x02\x1f\x20\n\x0c\n\x04\
    \x04\x20\x02\x06\x12\x04\x89\x02\x04!\n\x0f\n\x05\x04\x20\x02\x06\x04\
    \x12\x06\x89\x02\x04\x88\x02!\n\r\n\x05\x04\x20\x02\x06\x06\x12\x04\x89\
    \x02\x04\x17\n\r\n\x05\x04\x20\x02\x06\x01\x12\x04\x89\x02\x18\x1c\n\r\n\
    \x05\x04\x20\x02\x06\x03\x12\x04\x89\x02\x1f\x20\n\x0c\n\x04\x04\x20\x02\
    \x07\x12\x04\x8a\x02\x04!\n\x0f\n\x05\x04\x20\x02\x07\x04\x12\x06\x8a\
    \x02\x04\x89\x02!\n\r\n\x05\x04\x20\x02\x07\x06\x12\x04\x8a\x02\x04\x17\
    \n\r\n\x05\x04\x20\x02\x07\x01\x12\x04\x8a\x02\x18\x1c\n\r\n\x05\x04\x20\
    \x02\x07\x03\x12\x04\x8a\x02\x1f\x20\n\x0c\n\x04\x04\x20\x02\x08\x12\x04\
    \x8b\x02\x04#\n\x0f\n\x05\x04\x20\x02\x08\x04\x12\x06\x8b\x02\x04\x8a\
    \x02!\n\r\n\x05\x04\x20\x02\x08\x06\x12\x04\x8b\x02\x04\x17\n\r\n\x05\
    \x04\x20\x02\x08\x01\x12\x04\x8b\x02\x18\x1e\n\r\n\x05\x04\x20\x02\x08\
    \x03\x12\x04\x8b\x02!\"\n\x0c\n\x04\x04\x20\x02\t\x12\x04\x8c\x02\x04'\n\
    \x0f\n\x05\x04\x20\x02\t\x04\x12\x06\x8c\x02\x04\x8b\x02#\n\r\n\x05\x04\
    \x20\x02\t\x06\x12\x04\x8c\x02\x04\x17\n\r\n\x05\x04\x20\x02\t\x01\x12\
    \x04\x8c\x02\x18!\n\r\n\x05\x04\x20\x02\t\x03\x12\x04\x8c\x02$&\n\x0c\n\
    \x04\x04\x20\x02\n\x12\x04\x8d\x02\x04#\n\x0f\n\x05\x04\x20\x02\n\x04\
    \x12\x06\x8d\x02\x04\x8c\x02'\n\r\n\x05\x04\x20\x02\n\x06\x12\x04\x8d\
    \x02\x04\x17\n\r\n\x05\x04\x20\x02\n\x01\x12\x04\x8d\x02\x18\x1d\n\r\n\
    \x05\x04\x20\x02\n\x03\x12\x04\x8d\x02\x20\"\n\x0c\n\x04\x04\x20\x02\x0b\
    \x12\x04\x8e\x02\x04\x1c\n\x0f\n\x05\x04\x20\x02\x0b\x04\x12\x06\x8e\x02\
    \x04\x8d\x02#\n\r\n\x05\x04\x20\x02\x0b\x05\x12\x04\x8e\x02\x04\n\n\r\n\
    \x05\x04\x20\x02\x0b\x01\x12\x04\x8e\x02\x0b\x16\n\r\n\x05\x04\x20\x02\
    \x0b\x03\x12\x04\x8e\x02\x19\x1b\n\x0c\n\x04\x04\x20\x02\x0c\x12\x04\x8f\
    \x02\x04\x17\n\x0f\n\x05\x04\x20\x02\x0c\x04\x12\x06\x8f\x02\x04\x8e\x02\
    \x1c\n\r\n\x05\x04\x20\x02\x0c\x05\x12\x04\x8f\x02\x04\x08\n\r\n\x05\x04\
    \x20\x02\x0c\x01\x12\x04\x8f\x02\t\x11\n\r\n\x05\x04\x20\x02\x0c\x03\x12\
    \x04\x8f\x02\x14\x16\n\x0c\n\x02\x04!\x12\x06\x92\x02\0\x95\x02\x01\n\
    \x0b\n\x03\x04!\x01\x12\x04\x92\x02\x08\x0e\n\x0c\n\x04\x04!\x02\0\x12\
    \x04\x93\x02\x04\x1f\n\r\n\x05\x04!\x02\0\x04\x12\x04\x93\x02\x04\x0c\n\
    \r\n\x05\x04!\x02\0\x05\x12\x04\x93\x02\r\x13\n\r\n\x05\x04!\x02\0\x01\
    \x12\x04\x93\x02\x14\x1a\n\r\n\x05\x04!\x02\0\x03\x12\x04\x93\x02\x1d\
    \x1e\n\x0c\n\x04\x04!\x02\x01\x12\x04\x94\x02\x04\"\n\x0f\n\x05\x04!\x02\
    \x01\x04\x12\x06\x94\x02\x04\x93\x02\x1f\n\r\n\x05\x04!\x02\x01\x06\x12\
    \x04\x94\x02\x04\x16\n\r\n\x05\x04!\x02\x01\x01\x12\x04\x94\x02\x17\x1d\
    \n\r\n\x05\x04!\x02\x01\x03\x12\x04\x94\x02\x20!\n\x0c\n\x02\x04\"\x12\
    \x06\x97\x02\0\x9e\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\x97\x02\x08\x19\
    \n\x0c\n\x04\x04\"\x02\0\x12\x04\x98\x02\x04\x14\n\x0f\n\x05\x04\"\x02\0\
    \x04\x12\x06\x98\x02\x04\x97\x02\x1b\n\r\n\x05\x04\"\x02\0\x05\x12\x04\
    \x98\x02\x04\n\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x98\x02\x0b\x0f\n\r\n\
    \x05\x04\"\x02\0\x03\x12\x04\x98\x02\x12\x13\n\x0c\n\x04\x04\"\x02\x01\
    \x12\x04\x99\x02\x04\x14\n\x0f\n\x05\x04\"\x02\x01\x04\x12\x06\x99\x02\
    \x04\x98\x02\x14\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\x99\x02\x04\n\n\r\n\
    \x05\x04\"\x02\x01\x01\x12\x04\x99\x02\x0b\x0f\n\r\n\x05\x04\"\x02\x01\
    \x03\x12\x04\x99\x02\x12\x13\n\x0c\n\x04\x04\"\x02\x02\x12\x04\x9a\x02\
    \x04\x12\n\x0f\n\x05\x04\"\x02\x02\x04\x12\x06\x9a\x02\x04\x99\x02\x14\n\
    \r\n\x05\x04\"\x02\x02\x05\x12\x04\x9a\x02\x04\t\n\r\n\x05\x04\"\x02\x02\
    \x01\x12\x04\x9a\x02\n\r\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\x9a\x02\x10\
    \x11\n\x0c\n\x04\x04\"\x02\x03\x12\x04\x9b\x02\x04\x1d\n\r\n\x05\x04\"\
    \x02\x03\x04\x12\x04\x9b\x02\x04\x0c\n\r\n\x05\x04\"\x02\x03\x05\x12\x04\
    \x9b\x02\r\x13\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\x9b\x02\x14\x18\n\r\n\
    \x05\x04\"\x02\x03\x03\x12\x04\x9b\x02\x1b\x1c\n\x0c\n\x04\x04\"\x02\x04\
    \x12\x04\x9c\x02\x04\x16\n\x0f\n\x05\x04\"\x02\x04\x04\x12\x06\x9c\x02\
    \x04\x9b\x02\x1d\n\r\n\x05\x04\"\x02\x04\x06\x12\x04\x9c\x02\x04\n\n\r\n\
    \x05\x04\"\x02\x04\x01\x12\x04\x9c\x02\x0b\x11\n\r\n\x05\x04\"\x02\x04\
    \x03\x12\x04\x9c\x02\x14\x15\n\x0c\n\x04\x04\"\x02\x05\x12\x04\x9d\x02\
    \x04\x12\n\x0f\n\x05\x04\"\x02\x05\x04\x12\x06\x9d\x02\x04\x9c\x02\x16\n\
    \r\n\x05\x04\"\x02\x05\x05\x12\x04\x9d\x02\x04\t\n\r\n\x05\x04\"\x02\x05\
    \x01\x12\x04\x9d\x02\n\r\n\r\n\x05\x04\"\x02\x05\x03\x12\x04\x9d\x02\x10\
    \x11\n\x0c\n\x02\x04#\x12\x06\xa0\x02\0\xa4\x02\x01\n\x0b\n\x03\x04#\x01\
    \x12\x04\xa0\x02\x08\x13\n\x0c\n\x04\x04#\x02\0\x12\x04\xa1\x02\x04$\n\r\
    \n\x05\x04#\x02\0\x04\x12\x04\xa1\x02\x04\x0c\n\r\n\x05\x04#\x02\0\x05\
    \x12\x04\xa1\x02\r\x13\n\r\n\x05\x04#\x02\0\x01\x12\x04\xa1\x02\x14\x1f\
    \n\r\n\x05\x04#\x02\0\x03\x12\x04\xa1\x02\"#\n\x0c\n\x04\x04#\x02\x01\
    \x12\x04\xa2\x02\x04$\n\r\n\x05\x04#\x02\x01\x04\x12\x04\xa2\x02\x04\x0c\
    \n\r\n\x05\x04#\x02\x01\x05\x12\x04\xa2\x02\r\x13\n\r\n\x05\x04#\x02\x01\
    \x01\x12\x04\xa2\x02\x14\x1f\n\r\n\x05\x04#\x02\x01\x03\x12\x04\xa2\x02\
    \"#\n\x0c\n\x04\x04#\x02\x02\x12\x04\xa3\x02\x04\x13\n\x0f\n\x05\x04#\
    \x02\x02\x04\x12\x06\xa3\x02\x04\xa2\x02$\n\r\n\x05\x04#\x02\x02\x05\x12\
    \x04\xa3\x02\x04\x08\n\r\n\x05\x04#\x02\x02\x01\x12\x04\xa3\x02\t\x0e\n\
    \r\n\x05\x04#\x02\x02\x03\x12\x04\xa3\x02\x11\x12\n\x0c\n\x02\x04$\x12\
    \x06\xa6\x02\0\xab\x02\x01\n\x0b\n\x03\x04$\x01\x12\x04\xa6\x02\x08\x1a\
    \n\x0c\n\x04\x04$\x02\0\x12\x04\xa7\x02\x04\"\n\r\n\x05\x04$\x02\0\x04\
    \x12\x04\xa7\x02\x04\x0c\n\r\n\x05\x04$\x02\0\x05\x12\x04\xa7\x02\r\x13\
    \n\r\n\x05\x04$\x02\0\x01\x12\x04\xa7\x02\x14\x1d\n\r\n\x05\x04$\x02\0\
    \x03\x12\x04\xa7\x02\x20!\n\x0c\n\x04\x04$\x02\x01\x12\x04\xa8\x02\x04\
    \x19\n\x0f\n\x05\x04$\x02\x01\x04\x12\x06\xa8\x02\x04\xa7\x02\"\n\r\n\
    \x05\x04$\x02\x01\x05\x12\x04\xa8\x02\x04\n\n\r\n\x05\x04$\x02\x01\x01\
    \x12\x04\xa8\x02\x0b\x14\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xa8\x02\x17\
    \x18\n\x0c\n\x04\x04$\x02\x02\x12\x04\xa9\x02\x04\x13\n\x0f\n\x05\x04$\
    \x02\x02\x04\x12\x06\xa9\x02\x04\xa8\x02\x19\n\r\n\x05\x04$\x02\x02\x05\
    \x12\x04\xa9\x02\x04\n\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xa9\x02\x0b\
    \x0e\n\r\n\x05\x04$\x02\x02\x03\x12\x04\xa9\x02\x11\x12\n\x0c\n\x04\x04$\
    \x02\x03\x12\x04\xaa\x02\x04\x13\n\x0f\n\x05\x04$\x02\x03\x04\x12\x06\
    \xaa\x02\x04\xa9\x02\x13\n\r\n\x05\x04$\x02\x03\x05\x12\x04\xaa\x02\x04\
    \t\n\r\n\x05\x04$\x02\x03\x01\x12\x04\xaa\x02\n\x0e\n\r\n\x05\x04$\x02\
    \x03\x03\x12\x04\xaa\x02\x11\x12\n\x0c\n\x02\x04%\x12\x06\xad\x02\0\xb0\
    \x02\x01\n\x0b\n\x03\x04%\x01\x12\x04\xad\x02\x08\x12\n\x0c\n\x04\x04%\
    \x02\0\x12\x04\xae\x02\x04\x14\n\x0f\n\x05\x04%\x02\0\x04\x12\x06\xae\
    \x02\x04\xad\x02\x14\n\r\n\x05\x04%\x02\0\x05\x12\x04\xae\x02\x04\n\n\r\
    \n\x05\x04%\x02\0\x01\x12\x04\xae\x02\x0b\x0f\n\r\n\x05\x04%\x02\0\x03\
    \x12\x04\xae\x02\x12\x13\n\x0c\n\x04\x04%\x02\x01\x12\x04\xaf\x02\x04#\n\
    \x0f\n\x05\x04%\x02\x01\x04\x12\x06\xaf\x02\x04\xae\x02\x14\n\r\n\x05\
    \x04%\x02\x01\x06\x12\x04\xaf\x02\x04\x17\n\r\n\x05\x04%\x02\x01\x01\x12\
    \x04\xaf\x02\x18\x1e\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xaf\x02!\"\n\x0c\
    \n\x02\x04&\x12\x06\xb2\x02\0\xbd\x02\x01\n\x0b\n\x03\x04&\x01\x12\x04\
    \xb2\x02\x08\x19\n\x0c\n\x04\x04&\x02\0\x12\x04\xb3\x02\x04\x14\n\x0f\n\
    \x05\x04&\x02\0\x04\x12\x06\xb3\x02\x04\xb2\x02\x1b\n\r\n\x05\x04&\x02\0\
    \x05\x12\x04\xb3\x02\x04\n\n\r\n\x05\x04&\x02\0\x01\x12\x04\xb3\x02\x0b\
    \x0f\n\r\n\x05\x04&\x02\0\x03\x12\x04\xb3\x02\x12\x13\n\x0c\n\x04\x04&\
    \x02\x01\x12\x04\xb4\x02\x04\x17\n\x0f\n\x05\x04&\x02\x01\x04\x12\x06\
    \xb4\x02\x04\xb3\x02\x14\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xb4\x02\x04\
    \n\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xb4\x02\x0b\x12\n\r\n\x05\x04&\x02\
    \x01\x03\x12\x04\xb4\x02\x15\x16\n\x0c\n\x04\x04&\x02\x02\x12\x04\xb5\
    \x02\x04\x18\n\x0f\n\x05\x04&\x02\x02\x04\x12\x06\xb5\x02\x04\xb4\x02\
    \x17\n\r\n\x05\x04&\x02\x02\x05\x12\x04\xb5\x02\x04\x08\n\r\n\x05\x04&\
    \x02\x02\x01\x12\x04\xb5\x02\t\x13\n\r\n\x05\x04&\x02\x02\x03\x12\x04\
    \xb5\x02\x16\x17\n\x0c\n\x04\x04&\x02\x03\x12\x04\xb6\x02\x04\x13\n\x0f\
    \n\x05\x04&\x02\x03\x04\x12\x06\xb6\x02\x04\xb5\x02\x18\n\r\n\x05\x04&\
    \x02\x03\x05\x12\x04\xb6\x02\x04\n\n\r\n\x05\x04&\x02\x03\x01\x12\x04\
    \xb6\x02\x0b\x0e\n\r\n\x05\x04&\x02\x03\x03\x12\x04\xb6\x02\x11\x12\n\
    \x0c\n\x04\x04&\x02\x04\x12\x04\xb7\x02\x04\x17\n\x0f\n\x05\x04&\x02\x04\
    \x04\x12\x06\xb7\x02\x04\xb6\x02\x13\n\r\n\x05\x04&\x02\x04\x06\x12\x04\
    \xb7\x02\x04\x0e\n\r\n\x05\x04&\x02\x04\x01\x12\x04\xb7\x02\x0f\x12\n\r\
    \n\x05\x04&\x02\x04\x03\x12\x04\xb7\x02\x15\x16\n\x0c\n\x04\x04&\x02\x05\
    \x12\x04\xb8\x02\x04\x20\n\r\n\x05\x04&\x02\x05\x04\x12\x04\xb8\x02\x04\
    \x0c\n\r\n\x05\x04&\x02\x05\x05\x12\x04\xb8\x02\r\x13\n\r\n\x05\x04&\x02\
    \x05\x01\x12\x04\xb8\x02\x14\x1b\n\r\n\x05\x04&\x02\x05\x03\x12\x04\xb8\
    \x02\x1e\x1f\n\x0c\n\x04\x04&\x02\x06\x12\x04\xb9\x02\x04'\n\x0f\n\x05\
    \x04&\x02\x06\x04\x12\x06\xb9\x02\x04\xb8\x02\x20\n\r\n\x05\x04&\x02\x06\
    \x06\x12\x04\xb9\x02\x04\x16\n\r\n\x05\x04&\x02\x06\x01\x12\x04\xb9\x02\
    \x17\"\n\r\n\x05\x04&\x02\x06\x03\x12\x04\xb9\x02%&\n\x0c\n\x04\x04&\x02\
    \x07\x12\x04\xba\x02\x04\x19\n\x0f\n\x05\x04&\x02\x07\x04\x12\x06\xba\
    \x02\x04\xb9\x02'\n\r\n\x05\x04&\x02\x07\x06\x12\x04\xba\x02\x04\x0f\n\r\
    \n\x05\x04&\x02\x07\x01\x12\x04\xba\x02\x10\x14\n\r\n\x05\x04&\x02\x07\
    \x03\x12\x04\xba\x02\x17\x18\n\x0c\n\x04\x04&\x02\x08\x12\x04\xbb\x02\
    \x04\x1e\n\x0f\n\x05\x04&\x02\x08\x04\x12\x06\xbb\x02\x04\xba\x02\x19\n\
    \r\n\x05\x04&\x02\x08\x05\x12\x04\xbb\x02\x04\n\n\r\n\x05\x04&\x02\x08\
    \x01\x12\x04\xbb\x02\x0b\x19\n\r\n\x05\x04&\x02\x08\x03\x12\x04\xbb\x02\
    \x1c\x1d\n\x0c\n\x04\x04&\x02\t\x12\x04\xbc\x02\x04%\n\x0f\n\x05\x04&\
    \x02\t\x04\x12\x06\xbc\x02\x04\xbb\x02\x1e\n\r\n\x05\x04&\x02\t\x06\x12\
    \x04\xbc\x02\x04\x17\n\r\n\x05\x04&\x02\t\x01\x12\x04\xbc\x02\x18\x1f\n\
    \r\n\x05\x04&\x02\t\x03\x12\x04\xbc\x02\"$\n\x0c\n\x02\x04'\x12\x06\xbf\
    \x02\0\xdd\x02\x01\n\x0b\n\x03\x04'\x01\x12\x04\xbf\x02\x08\x15\n\x0c\n\
    \x04\x04'\x02\0\x12\x04\xc0\x02\x04\x14\n\x0f\n\x05\x04'\x02\0\x04\x12\
    \x06\xc0\x02\x04\xbf\x02\x17\n\r\n\x05\x04'\x02\0\x05\x12\x04\xc0\x02\
    \x04\n\n\r\n\x05\x04'\x02\0\x01\x12\x04\xc0\x02\x0b\x0f\n\r\n\x05\x04'\
    \x02\0\x03\x12\x04\xc0\x02\x12\x13\n\x0c\n\x04\x04'\x02\x01\x12\x04\xc1\
    \x02\x04%\n\x0f\n\x05\x04'\x02\x01\x04\x12\x06\xc1\x02\x04\xc0\x02\x14\n\
    \r\n\x05\x04'\x02\x01\x06\x12\x04\xc1\x02\x04\x15\n\r\n\x05\x04'\x02\x01\
    \x01\x12\x04\xc1\x02\x16\x20\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xc1\x02#\
    $\n\x0c\n\x04\x04'\x02\x02\x12\x04\xc2\x02\x04\x17\n\x0f\n\x05\x04'\x02\
    \x02\x04\x12\x06\xc2\x02\x04\xc1\x02%\n\r\n\x05\x04'\x02\x02\x05\x12\x04\
    \xc2\x02\x04\n\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xc2\x02\x0b\x12\n\r\n\
    \x05\x04'\x02\x02\x03\x12\x04\xc2\x02\x15\x16\n\x0c\n\x04\x04'\x02\x03\
    \x12\x04\xc3\x02\x04\x18\n\x0f\n\x05\x04'\x02\x03\x04\x12\x06\xc3\x02\
    \x04\xc2\x02\x17\n\r\n\x05\x04'\x02\x03\x05\x12\x04\xc3\x02\x04\n\n\r\n\
    \x05\x04'\x02\x03\x01\x12\x04\xc3\x02\x0b\x13\n\r\n\x05\x04'\x02\x03\x03\
    \x12\x04\xc3\x02\x16\x17\n\x0c\n\x04\x04'\x02\x04\x12\x04\xc4\x02\x04\
    \x15\n\x0f\n\x05\x04'\x02\x04\x04\x12\x06\xc4\x02\x04\xc3\x02\x18\n\r\n\
    \x05\x04'\x02\x04\x05\x12\x04\xc4\x02\x04\n\n\r\n\x05\x04'\x02\x04\x01\
    \x12\x04\xc4\x02\x0b\x10\n\r\n\x05\x04'\x02\x04\x03\x12\x04\xc4\x02\x13\
    \x14\n\x0c\n\x04\x04'\x02\x05\x12\x04\xc5\x02\x04\x1a\n\x0f\n\x05\x04'\
    \x02\x05\x04\x12\x06\xc5\x02\x04\xc4\x02\x15\n\r\n\x05\x04'\x02\x05\x05\
    \x12\x04\xc5\x02\x04\n\n\r\n\x05\x04'\x02\x05\x01\x12\x04\xc5\x02\x0b\
    \x15\n\r\n\x05\x04'\x02\x05\x03\x12\x04\xc5\x02\x18\x19\n\x0c\n\x04\x04'\
    \x02\x06\x12\x04\xc6\x02\x04\x19\n\x0f\n\x05\x04'\x02\x06\x04\x12\x06\
    \xc6\x02\x04\xc5\x02\x1a\n\r\n\x05\x04'\x02\x06\x05\x12\x04\xc6\x02\x04\
    \n\n\r\n\x05\x04'\x02\x06\x01\x12\x04\xc6\x02\x0b\x14\n\r\n\x05\x04'\x02\
    \x06\x03\x12\x04\xc6\x02\x17\x18\n\x0c\n\x04\x04'\x02\x07\x12\x04\xc7\
    \x02\x04\x15\n\x0f\n\x05\x04'\x02\x07\x04\x12\x06\xc7\x02\x04\xc6\x02\
    \x19\n\r\n\x05\x04'\x02\x07\x05\x12\x04\xc7\x02\x04\t\n\r\n\x05\x04'\x02\
    \x07\x01\x12\x04\xc7\x02\n\x10\n\r\n\x05\x04'\x02\x07\x03\x12\x04\xc7\
    \x02\x13\x14\n\x0c\n\x04\x04'\x02\x08\x12\x04\xc8\x02\x04\x14\n\x0f\n\
    \x05\x04'\x02\x08\x04\x12\x06\xc8\x02\x04\xc7\x02\x15\n\r\n\x05\x04'\x02\
    \x08\x05\x12\x04\xc8\x02\x04\t\n\r\n\x05\x04'\x02\x08\x01\x12\x04\xc8\
    \x02\n\x0f\n\r\n\x05\x04'\x02\x08\x03\x12\x04\xc8\x02\x12\x13\n\x0c\n\
    \x04\x04'\x02\t\x12\x04\xc9\x02\x04\x1d\n\r\n\x05\x04'\x02\t\x04\x12\x04\
    \xc9\x02\x04\x0c\n\r\n\x05\x04'\x02\t\x05\x12\x04\xc9\x02\r\x13\n\r\n\
    \x05\x04'\x02\t\x01\x12\x04\xc9\x02\x14\x17\n\r\n\x05\x04'\x02\t\x03\x12\
    \x04\xc9\x02\x1a\x1c\n\x0c\n\x04\x04'\x02\n\x12\x04\xca\x02\x04\x1d\n\r\
    \n\x05\x04'\x02\n\x04\x12\x04\xca\x02\x04\x0c\n\r\n\x05\x04'\x02\n\x05\
    \x12\x04\xca\x02\r\x13\n\r\n\x05\x04'\x02\n\x01\x12\x04\xca\x02\x14\x17\
    \n\r\n\x05\x04'\x02\n\x03\x12\x04\xca\x02\x1a\x1c\n\x0c\n\x04\x04'\x02\
    \x0b\x12\x04\xcb\x02\x04%\n\r\n\x05\x04'\x02\x0b\x04\x12\x04\xcb\x02\x04\
    \x0c\n\r\n\x05\x04'\x02\x0b\x05\x12\x04\xcb\x02\r\x13\n\r\n\x05\x04'\x02\
    \x0b\x01\x12\x04\xcb\x02\x14\x1f\n\r\n\x05\x04'\x02\x0b\x03\x12\x04\xcb\
    \x02\"$\n\x0c\n\x04\x04'\x02\x0c\x12\x04\xcc\x02\x04!\n\r\n\x05\x04'\x02\
    \x0c\x04\x12\x04\xcc\x02\x04\x0c\n\r\n\x05\x04'\x02\x0c\x05\x12\x04\xcc\
    \x02\r\x13\n\r\n\x05\x04'\x02\x0c\x01\x12\x04\xcc\x02\x14\x1b\n\r\n\x05\
    \x04'\x02\x0c\x03\x12\x04\xcc\x02\x1e\x20\n\x0c\n\x04\x04'\x02\r\x12\x04\
    \xcd\x02\x04&\n\x0f\n\x05\x04'\x02\r\x04\x12\x06\xcd\x02\x04\xcc\x02!\n\
    \r\n\x05\x04'\x02\r\x06\x12\x04\xcd\x02\x04\x17\n\r\n\x05\x04'\x02\r\x01\
    \x12\x04\xcd\x02\x18\x20\n\r\n\x05\x04'\x02\r\x03\x12\x04\xcd\x02#%\n\
    \x0c\n\x04\x04'\x02\x0e\x12\x04\xce\x02\x04\x1c\n\x0f\n\x05\x04'\x02\x0e\
    \x04\x12\x06\xce\x02\x04\xcd\x02&\n\r\n\x05\x04'\x02\x0e\x05\x12\x04\xce\
    \x02\x04\n\n\r\n\x05\x04'\x02\x0e\x01\x12\x04\xce\x02\x0b\x16\n\r\n\x05\
    \x04'\x02\x0e\x03\x12\x04\xce\x02\x19\x1b\n\x0c\n\x04\x04'\x02\x0f\x12\
    \x04\xcf\x02\x04\x15\n\x0f\n\x05\x04'\x02\x0f\x04\x12\x06\xcf\x02\x04\
    \xce\x02\x1c\n\r\n\x05\x04'\x02\x0f\x05\x12\x04\xcf\x02\x04\n\n\r\n\x05\
    \x04'\x02\x0f\x01\x12\x04\xcf\x02\x0b\x0f\n\r\n\x05\x04'\x02\x0f\x03\x12\
    \x04\xcf\x02\x12\x14\n\x0c\n\x04\x04'\x02\x10\x12\x04\xd0\x02\x04\x14\n\
    \x0f\n\x05\x04'\x02\x10\x04\x12\x06\xd0\x02\x04\xcf\x02\x15\n\r\n\x05\
    \x04'\x02\x10\x05\x12\x04\xd0\x02\x04\x08\n\r\n\x05\x04'\x02\x10\x01\x12\
    \x04\xd0\x02\t\x0e\n\r\n\x05\x04'\x02\x10\x03\x12\x04\xd0\x02\x11\x13\n\
    \x0c\n\x04\x04'\x02\x11\x12\x04\xd1\x02\x04\x18\n\x0f\n\x05\x04'\x02\x11\
    \x04\x12\x06\xd1\x02\x04\xd0\x02\x14\n\r\n\x05\x04'\x02\x11\x05\x12\x04\
    \xd1\x02\x04\x08\n\r\n\x05\x04'\x02\x11\x01\x12\x04\xd1\x02\t\x12\n\r\n\
    \x05\x04'\x02\x11\x03\x12\x04\xd1\x02\x15\x17\n\x0c\n\x04\x04'\x02\x12\
    \x12\x04\xd2\x02\x04$\n\x0f\n\x05\x04'\x02\x12\x04\x12\x06\xd2\x02\x04\
    \xd1\x02\x18\n\r\n\x05\x04'\x02\x12\x06\x12\x04\xd2\x02\x04\x17\n\r\n\
    \x05\x04'\x02\x12\x01\x12\x04\xd2\x02\x18\x1e\n\r\n\x05\x04'\x02\x12\x03\
    \x12\x04\xd2\x02!#\n\x0c\n\x04\x04'\x02\x13\x12\x04\xd3\x02\x04(\n\x0f\n\
    \x05\x04'\x02\x13\x04\x12\x06\xd3\x02\x04\xd2\x02$\n\r\n\x05\x04'\x02\
    \x13\x06\x12\x04\xd3\x02\x04\x17\n\r\n\x05\x04'\x02\x13\x01\x12\x04\xd3\
    \x02\x18\"\n\r\n\x05\x04'\x02\x13\x03\x12\x04\xd3\x02%'\n\x0c\n\x04\x04'\
    \x02\x14\x12\x04\xd4\x02\x04\x1e\n\x0f\n\x05\x04'\x02\x14\x04\x12\x06\
    \xd4\x02\x04\xd3\x02(\n\r\n\x05\x04'\x02\x14\x05\x12\x04\xd4\x02\x04\n\n\
    \r\n\x05\x04'\x02\x14\x01\x12\x04\xd4\x02\x0b\x18\n\r\n\x05\x04'\x02\x14\
    \x03\x12\x04\xd4\x02\x1b\x1d\n\x0c\n\x04\x04'\x02\x15\x12\x04\xd5\x02\
    \x04!\n\x0f\n\x05\x04'\x02\x15\x04\x12\x06\xd5\x02\x04\xd4\x02\x1e\n\r\n\
    \x05\x04'\x02\x15\x06\x12\x04\xd5\x02\x04\x16\n\r\n\x05\x04'\x02\x15\x01\
    \x12\x04\xd5\x02\x17\x1b\n\r\n\x05\x04'\x02\x15\x03\x12\x04\xd5\x02\x1e\
    \x20\n\x0c\n\x04\x04'\x02\x16\x12\x04\xd6\x02\x04\x19\n\x0f\n\x05\x04'\
    \x02\x16\x04\x12\x06\xd6\x02\x04\xd5\x02!\n\r\n\x05\x04'\x02\x16\x05\x12\
    \x04\xd6\x02\x04\x08\n\r\n\x05\x04'\x02\x16\x01\x12\x04\xd6\x02\t\x13\n\
    \r\n\x05\x04'\x02\x16\x03\x12\x04\xd6\x02\x16\x18\n\x0c\n\x04\x04'\x02\
    \x17\x12\x04\xd7\x02\x04\x1b\n\x0f\n\x05\x04'\x02\x17\x04\x12\x06\xd7\
    \x02\x04\xd6\x02\x19\n\r\n\x05\x04'\x02\x17\x05\x12\x04\xd7\x02\x04\t\n\
    \r\n\x05\x04'\x02\x17\x01\x12\x04\xd7\x02\n\x15\n\r\n\x05\x04'\x02\x17\
    \x03\x12\x04\xd7\x02\x18\x1a\n\x0c\n\x04\x04'\x02\x18\x12\x04\xd8\x02\
    \x04\x17\n\x0f\n\x05\x04'\x02\x18\x04\x12\x06\xd8\x02\x04\xd7\x02\x1b\n\
    \r\n\x05\x04'\x02\x18\x05\x12\x04\xd8\x02\x04\x08\n\r\n\x05\x04'\x02\x18\
    \x01\x12\x04\xd8\x02\t\x11\n\r\n\x05\x04'\x02\x18\x03\x12\x04\xd8\x02\
    \x14\x16\n\x0c\n\x04\x04'\x02\x19\x12\x04\xd9\x02\x04\x1a\n\x0f\n\x05\
    \x04'\x02\x19\x04\x12\x06\xd9\x02\x04\xd8\x02\x17\n\r\n\x05\x04'\x02\x19\
    \x05\x12\x04\xd9\x02\x04\x08\n\r\n\x05\x04'\x02\x19\x01\x12\x04\xd9\x02\
    \t\x14\n\r\n\x05\x04'\x02\x19\x03\x12\x04\xd9\x02\x17\x19\n\x0c\n\x04\
    \x04'\x02\x1a\x12\x04\xda\x02\x04&\n\r\n\x05\x04'\x02\x1a\x04\x12\x04\
    \xda\x02\x04\x0c\n\r\n\x05\x04'\x02\x1a\x05\x12\x04\xda\x02\r\x13\n\r\n\
    \x05\x04'\x02\x1a\x01\x12\x04\xda\x02\x14\x20\n\r\n\x05\x04'\x02\x1a\x03\
    \x12\x04\xda\x02#%\n\x0c\n\x04\x04'\x02\x1b\x12\x04\xdb\x02\x04\x18\n\
    \x0f\n\x05\x04'\x02\x1b\x04\x12\x06\xdb\x02\x04\xda\x02&\n\r\n\x05\x04'\
    \x02\x1b\x05\x12\x04\xdb\x02\x04\t\n\r\n\x05\x04'\x02\x1b\x01\x12\x04\
    \xdb\x02\n\x12\n\r\n\x05\x04'\x02\x1b\x03\x12\x04\xdb\x02\x15\x17\n\x0c\
    \n\x04\x04'\x02\x1c\x12\x04\xdc\x02\x04\x17\n\x0f\n\x05\x04'\x02\x1c\x04\
    \x12\x06\xdc\x02\x04\xdb\x02\x18\n\r\n\x05\x04'\x02\x1c\x05\x12\x04\xdc\
    \x02\x04\t\n\r\n\x05\x04'\x02\x1c\x01\x12\x04\xdc\x02\n\x11\n\r\n\x05\
    \x04'\x02\x1c\x03\x12\x04\xdc\x02\x14\x16\n\x0c\n\x02\x04(\x12\x06\xdf\
    \x02\0\xe5\x02\x01\n\x0b\n\x03\x04(\x01\x12\x04\xdf\x02\x08\x16\n\x0c\n\
    \x04\x04(\x02\0\x12\x04\xe0\x02\x04\x20\n\x0f\n\x05\x04(\x02\0\x04\x12\
    \x06\xe0\x02\x04\xdf\x02\x18\n\r\n\x05\x04(\x02\0\x06\x12\x04\xe0\x02\
    \x04\x11\n\r\n\x05\x04(\x02\0\x01\x12\x04\xe0\x02\x12\x1b\n\r\n\x05\x04(\
    \x02\0\x03\x12\x04\xe0\x02\x1e\x1f\n\x0c\n\x04\x04(\x02\x01\x12\x04\xe1\
    \x02\x04\x1c\n\x0f\n\x05\x04(\x02\x01\x04\x12\x06\xe1\x02\x04\xe0\x02\
    \x20\n\r\n\x05\x04(\x02\x01\x05\x12\x04\xe1\x02\x04\x08\n\r\n\x05\x04(\
    \x02\x01\x01\x12\x04\xe1\x02\t\x17\n\r\n\x05\x04(\x02\x01\x03\x12\x04\
    \xe1\x02\x1a\x1b\n\x0c\n\x04\x04(\x02\x02\x12\x04\xe2\x02\x04*\n\x0f\n\
    \x05\x04(\x02\x02\x04\x12\x06\xe2\x02\x04\xe1\x02\x1c\n\r\n\x05\x04(\x02\
    \x02\x06\x12\x04\xe2\x02\x04\x17\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xe2\
    \x02\x18%\n\r\n\x05\x04(\x02\x02\x03\x12\x04\xe2\x02()\n\x0c\n\x04\x04(\
    \x02\x03\x12\x04\xe3\x02\x04!\n\x0f\n\x05\x04(\x02\x03\x04\x12\x06\xe3\
    \x02\x04\xe2\x02*\n\r\n\x05\x04(\x02\x03\x06\x12\x04\xe3\x02\x04\x17\n\r\
    \n\x05\x04(\x02\x03\x01\x12\x04\xe3\x02\x18\x1c\n\r\n\x05\x04(\x02\x03\
    \x03\x12\x04\xe3\x02\x1f\x20\n\x0c\n\x04\x04(\x02\x04\x12\x04\xe4\x02\
    \x04\x1c\n\r\n\x05\x04(\x02\x04\x04\x12\x04\xe4\x02\x04\x0c\n\r\n\x05\
    \x04(\x02\x04\x05\x12\x04\xe4\x02\r\x13\n\r\n\x05\x04(\x02\x04\x01\x12\
    \x04\xe4\x02\x14\x17\n\r\n\x05\x04(\x02\x04\x03\x12\x04\xe4\x02\x1a\x1b\
    \n\x0c\n\x02\x04)\x12\x06\xe7\x02\0\xec\x02\x01\n\x0b\n\x03\x04)\x01\x12\
    \x04\xe7\x02\x08\x19\n\x0c\n\x04\x04)\x02\0\x12\x04\xe8\x02\x04\x17\n\
    \x0f\n\x05\x04)\x02\0\x04\x12\x06\xe8\x02\x04\xe7\x02\x1b\n\r\n\x05\x04)\
    \x02\0\x05\x12\x04\xe8\x02\x04\n\n\r\n\x05\x04)\x02\0\x01\x12\x04\xe8\
    \x02\x0b\x12\n\r\n\x05\x04)\x02\0\x03\x12\x04\xe8\x02\x15\x16\n\x0c\n\
    \x04\x04)\x02\x01\x12\x04\xe9\x02\x04\x18\n\x0f\n\x05\x04)\x02\x01\x04\
    \x12\x06\xe9\x02\x04\xe8\x02\x17\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xe9\
    \x02\x04\n\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xe9\x02\x0b\x13\n\r\n\x05\
    \x04)\x02\x01\x03\x12\x04\xe9\x02\x16\x17\n\x0c\n\x04\x04)\x02\x02\x12\
    \x04\xea\x02\x04\x1f\n\r\n\x05\x04)\x02\x02\x04\x12\x04\xea\x02\x04\x0c\
    \n\r\n\x05\x04)\x02\x02\x05\x12\x04\xea\x02\r\x13\n\r\n\x05\x04)\x02\x02\
    \x01\x12\x04\xea\x02\x14\x1a\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xea\x02\
    \x1d\x1e\n\x0c\n\x04\x04)\x02\x03\x12\x04\xeb\x02\x04\x13\n\x0f\n\x05\
    \x04)\x02\x03\x04\x12\x06\xeb\x02\x04\xea\x02\x1f\n\r\n\x05\x04)\x02\x03\
    \x05\x12\x04\xeb\x02\x04\t\n\r\n\x05\x04)\x02\x03\x01\x12\x04\xeb\x02\n\
    \x0e\n\r\n\x05\x04)\x02\x03\x03\x12\x04\xeb\x02\x11\x12\n\x0c\n\x02\x04*\
    \x12\x06\xee\x02\0\xf4\x02\x01\n\x0b\n\x03\x04*\x01\x12\x04\xee\x02\x08\
    \x1a\n\x0c\n\x04\x04*\x02\0\x12\x04\xef\x02\x04\x17\n\x0f\n\x05\x04*\x02\
    \0\x04\x12\x06\xef\x02\x04\xee\x02\x1c\n\r\n\x05\x04*\x02\0\x05\x12\x04\
    \xef\x02\x04\n\n\r\n\x05\x04*\x02\0\x01\x12\x04\xef\x02\x0b\x12\n\r\n\
    \x05\x04*\x02\0\x03\x12\x04\xef\x02\x15\x16\n\x0c\n\x04\x04*\x02\x01\x12\
    \x04\xf0\x02\x04\x18\n\x0f\n\x05\x04*\x02\x01\x04\x12\x06\xf0\x02\x04\
    \xef\x02\x17\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xf0\x02\x04\n\n\r\n\x05\
    \x04*\x02\x01\x01\x12\x04\xf0\x02\x0b\x13\n\r\n\x05\x04*\x02\x01\x03\x12\
    \x04\xf0\x02\x16\x17\n\x0c\n\x04\x04*\x02\x02\x12\x04\xf1\x02\x04\x1f\n\
    \r\n\x05\x04*\x02\x02\x04\x12\x04\xf1\x02\x04\x0c\n\r\n\x05\x04*\x02\x02\
    \x05\x12\x04\xf1\x02\r\x13\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xf1\x02\
    \x14\x1a\n\r\n\x05\x04*\x02\x02\x03\x12\x04\xf1\x02\x1d\x1e\n\x0c\n\x04\
    \x04*\x02\x03\x12\x04\xf2\x02\x04\x13\n\x0f\n\x05\x04*\x02\x03\x04\x12\
    \x06\xf2\x02\x04\xf1\x02\x1f\n\r\n\x05\x04*\x02\x03\x05\x12\x04\xf2\x02\
    \x04\t\n\r\n\x05\x04*\x02\x03\x01\x12\x04\xf2\x02\n\x0e\n\r\n\x05\x04*\
    \x02\x03\x03\x12\x04\xf2\x02\x11\x12\n\x0c\n\x04\x04*\x02\x04\x12\x04\
    \xf3\x02\x04\x13\n\x0f\n\x05\x04*\x02\x04\x04\x12\x06\xf3\x02\x04\xf2\
    \x02\x13\n\r\n\x05\x04*\x02\x04\x05\x12\x04\xf3\x02\x04\x08\n\r\n\x05\
    \x04*\x02\x04\x01\x12\x04\xf3\x02\t\x0e\n\r\n\x05\x04*\x02\x04\x03\x12\
    \x04\xf3\x02\x11\x12\n\x0c\n\x02\x04+\x12\x06\xf6\x02\0\xf8\x02\x01\n\
    \x0b\n\x03\x04+\x01\x12\x04\xf6\x02\x08\x11\n\x0c\n\x04\x04+\x02\0\x12\
    \x04\xf7\x02\x04\x1e\n\r\n\x05\x04+\x02\0\x04\x12\x04\xf7\x02\x04\x0c\n\
    \r\n\x05\x04+\x02\0\x05\x12\x04\xf7\x02\r\x13\n\r\n\x05\x04+\x02\0\x01\
    \x12\x04\xf7\x02\x14\x19\n\r\n\x05\x04+\x02\0\x03\x12\x04\xf7\x02\x1c\
    \x1d\n\x0c\n\x02\x04,\x12\x06\xfa\x02\0\xfc\x02\x01\n\x0b\n\x03\x04,\x01\
    \x12\x04\xfa\x02\x08\x13\n\x0c\n\x04\x04,\x02\0\x12\x04\xfb\x02\x04'\n\
    \x0f\n\x05\x04,\x02\0\x04\x12\x06\xfb\x02\x04\xfa\x02\x15\n\r\n\x05\x04,\
    \x02\0\x06\x12\x04\xfb\x02\x04\x1a\n\r\n\x05\x04,\x02\0\x01\x12\x04\xfb\
    \x02\x1b\"\n\r\n\x05\x04,\x02\0\x03\x12\x04\xfb\x02%&\n\x0c\n\x02\x04-\
    \x12\x06\xfe\x02\0\x81\x03\x01\n\x0b\n\x03\x04-\x01\x12\x04\xfe\x02\x08\
    \x13\n\x0c\n\x04\x04-\x02\0\x12\x04\xff\x02\x04\x1c\n\r\n\x05\x04-\x02\0\
    \x04\x12\x04\xff\x02\x04\x0c\n\r\n\x05\x04-\x02\0\x05\x12\x04\xff\x02\r\
    \x13\n\r\n\x05\x04-\x02\0\x01\x12\x04\xff\x02\x14\x17\n\r\n\x05\x04-\x02\
    \0\x03\x12\x04\xff\x02\x1a\x1b\n\x0c\n\x04\x04-\x02\x01\x12\x04\x80\x03\
    \x04\x20\n\x0f\n\x05\x04-\x02\x01\x04\x12\x06\x80\x03\x04\xff\x02\x1c\n\
    \r\n\x05\x04-\x02\x01\x06\x12\x04\x80\x03\x04\x16\n\r\n\x05\x04-\x02\x01\
    \x01\x12\x04\x80\x03\x17\x1b\n\r\n\x05\x04-\x02\x01\x03\x12\x04\x80\x03\
    \x1e\x1f\n\x0c\n\x02\x04.\x12\x06\x83\x03\0\x86\x03\x01\n\x0b\n\x03\x04.\
    \x01\x12\x04\x83\x03\x08\x13\n\x0c\n\x04\x04.\x02\0\x12\x04\x84\x03\x04\
    \x13\n\x0f\n\x05\x04.\x02\0\x04\x12\x06\x84\x03\x04\x83\x03\x15\n\r\n\
    \x05\x04.\x02\0\x05\x12\x04\x84\x03\x04\t\n\r\n\x05\x04.\x02\0\x01\x12\
    \x04\x84\x03\n\x0e\n\r\n\x05\x04.\x02\0\x03\x12\x04\x84\x03\x11\x12\n\
    \x0c\n\x04\x04.\x02\x01\x12\x04\x85\x03\x04\x17\n\x0f\n\x05\x04.\x02\x01\
    \x04\x12\x06\x85\x03\x04\x84\x03\x13\n\r\n\x05\x04.\x02\x01\x05\x12\x04\
    \x85\x03\x04\n\n\r\n\x05\x04.\x02\x01\x01\x12\x04\x85\x03\x0b\x12\n\r\n\
    \x05\x04.\x02\x01\x03\x12\x04\x85\x03\x15\x16\n\x0c\n\x02\x04/\x12\x06\
    \x88\x03\0\x8f\x03\x01\n\x0b\n\x03\x04/\x01\x12\x04\x88\x03\x08\x19\n\
    \x0c\n\x04\x04/\x02\0\x12\x04\x89\x03\x04\x12\n\x0f\n\x05\x04/\x02\0\x04\
    \x12\x06\x89\x03\x04\x88\x03\x1b\n\r\n\x05\x04/\x02\0\x05\x12\x04\x89\
    \x03\x04\n\n\r\n\x05\x04/\x02\0\x01\x12\x04\x89\x03\x0b\r\n\r\n\x05\x04/\
    \x02\0\x03\x12\x04\x89\x03\x10\x11\n\x0c\n\x04\x04/\x02\x01\x12\x04\x8a\
    \x03\x04\x16\n\x0f\n\x05\x04/\x02\x01\x04\x12\x06\x8a\x03\x04\x89\x03\
    \x12\n\r\n\x05\x04/\x02\x01\x05\x12\x04\x8a\x03\x04\n\n\r\n\x05\x04/\x02\
    \x01\x01\x12\x04\x8a\x03\x0b\x11\n\r\n\x05\x04/\x02\x01\x03\x12\x04\x8a\
    \x03\x14\x15\n\x0c\n\x04\x04/\x02\x02\x12\x04\x8b\x03\x04\x18\n\x0f\n\
    \x05\x04/\x02\x02\x04\x12\x06\x8b\x03\x04\x8a\x03\x16\n\r\n\x05\x04/\x02\
    \x02\x05\x12\x04\x8b\x03\x04\n\n\r\n\x05\x04/\x02\x02\x01\x12\x04\x8b\
    \x03\x0b\x13\n\r\n\x05\x04/\x02\x02\x03\x12\x04\x8b\x03\x16\x17\n\x0c\n\
    \x04\x04/\x02\x03\x12\x04\x8c\x03\x04\x15\n\x0f\n\x05\x04/\x02\x03\x04\
    \x12\x06\x8c\x03\x04\x8b\x03\x18\n\r\n\x05\x04/\x02\x03\x05\x12\x04\x8c\
    \x03\x04\n\n\r\n\x05\x04/\x02\x03\x01\x12\x04\x8c\x03\x0b\x10\n\r\n\x05\
    \x04/\x02\x03\x03\x12\x04\x8c\x03\x13\x14\n\x0c\n\x04\x04/\x02\x04\x12\
    \x04\x8d\x03\x04\x16\n\x0f\n\x05\x04/\x02\x04\x04\x12\x06\x8d\x03\x04\
    \x8c\x03\x15\n\r\n\x05\x04/\x02\x04\x05\x12\x04\x8d\x03\x04\n\n\r\n\x05\
    \x04/\x02\x04\x01\x12\x04\x8d\x03\x0b\x11\n\r\n\x05\x04/\x02\x04\x03\x12\
    \x04\x8d\x03\x14\x15\n\x0c\n\x04\x04/\x02\x05\x12\x04\x8e\x03\x04!\n\x0f\
    \n\x05\x04/\x02\x05\x04\x12\x06\x8e\x03\x04\x8d\x03\x16\n\r\n\x05\x04/\
    \x02\x05\x06\x12\x04\x8e\x03\x04\x0f\n\r\n\x05\x04/\x02\x05\x01\x12\x04\
    \x8e\x03\x10\x1c\n\r\n\x05\x04/\x02\x05\x03\x12\x04\x8e\x03\x1f\x20\n\
    \x0c\n\x02\x040\x12\x06\x91\x03\0\x9e\x03\x01\n\x0b\n\x03\x040\x01\x12\
    \x04\x91\x03\x08\x1e\n\x0c\n\x04\x040\x02\0\x12\x04\x92\x03\x04\x17\n\
    \x0f\n\x05\x040\x02\0\x04\x12\x06\x92\x03\x04\x91\x03\x20\n\r\n\x05\x040\
    \x02\0\x05\x12\x04\x92\x03\x04\n\n\r\n\x05\x040\x02\0\x01\x12\x04\x92\
    \x03\x0b\x12\n\r\n\x05\x040\x02\0\x03\x12\x04\x92\x03\x15\x16\n\x0c\n\
    \x04\x040\x02\x01\x12\x04\x93\x03\x04\x18\n\x0f\n\x05\x040\x02\x01\x04\
    \x12\x06\x93\x03\x04\x92\x03\x17\n\r\n\x05\x040\x02\x01\x05\x12\x04\x93\
    \x03\x04\n\n\r\n\x05\x040\x02\x01\x01\x12\x04\x93\x03\x0b\x13\n\r\n\x05\
    \x040\x02\x01\x03\x12\x04\x93\x03\x16\x17\n\x0c\n\x04\x040\x02\x02\x12\
    \x04\x94\x03\x04\x12\n\x0f\n\x05\x040\x02\x02\x04\x12\x06\x94\x03\x04\
    \x93\x03\x18\n\r\n\x05\x040\x02\x02\x05\x12\x04\x94\x03\x04\n\n\r\n\x05\
    \x040\x02\x02\x01\x12\x04\x94\x03\x0b\r\n\r\n\x05\x040\x02\x02\x03\x12\
    \x04\x94\x03\x10\x11\n\x0c\n\x04\x040\x02\x03\x12\x04\x95\x03\x04\x14\n\
    \x0f\n\x05\x040\x02\x03\x04\x12\x06\x95\x03\x04\x94\x03\x12\n\r\n\x05\
    \x040\x02\x03\x05\x12\x04\x95\x03\x04\n\n\r\n\x05\x040\x02\x03\x01\x12\
    \x04\x95\x03\x0b\x0f\n\r\n\x05\x040\x02\x03\x03\x12\x04\x95\x03\x12\x13\
    \n\x0c\n\x04\x040\x02\x04\x12\x04\x96\x03\x04\x15\n\x0f\n\x05\x040\x02\
    \x04\x04\x12\x06\x96\x03\x04\x95\x03\x14\n\r\n\x05\x040\x02\x04\x05\x12\
    \x04\x96\x03\x04\n\n\r\n\x05\x040\x02\x04\x01\x12\x04\x96\x03\x0b\x10\n\
    \r\n\x05\x040\x02\x04\x03\x12\x04\x96\x03\x13\x14\n\x0c\n\x04\x040\x02\
    \x05\x12\x04\x97\x03\x04\x15\n\x0f\n\x05\x040\x02\x05\x04\x12\x06\x97\
    \x03\x04\x96\x03\x15\n\r\n\x05\x040\x02\x05\x05\x12\x04\x97\x03\x04\x08\
    \n\r\n\x05\x040\x02\x05\x01\x12\x04\x97\x03\t\x10\n\r\n\x05\x040\x02\x05\
    \x03\x12\x04\x97\x03\x13\x14\n\x0c\n\x04\x040\x02\x06\x12\x04\x98\x03\
    \x04\x1f\n\x0f\n\x05\x040\x02\x06\x04\x12\x06\x98\x03\x04\x97\x03\x15\n\
    \r\n\x05\x040\x02\x06\x06\x12\x04\x98\x03\x04\x16\n\r\n\x05\x040\x02\x06\
    \x01\x12\x04\x98\x03\x17\x1a\n\r\n\x05\x040\x02\x06\x03\x12\x04\x98\x03\
    \x1d\x1e\n\x0c\n\x04\x040\x02\x07\x12\x04\x99\x03\x04\x15\n\x0f\n\x05\
    \x040\x02\x07\x04\x12\x06\x99\x03\x04\x98\x03\x1f\n\r\n\x05\x040\x02\x07\
    \x05\x12\x04\x99\x03\x04\n\n\r\n\x05\x040\x02\x07\x01\x12\x04\x99\x03\
    \x0b\x10\n\r\n\x05\x040\x02\x07\x03\x12\x04\x99\x03\x13\x14\n\x0c\n\x04\
    \x040\x02\x08\x12\x04\x9a\x03\x04\x15\n\x0f\n\x05\x040\x02\x08\x04\x12\
    \x06\x9a\x03\x04\x99\x03\x15\n\r\n\x05\x040\x02\x08\x05\x12\x04\x9a\x03\
    \x04\t\n\r\n\x05\x040\x02\x08\x01\x12\x04\x9a\x03\n\x10\n\r\n\x05\x040\
    \x02\x08\x03\x12\x04\x9a\x03\x13\x14\n\x0c\n\x04\x040\x02\t\x12\x04\x9b\
    \x03\x04%\n\x0f\n\x05\x040\x02\t\x04\x12\x06\x9b\x03\x04\x9a\x03\x15\n\r\
    \n\x05\x040\x02\t\x06\x12\x04\x9b\x03\x04\x17\n\r\n\x05\x040\x02\t\x01\
    \x12\x04\x9b\x03\x18\x1f\n\r\n\x05\x040\x02\t\x03\x12\x04\x9b\x03\"$\n\
    \x0c\n\x04\x040\x02\n\x12\x04\x9c\x03\x04\x14\n\x0f\n\x05\x040\x02\n\x04\
    \x12\x06\x9c\x03\x04\x9b\x03%\n\r\n\x05\x040\x02\n\x05\x12\x04\x9c\x03\
    \x04\t\n\r\n\x05\x040\x02\n\x01\x12\x04\x9c\x03\n\x0e\n\r\n\x05\x040\x02\
    \n\x03\x12\x04\x9c\x03\x11\x13\n\x0c\n\x04\x040\x02\x0b\x12\x04\x9d\x03\
    \x04\x17\n\x0f\n\x05\x040\x02\x0b\x04\x12\x06\x9d\x03\x04\x9c\x03\x14\n\
    \r\n\x05\x040\x02\x0b\x05\x12\x04\x9d\x03\x04\t\n\r\n\x05\x040\x02\x0b\
    \x01\x12\x04\x9d\x03\n\x11\n\r\n\x05\x040\x02\x0b\x03\x12\x04\x9d\x03\
    \x14\x16\n\x0c\n\x02\x041\x12\x06\xa0\x03\0\xa4\x03\x01\n\x0b\n\x03\x041\
    \x01\x12\x04\xa0\x03\x08\x1f\n\x0c\n\x04\x041\x02\0\x12\x04\xa1\x03\x04&\
    \n\x0f\n\x05\x041\x02\0\x04\x12\x06\xa1\x03\x04\xa0\x03!\n\r\n\x05\x041\
    \x02\0\x06\x12\x04\xa1\x03\x04\x1a\n\r\n\x05\x041\x02\0\x01\x12\x04\xa1\
    \x03\x1b!\n\r\n\x05\x041\x02\0\x03\x12\x04\xa1\x03$%\n\x0c\n\x04\x041\
    \x02\x01\x12\x04\xa2\x03\x04&\n\x0f\n\x05\x041\x02\x01\x04\x12\x06\xa2\
    \x03\x04\xa1\x03&\n\r\n\x05\x041\x02\x01\x06\x12\x04\xa2\x03\x04\x1a\n\r\
    \n\x05\x041\x02\x01\x01\x12\x04\xa2\x03\x1b!\n\r\n\x05\x041\x02\x01\x03\
    \x12\x04\xa2\x03$%\n\x0c\n\x04\x041\x02\x02\x12\x04\xa3\x03\x04\x15\n\
    \x0f\n\x05\x041\x02\x02\x04\x12\x06\xa3\x03\x04\xa2\x03&\n\r\n\x05\x041\
    \x02\x02\x05\x12\x04\xa3\x03\x04\n\n\r\n\x05\x041\x02\x02\x01\x12\x04\
    \xa3\x03\x0b\x10\n\r\n\x05\x041\x02\x02\x03\x12\x04\xa3\x03\x13\x14\n\
    \x0c\n\x02\x042\x12\x06\xa6\x03\0\xab\x03\x01\n\x0b\n\x03\x042\x01\x12\
    \x04\xa6\x03\x08\x19\n\x0c\n\x04\x042\x02\0\x12\x04\xa7\x03\x04\x15\n\
    \x0f\n\x05\x042\x02\0\x04\x12\x06\xa7\x03\x04\xa6\x03\x1b\n\r\n\x05\x042\
    \x02\0\x05\x12\x04\xa7\x03\x04\n\n\r\n\x05\x042\x02\0\x01\x12\x04\xa7\
    \x03\x0b\x10\n\r\n\x05\x042\x02\0\x03\x12\x04\xa7\x03\x13\x14\n\x0c\n\
    \x04\x042\x02\x01\x12\x04\xa8\x03\x04\x15\n\x0f\n\x05\x042\x02\x01\x04\
    \x12\x06\xa8\x03\x04\xa7\x03\x15\n\r\n\x05\x042\x02\x01\x05\x12\x04\xa8\
    \x03\x04\x08\n\r\n\x05\x042\x02\x01\x01\x12\x04\xa8\x03\t\x10\n\r\n\x05\
    \x042\x02\x01\x03\x12\x04\xa8\x03\x13\x14\n\x0c\n\x04\x042\x02\x02\x12\
    \x04\xa9\x03\x04\x18\n\x0f\n\x05\x042\x02\x02\x04\x12\x06\xa9\x03\x04\
    \xa8\x03\x15\n\r\n\x05\x042\x02\x02\x05\x12\x04\xa9\x03\x04\n\n\r\n\x05\
    \x042\x02\x02\x01\x12\x04\xa9\x03\x0b\x13\n\r\n\x05\x042\x02\x02\x03\x12\
    \x04\xa9\x03\x16\x17\n\x0c\n\x04\x042\x02\x03\x12\x04\xaa\x03\x04\x17\n\
    \x0f\n\x05\x042\x02\x03\x04\x12\x06\xaa\x03\x04\xa9\x03\x18\n\r\n\x05\
    \x042\x02\x03\x05\x12\x04\xaa\x03\x04\n\n\r\n\x05\x042\x02\x03\x01\x12\
    \x04\xaa\x03\x0b\x12\n\r\n\x05\x042\x02\x03\x03\x12\x04\xaa\x03\x15\x16\
    \n\x0c\n\x02\x043\x12\x06\xad\x03\0\xb1\x03\x01\n\x0b\n\x03\x043\x01\x12\
    \x04\xad\x03\x08\x1a\n\x0c\n\x04\x043\x02\0\x12\x04\xae\x03\x04\x15\n\
    \x0f\n\x05\x043\x02\0\x04\x12\x06\xae\x03\x04\xad\x03\x1c\n\r\n\x05\x043\
    \x02\0\x05\x12\x04\xae\x03\x04\n\n\r\n\x05\x043\x02\0\x01\x12\x04\xae\
    \x03\x0b\x10\n\r\n\x05\x043\x02\0\x03\x12\x04\xae\x03\x13\x14\n\x0c\n\
    \x04\x043\x02\x01\x12\x04\xaf\x03\x04\x15\n\x0f\n\x05\x043\x02\x01\x04\
    \x12\x06\xaf\x03\x04\xae\x03\x15\n\r\n\x05\x043\x02\x01\x05\x12\x04\xaf\
    \x03\x04\x08\n\r\n\x05\x043\x02\x01\x01\x12\x04\xaf\x03\t\x10\n\r\n\x05\
    \x043\x02\x01\x03\x12\x04\xaf\x03\x13\x14\n\x0c\n\x04\x043\x02\x02\x12\
    \x04\xb0\x03\x04!\n\r\n\x05\x043\x02\x02\x04\x12\x04\xb0\x03\x04\x0c\n\r\
    \n\x05\x043\x02\x02\x05\x12\x04\xb0\x03\r\x13\n\r\n\x05\x043\x02\x02\x01\
    \x12\x04\xb0\x03\x14\x1c\n\r\n\x05\x043\x02\x02\x03\x12\x04\xb0\x03\x1f\
    \x20\n\x0c\n\x02\x044\x12\x06\xb3\x03\0\xb7\x03\x01\n\x0b\n\x03\x044\x01\
    \x12\x04\xb3\x03\x08\x1e\n\x0c\n\x04\x044\x02\0\x12\x04\xb4\x03\x04\x12\
    \n\x0f\n\x05\x044\x02\0\x04\x12\x06\xb4\x03\x04\xb3\x03\x20\n\r\n\x05\
    \x044\x02\0\x05\x12\x04\xb4\x03\x04\n\n\r\n\x05\x044\x02\0\x01\x12\x04\
    \xb4\x03\x0b\r\n\r\n\x05\x044\x02\0\x03\x12\x04\xb4\x03\x10\x11\n\x0c\n\
    \x04\x044\x02\x01\x12\x04\xb5\x03\x04\x15\n\x0f\n\x05\x044\x02\x01\x04\
    \x12\x06\xb5\x03\x04\xb4\x03\x12\n\r\n\x05\x044\x02\x01\x05\x12\x04\xb5\
    \x03\x04\x08\n\r\n\x05\x044\x02\x01\x01\x12\x04\xb5\x03\t\x10\n\r\n\x05\
    \x044\x02\x01\x03\x12\x04\xb5\x03\x13\x14\n\x0c\n\x04\x044\x02\x02\x12\
    \x04\xb6\x03\x04\x14\n\x0f\n\x05\x044\x02\x02\x04\x12\x06\xb6\x03\x04\
    \xb5\x03\x15\n\r\n\x05\x044\x02\x02\x05\x12\x04\xb6\x03\x04\n\n\r\n\x05\
    \x044\x02\x02\x01\x12\x04\xb6\x03\x0b\x0f\n\r\n\x05\x044\x02\x02\x03\x12\
    \x04\xb6\x03\x12\x13\n\x0c\n\x02\x045\x12\x06\xb9\x03\0\xbc\x03\x01\n\
    \x0b\n\x03\x045\x01\x12\x04\xb9\x03\x08\"\n\x0c\n\x04\x045\x02\0\x12\x04\
    \xba\x03\x04\x12\n\x0f\n\x05\x045\x02\0\x04\x12\x06\xba\x03\x04\xb9\x03$\
    \n\r\n\x05\x045\x02\0\x05\x12\x04\xba\x03\x04\n\n\r\n\x05\x045\x02\0\x01\
    \x12\x04\xba\x03\x0b\r\n\r\n\x05\x045\x02\0\x03\x12\x04\xba\x03\x10\x11\
    \n\x0c\n\x04\x045\x02\x01\x12\x04\xbb\x03\x04\x15\n\x0f\n\x05\x045\x02\
    \x01\x04\x12\x06\xbb\x03\x04\xba\x03\x12\n\r\n\x05\x045\x02\x01\x05\x12\
    \x04\xbb\x03\x04\n\n\r\n\x05\x045\x02\x01\x01\x12\x04\xbb\x03\x0b\x10\n\
    \r\n\x05\x045\x02\x01\x03\x12\x04\xbb\x03\x13\x14\n\x0c\n\x02\x046\x12\
    \x06\xbe\x03\0\xc1\x03\x01\n\x0b\n\x03\x046\x01\x12\x04\xbe\x03\x08\x1e\
    \n\x0c\n\x04\x046\x02\0\x12\x04\xbf\x03\x04\x12\n\x0f\n\x05\x046\x02\0\
    \x04\x12\x06\xbf\x03\x04\xbe\x03\x20\n\r\n\x05\x046\x02\0\x05\x12\x04\
    \xbf\x03\x04\n\n\r\n\x05\x046\x02\0\x01\x12\x04\xbf\x03\x0b\r\n\r\n\x05\
    \x046\x02\0\x03\x12\x04\xbf\x03\x10\x11\n\x0c\n\x04\x046\x02\x01\x12\x04\
    \xc0\x03\x04\x15\n\x0f\n\x05\x046\x02\x01\x04\x12\x06\xc0\x03\x04\xbf\
    \x03\x12\n\r\n\x05\x046\x02\x01\x05\x12\x04\xc0\x03\x04\x08\n\r\n\x05\
    \x046\x02\x01\x01\x12\x04\xc0\x03\t\x10\n\r\n\x05\x046\x02\x01\x03\x12\
    \x04\xc0\x03\x13\x14\n\x0c\n\x02\x047\x12\x06\xc3\x03\0\xca\x03\x01\n\
    \x0b\n\x03\x047\x01\x12\x04\xc3\x03\x08\x13\n\x0c\n\x04\x047\x02\0\x12\
    \x04\xc4\x03\x04\x12\n\x0f\n\x05\x047\x02\0\x04\x12\x06\xc4\x03\x04\xc3\
    \x03\x15\n\r\n\x05\x047\x02\0\x05\x12\x04\xc4\x03\x04\n\n\r\n\x05\x047\
    \x02\0\x01\x12\x04\xc4\x03\x0b\r\n\r\n\x05\x047\x02\0\x03\x12\x04\xc4\
    \x03\x10\x11\n\x0c\n\x04\x047\x02\x01\x12\x04\xc5\x03\x04\x16\n\x0f\n\
    \x05\x047\x02\x01\x04\x12\x06\xc5\x03\x04\xc4\x03\x12\n\r\n\x05\x047\x02\
    \x01\x05\x12\x04\xc5\x03\x04\n\n\r\n\x05\x047\x02\x01\x01\x12\x04\xc5\
    \x03\x0b\x11\n\r\n\x05\x047\x02\x01\x03\x12\x04\xc5\x03\x14\x15\n\x0c\n\
    \x04\x047\x02\x02\x12\x04\xc6\x03\x04\x14\n\x0f\n\x05\x047\x02\x02\x04\
    \x12\x06\xc6\x03\x04\xc5\x03\x16\n\r\n\x05\x047\x02\x02\x05\x12\x04\xc6\
    \x03\x04\n\n\r\n\x05\x047\x02\x02\x01\x12\x04\xc6\x03\x0b\x0f\n\r\n\x05\
    \x047\x02\x02\x03\x12\x04\xc6\x03\x12\x13\n\x0c\n\x04\x047\x02\x03\x12\
    \x04\xc7\x03\x04\x14\n\x0f\n\x05\x047\x02\x03\x04\x12\x06\xc7\x03\x04\
    \xc6\x03\x14\n\r\n\x05\x047\x02\x03\x05\x12\x04\xc7\x03\x04\n\n\r\n\x05\
    \x047\x02\x03\x01\x12\x04\xc7\x03\x0b\x0f\n\r\n\x05\x047\x02\x03\x03\x12\
    \x04\xc7\x03\x12\x13\n\x0c\n\x04\x047\x02\x04\x12\x04\xc8\x03\x04\x15\n\
    \x0f\n\x05\x047\x02\x04\x04\x12\x06\xc8\x03\x04\xc7\x03\x14\n\r\n\x05\
    \x047\x02\x04\x05\x12\x04\xc8\x03\x04\n\n\r\n\x05\x047\x02\x04\x01\x12\
    \x04\xc8\x03\x0b\x10\n\r\n\x05\x047\x02\x04\x03\x12\x04\xc8\x03\x13\x14\
    \n\x0c\n\x04\x047\x02\x05\x12\x04\xc9\x03\x04\x13\n\x0f\n\x05\x047\x02\
    \x05\x04\x12\x06\xc9\x03\x04\xc8\x03\x15\n\r\n\x05\x047\x02\x05\x05\x12\
    \x04\xc9\x03\x04\t\n\r\n\x05\x047\x02\x05\x01\x12\x04\xc9\x03\n\x0e\n\r\
    \n\x05\x047\x02\x05\x03\x12\x04\xc9\x03\x11\x12\n\x0c\n\x02\x048\x12\x06\
    \xcc\x03\0\xd0\x03\x01\n\x0b\n\x03\x048\x01\x12\x04\xcc\x03\x08\x13\n\
    \x0c\n\x04\x048\x02\0\x12\x04\xcd\x03\x04\x12\n\x0f\n\x05\x048\x02\0\x04\
    \x12\x06\xcd\x03\x04\xcc\x03\x15\n\r\n\x05\x048\x02\0\x05\x12\x04\xcd\
    \x03\x04\n\n\r\n\x05\x048\x02\0\x01\x12\x04\xcd\x03\x0b\r\n\r\n\x05\x048\
    \x02\0\x03\x12\x04\xcd\x03\x10\x11\n\x0c\n\x04\x048\x02\x01\x12\x04\xce\
    \x03\x04\x14\n\x0f\n\x05\x048\x02\x01\x04\x12\x06\xce\x03\x04\xcd\x03\
    \x12\n\r\n\x05\x048\x02\x01\x05\x12\x04\xce\x03\x04\n\n\r\n\x05\x048\x02\
    \x01\x01\x12\x04\xce\x03\x0b\x0f\n\r\n\x05\x048\x02\x01\x03\x12\x04\xce\
    \x03\x12\x13\n\x0c\n\x04\x048\x02\x02\x12\x04\xcf\x03\x04\x15\n\x0f\n\
    \x05\x048\x02\x02\x04\x12\x06\xcf\x03\x04\xce\x03\x14\n\r\n\x05\x048\x02\
    \x02\x05\x12\x04\xcf\x03\x04\n\n\r\n\x05\x048\x02\x02\x01\x12\x04\xcf\
    \x03\x0b\x10\n\r\n\x05\x048\x02\x02\x03\x12\x04\xcf\x03\x13\x14\n\x0c\n\
    \x02\x049\x12\x06\xd2\x03\0\xd5\x03\x01\n\x0b\n\x03\x049\x01\x12\x04\xd2\
    \x03\x08\x1e\n\x0c\n\x04\x049\x02\0\x12\x04\xd3\x03\x04\x1c\n\x0f\n\x05\
    \x049\x02\0\x04\x12\x06\xd3\x03\x04\xd2\x03\x20\n\r\n\x05\x049\x02\0\x05\
    \x12\x04\xd3\x03\x04\n\n\r\n\x05\x049\x02\0\x01\x12\x04\xd3\x03\x0b\x17\
    \n\r\n\x05\x049\x02\0\x03\x12\x04\xd3\x03\x1a\x1b\n\x0c\n\x04\x049\x02\
    \x01\x12\x04\xd4\x03\x04\x13\n\x0f\n\x05\x049\x02\x01\x04\x12\x06\xd4\
    \x03\x04\xd3\x03\x1c\n\r\n\x05\x049\x02\x01\x05\x12\x04\xd4\x03\x04\t\n\
    \r\n\x05\x049\x02\x01\x01\x12\x04\xd4\x03\n\x0e\n\r\n\x05\x049\x02\x01\
    \x03\x12\x04\xd4\x03\x11\x12\n\x0c\n\x02\x04:\x12\x06\xd7\x03\0\xdc\x03\
    \x01\n\x0b\n\x03\x04:\x01\x12\x04\xd7\x03\x08\x19\n\x0c\n\x04\x04:\x02\0\
    \x12\x04\xd8\x03\x04%\n\x0f\n\x05\x04:\x02\0\x04\x12\x06\xd8\x03\x04\xd7\
    \x03\x1a\n\r\n\x05\x04:\x02\0\x06\x12\x04\xd8\x03\x04\x11\n\r\n\x05\x04:\
    \x02\0\x01\x12\x04\xd8\x03\x12\x20\n\r\n\x05\x04:\x02\0\x03\x12\x04\xd8\
    \x03#$\n\x0c\n\x04\x04:\x02\x01\x12\x04\xd9\x03\x04\x12\n\x0f\n\x05\x04:\
    \x02\x01\x04\x12\x06\xd9\x03\x04\xd8\x03%\n\r\n\x05\x04:\x02\x01\x05\x12\
    \x04\xd9\x03\x04\t\n\r\n\x05\x04:\x02\x01\x01\x12\x04\xd9\x03\n\r\n\r\n\
    \x05\x04:\x02\x01\x03\x12\x04\xd9\x03\x10\x11\n\x0c\n\x04\x04:\x02\x02\
    \x12\x04\xda\x03\x04\x13\n\x0f\n\x05\x04:\x02\x02\x04\x12\x06\xda\x03\
    \x04\xd9\x03\x12\n\r\n\x05\x04:\x02\x02\x05\x12\x04\xda\x03\x04\x08\n\r\
    \n\x05\x04:\x02\x02\x01\x12\x04\xda\x03\t\x0e\n\r\n\x05\x04:\x02\x02\x03\
    \x12\x04\xda\x03\x11\x12\n\x0c\n\x04\x04:\x02\x03\x12\x04\xdb\x03\x04\
    \x1c\n\x0f\n\x05\x04:\x02\x03\x04\x12\x06\xdb\x03\x04\xda\x03\x13\n\r\n\
    \x05\x04:\x02\x03\x05\x12\x04\xdb\x03\x04\t\n\r\n\x05\x04:\x02\x03\x01\
    \x12\x04\xdb\x03\n\x17\n\r\n\x05\x04:\x02\x03\x03\x12\x04\xdb\x03\x1a\
    \x1b\n\x0c\n\x02\x04;\x12\x06\xde\x03\0\xe2\x03\x01\n\x0b\n\x03\x04;\x01\
    \x12\x04\xde\x03\x08\x1f\n\x0c\n\x04\x04;\x02\0\x12\x04\xdf\x03\x04\x1c\
    \n\r\n\x05\x04;\x02\0\x04\x12\x04\xdf\x03\x04\x0c\n\r\n\x05\x04;\x02\0\
    \x05\x12\x04\xdf\x03\r\x13\n\r\n\x05\x04;\x02\0\x01\x12\x04\xdf\x03\x14\
    \x17\n\r\n\x05\x04;\x02\0\x03\x12\x04\xdf\x03\x1a\x1b\n\x0c\n\x04\x04;\
    \x02\x01\x12\x04\xe0\x03\x04\x14\n\x0f\n\x05\x04;\x02\x01\x04\x12\x06\
    \xe0\x03\x04\xdf\x03\x1c\n\r\n\x05\x04;\x02\x01\x05\x12\x04\xe0\x03\x04\
    \n\n\r\n\x05\x04;\x02\x01\x01\x12\x04\xe0\x03\x0b\x0f\n\r\n\x05\x04;\x02\
    \x01\x03\x12\x04\xe0\x03\x12\x13\n\x0c\n\x04\x04;\x02\x02\x12\x04\xe1\
    \x03\x04\x13\n\x0f\n\x05\x04;\x02\x02\x04\x12\x06\xe1\x03\x04\xe0\x03\
    \x14\n\r\n\x05\x04;\x02\x02\x05\x12\x04\xe1\x03\x04\x08\n\r\n\x05\x04;\
    \x02\x02\x01\x12\x04\xe1\x03\t\x0e\n\r\n\x05\x04;\x02\x02\x03\x12\x04\
    \xe1\x03\x11\x12\n\x0c\n\x02\x04<\x12\x06\xe4\x03\0\xe8\x03\x01\n\x0b\n\
    \x03\x04<\x01\x12\x04\xe4\x03\x08\x1f\n\x0c\n\x04\x04<\x02\0\x12\x04\xe5\
    \x03\x04\x12\n\x0f\n\x05\x04<\x02\0\x04\x12\x06\xe5\x03\x04\xe4\x03!\n\r\
    \n\x05\x04<\x02\0\x05\x12\x04\xe5\x03\x04\n\n\r\n\x05\x04<\x02\0\x01\x12\
    \x04\xe5\x03\x0b\r\n\r\n\x05\x04<\x02\0\x03\x12\x04\xe5\x03\x10\x11\n\
    \x0c\n\x04\x04<\x02\x01\x12\x04\xe6\x03\x04\x15\n\x0f\n\x05\x04<\x02\x01\
    \x04\x12\x06\xe6\x03\x04\xe5\x03\x12\n\r\n\x05\x04<\x02\x01\x05\x12\x04\
    \xe6\x03\x04\n\n\r\n\x05\x04<\x02\x01\x01\x12\x04\xe6\x03\x0b\x10\n\r\n\
    \x05\x04<\x02\x01\x03\x12\x04\xe6\x03\x13\x14\n\x0c\n\x04\x04<\x02\x02\
    \x12\x04\xe7\x03\x04\x13\n\x0f\n\x05\x04<\x02\x02\x04\x12\x06\xe7\x03\
    \x04\xe6\x03\x15\n\r\n\x05\x04<\x02\x02\x05\x12\x04\xe7\x03\x04\t\n\r\n\
    \x05\x04<\x02\x02\x01\x12\x04\xe7\x03\n\x0e\n\r\n\x05\x04<\x02\x02\x03\
    \x12\x04\xe7\x03\x11\x12\n\x0c\n\x02\x04=\x12\x06\xea\x03\0\xee\x03\x01\
    \n\x0b\n\x03\x04=\x01\x12\x04\xea\x03\x08\x18\n\x0c\n\x04\x04=\x02\0\x12\
    \x04\xeb\x03\x04\x12\n\x0f\n\x05\x04=\x02\0\x04\x12\x06\xeb\x03\x04\xea\
    \x03\x1a\n\r\n\x05\x04=\x02\0\x05\x12\x04\xeb\x03\x04\n\n\r\n\x05\x04=\
    \x02\0\x01\x12\x04\xeb\x03\x0b\r\n\r\n\x05\x04=\x02\0\x03\x12\x04\xeb\
    \x03\x10\x11\n\x0c\n\x04\x04=\x02\x01\x12\x04\xec\x03\x04\x15\n\x0f\n\
    \x05\x04=\x02\x01\x04\x12\x06\xec\x03\x04\xeb\x03\x12\n\r\n\x05\x04=\x02\
    \x01\x05\x12\x04\xec\x03\x04\n\n\r\n\x05\x04=\x02\x01\x01\x12\x04\xec\
    \x03\x0b\x10\n\r\n\x05\x04=\x02\x01\x03\x12\x04\xec\x03\x13\x14\n\x0c\n\
    \x04\x04=\x02\x02\x12\x04\xed\x03\x04\x13\n\x0f\n\x05\x04=\x02\x02\x04\
    \x12\x06\xed\x03\x04\xec\x03\x15\n\r\n\x05\x04=\x02\x02\x05\x12\x04\xed\
    \x03\x04\t\n\r\n\x05\x04=\x02\x02\x01\x12\x04\xed\x03\n\x0e\n\r\n\x05\
    \x04=\x02\x02\x03\x12\x04\xed\x03\x11\x12\n\x0c\n\x02\x04>\x12\x06\xf0\
    \x03\0\xf7\x03\x01\n\x0b\n\x03\x04>\x01\x12\x04\xf0\x03\x08\x1f\n\x0c\n\
    \x04\x04>\x02\0\x12\x04\xf1\x03\x04\x1c\n\x0f\n\x05\x04>\x02\0\x04\x12\
    \x06\xf1\x03\x04\xf0\x03!\n\r\n\x05\x04>\x02\0\x05\x12\x04\xf1\x03\x04\n\
    \n\r\n\x05\x04>\x02\0\x01\x12\x04\xf1\x03\x0b\x17\n\r\n\x05\x04>\x02\0\
    \x03\x12\x04\xf1\x03\x1a\x1b\n\x0c\n\x04\x04>\x02\x01\x12\x04\xf2\x03\
    \x04!\n\r\n\x05\x04>\x02\x01\x04\x12\x04\xf2\x03\x04\x0c\n\r\n\x05\x04>\
    \x02\x01\x05\x12\x04\xf2\x03\r\x13\n\r\n\x05\x04>\x02\x01\x01\x12\x04\
    \xf2\x03\x14\x1c\n\r\n\x05\x04>\x02\x01\x03\x12\x04\xf2\x03\x1f\x20\n\
    \x0c\n\x04\x04>\x02\x02\x12\x04\xf3\x03\x04\x1d\n\r\n\x05\x04>\x02\x02\
    \x04\x12\x04\xf3\x03\x04\x0c\n\r\n\x05\x04>\x02\x02\x05\x12\x04\xf3\x03\
    \r\x13\n\r\n\x05\x04>\x02\x02\x01\x12\x04\xf3\x03\x14\x18\n\r\n\x05\x04>\
    \x02\x02\x03\x12\x04\xf3\x03\x1b\x1c\n\x0c\n\x04\x04>\x02\x03\x12\x04\
    \xf4\x03\x04\x17\n\x0f\n\x05\x04>\x02\x03\x04\x12\x06\xf4\x03\x04\xf3\
    \x03\x1d\n\r\n\x05\x04>\x02\x03\x05\x12\x04\xf4\x03\x04\n\n\r\n\x05\x04>\
    \x02\x03\x01\x12\x04\xf4\x03\x0b\x12\n\r\n\x05\x04>\x02\x03\x03\x12\x04\
    \xf4\x03\x15\x16\n\x0c\n\x04\x04>\x02\x04\x12\x04\xf5\x03\x04\x18\n\x0f\
    \n\x05\x04>\x02\x04\x04\x12\x06\xf5\x03\x04\xf4\x03\x17\n\r\n\x05\x04>\
    \x02\x04\x05\x12\x04\xf5\x03\x04\x08\n\r\n\x05\x04>\x02\x04\x01\x12\x04\
    \xf5\x03\t\x13\n\r\n\x05\x04>\x02\x04\x03\x12\x04\xf5\x03\x16\x17\n\x0c\
    \n\x04\x04>\x02\x05\x12\x04\xf6\x03\x04\x17\n\x0f\n\x05\x04>\x02\x05\x04\
    \x12\x06\xf6\x03\x04\xf5\x03\x18\n\r\n\x05\x04>\x02\x05\x05\x12\x04\xf6\
    \x03\x04\t\n\r\n\x05\x04>\x02\x05\x01\x12\x04\xf6\x03\n\x12\n\r\n\x05\
    \x04>\x02\x05\x03\x12\x04\xf6\x03\x15\x16b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
